/* WARNING: THIS FILE IS AUTOMATICALLY GENERATED FROM A .SM FILE.
 * Changes made here will certainly be overwritten.
 */


/* 
 * (C) 2009 BeiHang University 
 *
 * See COPYING in top-level directory.
 *
 */

#include <string.h>
#include <assert.h>
#include <unistd.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-types-debug.h"
#include "pint-cached-config.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-perf-counter.h"

extern double        load_diff;
extern double        g_high_load;
extern double        g_low_load;
extern PVFS_handle   mig_datafile_handle;
extern PVFS_handle   rt_handle;
extern int           candidate_find; 
extern char          access_size[10]; 
extern double        global_max_load_access_size;

enum 
{
	MIGRATION_OVER = 10
};
/**
   state machine description
   1.init lock on metadata
   2.send migration request
   3.post flow
   4.modify metadata
   5.end of state machine
*/

#define IO_SM_PHASE_FLOW                                     0
#define IO_SM_PHASE_FINAL_ACK                                1
#define IO_SM_NUM_PHASES                                     2

#define STATUS_USER_TAG_TYPE(tag, type)		\
	((tag % IO_SM_NUM_PHASES) == type)
#define STATUS_USER_TAG_GET_INDEX(tag, type)	\
	(tag / IO_SM_NUM_PHASES)
#define STATUS_USER_TAG_IS_SEND_OR_RECV(tag)				\
	(STATUS_USER_TAG_TYPE(tag, IO_SM_PHASE_REQ_MSGPAIR_RECV) ||	\
	 STATUS_USER_TAG_TYPE(tag, IO_SM_PHASE_REQ_MSGPAIR_SEND))

#define PINT_init_msgpair(sm_p, msg_p)					\
	do {								\
		msg_p = &sm_p->msgarray_op.msgpair;			\
		memset(msg_p, 0, sizeof(PINT_sm_msgpair_state));	\
		if (sm_p->msgarray_op.msgarray && (sm_p->msgarray_op.msgarray != &(sm_p->msgarray_op.msgpair))) \
		{							\
			sm_p->msgarray_op.msgarray = NULL;		\
		}							\
		sm_p->msgarray_op.msgarray = msg_p;			\
		sm_p->msgarray_op.count = 1;				\
	} while(0)


static PINT_sm_action init_migration(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_init;
static struct PINT_pjmp_tbl_s ST_init_pjtbl[];
static struct PINT_tran_tbl_s ST_init_trtbl[];

static PINT_sm_action getattr_migration(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_getattr_migration;
static struct PINT_pjmp_tbl_s ST_getattr_migration_pjtbl[];
static struct PINT_tran_tbl_s ST_getattr_migration_trtbl[];

static PINT_sm_action send_migration_request(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_send_migration_request;
static struct PINT_pjmp_tbl_s ST_send_migration_request_pjtbl[];
static struct PINT_tran_tbl_s ST_send_migration_request_trtbl[];
static struct PINT_state_s ST_send_migration_request_xfer_msgpair;
static struct PINT_pjmp_tbl_s ST_send_migration_request_xfer_msgpair_pjtbl[];
static struct PINT_tran_tbl_s ST_send_migration_request_xfer_msgpair_trtbl[];

static PINT_sm_action post_flow(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_post_flow;
static struct PINT_pjmp_tbl_s ST_post_flow_pjtbl[];
static struct PINT_tran_tbl_s ST_post_flow_trtbl[];

static PINT_sm_action post_complete_ack(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_post_complete_ack;
static struct PINT_pjmp_tbl_s ST_post_complete_ack_pjtbl[];
static struct PINT_tran_tbl_s ST_post_complete_ack_trtbl[];

static PINT_sm_action test_send_one_msg_f(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_test_send_one_msg;
static struct PINT_pjmp_tbl_s ST_test_send_one_msg_pjtbl[];
static struct PINT_tran_tbl_s ST_test_send_one_msg_trtbl[];

static PINT_sm_action update_metadata(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_update_metadata;
static struct PINT_pjmp_tbl_s ST_update_metadata_pjtbl[];
static struct PINT_tran_tbl_s ST_update_metadata_trtbl[];
static struct PINT_state_s ST_update_metadata_request_xfer_msgpair;
static struct PINT_pjmp_tbl_s ST_update_metadata_request_xfer_msgpair_pjtbl[];
static struct PINT_tran_tbl_s ST_update_metadata_request_xfer_msgpair_trtbl[];

static PINT_sm_action remove_datafile_handle(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_remove_datafile_handle;
static struct PINT_pjmp_tbl_s ST_remove_datafile_handle_pjtbl[];
static struct PINT_tran_tbl_s ST_remove_datafile_handle_trtbl[];

static PINT_sm_action cleanup(
	struct PINT_smcb *smcb, job_status_s *js_p);

static struct PINT_state_s ST_cleanup;
static struct PINT_pjmp_tbl_s ST_cleanup_pjtbl[];
static struct PINT_tran_tbl_s ST_cleanup_trtbl[];

struct PINT_state_machine_s pvfs2_migrate_file_sm = {
	.name = "pvfs2_migrate_file_sm",
	.first_state = &ST_init
};

static struct PINT_state_s ST_init = {
	 .state_name = "init" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = init_migration ,
	 .pjtbl = NULL ,
	 .trtbl = ST_init_trtbl 
};

static struct PINT_tran_tbl_s ST_init_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_getattr_migration },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_getattr_migration = {
	 .state_name = "getattr_migration" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = getattr_migration ,
	 .pjtbl = NULL ,
	 .trtbl = ST_getattr_migration_trtbl 
};

static struct PINT_tran_tbl_s ST_getattr_migration_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_send_migration_request },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_send_migration_request = {
	 .state_name = "send_migration_request" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = send_migration_request ,
	 .pjtbl = NULL ,
	 .trtbl = ST_send_migration_request_trtbl 
};

static struct PINT_tran_tbl_s ST_send_migration_request_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_send_migration_request_xfer_msgpair },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_send_migration_request_xfer_msgpair = {
	 .state_name = "send_migration_request_xfer_msgpair" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_JUMP ,
	 .action.nested = &pvfs2_msgpairarray_sm ,
	 .pjtbl = NULL ,
	 .trtbl = ST_send_migration_request_xfer_msgpair_trtbl 
};

static struct PINT_tran_tbl_s ST_send_migration_request_xfer_msgpair_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_post_flow },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_post_flow = {
	 .state_name = "post_flow" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = post_flow ,
	 .pjtbl = NULL ,
	 .trtbl = ST_post_flow_trtbl 
};

static struct PINT_tran_tbl_s ST_post_flow_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_post_complete_ack },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_post_complete_ack = {
	 .state_name = "post_complete_ack" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = post_complete_ack ,
	 .pjtbl = NULL ,
	 .trtbl = ST_post_complete_ack_trtbl 
};

static struct PINT_tran_tbl_s ST_post_complete_ack_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_test_send_one_msg },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_test_send_one_msg = {
	 .state_name = "test_send_one_msg" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = test_send_one_msg_f ,
	 .pjtbl = NULL ,
	 .trtbl = ST_test_send_one_msg_trtbl 
};

static struct PINT_tran_tbl_s ST_test_send_one_msg_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_update_metadata },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_update_metadata = {
	 .state_name = "update_metadata" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = update_metadata ,
	 .pjtbl = NULL ,
	 .trtbl = ST_update_metadata_trtbl 
};

static struct PINT_tran_tbl_s ST_update_metadata_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_update_metadata_request_xfer_msgpair },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_update_metadata_request_xfer_msgpair = {
	 .state_name = "update_metadata_request_xfer_msgpair" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_JUMP ,
	 .action.nested = &pvfs2_msgpairarray_sm ,
	 .pjtbl = NULL ,
	 .trtbl = ST_update_metadata_request_xfer_msgpair_trtbl 
};

static struct PINT_tran_tbl_s ST_update_metadata_request_xfer_msgpair_trtbl[] = {
	{ .return_value = 0 ,
	 .next_state = &ST_remove_datafile_handle },
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_remove_datafile_handle = {
	 .state_name = "remove_datafile_handle" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = remove_datafile_handle ,
	 .pjtbl = NULL ,
	 .trtbl = ST_remove_datafile_handle_trtbl 
};

static struct PINT_tran_tbl_s ST_remove_datafile_handle_trtbl[] = {
	{ .return_value = -1 ,
	 .next_state = &ST_cleanup }
};

static struct PINT_state_s ST_cleanup = {
	 .state_name = "cleanup" ,
	 .parent_machine = &pvfs2_migrate_file_sm ,
	 .flag = SM_RUN ,
	 .action.func = cleanup ,
	 .pjtbl = NULL ,
	 .trtbl = ST_cleanup_trtbl 
};

static struct PINT_tran_tbl_s ST_cleanup_trtbl[] = {
	{ .return_value = -1 ,
	 .flag = SM_RETURN }
};

# 149 "src/server/migrate-file-client.sm"



static int send_migration_request_comp_fn(
	void *v_p,
	struct PVFS_server_resp *resp_p,
	int index){

	PINT_smcb *smcb = v_p;
	PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);


	/*got new datafile handle*/
	s_op->u.migposter.target_handle = resp_p->u.migposter.handle;
	gossip_debug(GOSSIP_SERVER_DEBUG,"\n\n New migration file handle:%llu,fs id:%d\n\n\n", llu(resp_p->u.migposter.handle),s_op->u.migposter.fs_id);  

	return resp_p->status;  
}

static int update_metadata_comp_fn(
	void *v_p,
	struct PVFS_server_resp *resp_p,
	int index){
	

  //PINT_smcb *smcb = v_p;
	//PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
	gossip_debug(
		GOSSIP_SERVER_DEBUG,
		"Update meta date finish ! \n"		
		);
	//PINT_smcb *smcb = v_p;
	//struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);    

	return 0;//resp_p->status; 
}

static PINT_sm_action init_migration(
	struct PINT_smcb *smcb, job_status_s *js_p){
	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);    
	
	struct PINT_perf_detail_item mig_datafile_item;
        double interval;
        interval = ((double)PINT_server_pc->interval_array_ms[1]/(1000.0));
        /* global flag and handle for currenly migrating datafile
	 */
        mig_datafile_item = PINT_choose_heavy_one(PINT_server_pc_detail, load_diff, interval, rt_handle, g_high_load, g_low_load, access_size, global_max_load_access_size, &candidate_find);
       
	if (mig_datafile_item.id == 0)
	{
		//printf("No proper candidate, abort migration ! \n");
		gossip_debug( 
			GOSSIP_SERVER_DEBUG, 
			"No proper candidate, abort migration \n");     
		js_p->error_code = -1;
		return SM_ACTION_COMPLETE; 
	}
    

        mig_datafile_handle = mig_datafile_item.id;
	js_p->error_code = 0;
	gossip_debug( 
		GOSSIP_SERVER_DEBUG, 
		"Enter init_migration:__***__Heavy load item: fs_id: %d file_handle:  %llu  read: %lld  write:%lld \n",  mig_datafile_item.fs_id, llu(mig_datafile_item.id), lld(mig_datafile_item.value_read), lld(mig_datafile_item.value_write)); 
	
	s_op->u.migposter.handle = mig_datafile_item.id;
	s_op->u.migposter.fs_id = mig_datafile_item.fs_id;		 
	if(s_op->msgarray_op.msgpair.svr_addr == 0){
		gossip_debug(GOSSIP_SERVER_DEBUG,"server target address is Null,abort migration!\n");
		js_p->error_code = -1;
	}
	
	/*do not migrate working-on handle
	  gossip_err("migrating handle:%llu,migposter handle:%llu\n",llu(migrating_handle),llu(s_op->u.migposter.handle));
	  if(migrating_handle == s_op->u.migposter.handle){
	  gossip_debug(GOSSIP_LB_DEBUG,"migration handle is currentlly working,abort migration!\n");
	  js_p->error_code = -1;
	  }
	*/
	return SM_ACTION_COMPLETE;
}

/* prelude_getattr_if_needed()
 *
 * reads basic attributes of target object, if there is a particular
 * target object for the operation
 */
static PINT_sm_action getattr_migration(
	struct PINT_smcb *smcb, job_status_s *js_p)
{
	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
	int ret = -PVFS_EINVAL;
	job_id_t tmp_id;

	PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "start\n");

	//

	/* all other operations fall to this point and read basic
	 * attribute information
	 */
	memset(&(s_op->ds_attr), 0, sizeof(PVFS_ds_attributes));

	//gossip_debug(GOSSIP_LB_DEBUG, "About to retrieve attributes "    "for handle %llu\n", llu(s_op->target_handle));

 	ret = job_trove_dspace_getattr( 
 		s_op->u.migposter.fs_id, 
		s_op->u.migposter.handle,
		smcb,
		&(s_op->ds_attr), 
 		0,
		js_p,
		&tmp_id, 
		server_job_context, NULL); 

/* 	if(ret == 1){  */
/* 		gossip_debug(GOSSIP_SERVER_DEBUG, "\n Ok: _*****_: return immediately \n ");  */
/*  	}else if (ret == 0){  */
/* 	  gossip_debug(GOSSIP_SERVER_DEBUG, "\n Ok: _*****_: return success \n ");  */
/*  	}  */
	
/*  	gossip_debug(GOSSIP_LB_DEBUG,  */
/*  		     "\n\n Client get attr: ret= %d,  \n handle: %llu \n fs_id: %d \n dfile count: %d \n dist_size: %d \n metafile: %llu \n ___*******___",   */
/*  		     ret,  */
/*  		     s_op->ds_attr.handle,   */
/*  		     s_op->ds_attr.fs_id,   */
/*  		     s_op->ds_attr.dfile_count,  */
/*  		     s_op->ds_attr.dist_size,  */
/*  		     s_op->ds_attr.metafile);  */
	
	//js_p->error_code = 0;
	//return SM_ACTION_COMPLETE;
	return ret;
}

static PINT_sm_action send_migration_request(
	struct PINT_smcb *smcb, job_status_s *js_p){
	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
	PINT_sm_msgpair_state *msg_p = NULL;
	PVFS_BMI_addr_t tmp_addr = s_op->msgarray_op.msgpair.svr_addr;
	
 	gossip_debug(GOSSIP_SERVER_DEBUG, "ds_attr: Send migration request: \n handle: %llu \n fs_id: %d \n dfile count: %d \n dist_size: %d \n metafile: %llu \n", s_op->ds_attr.handle,  
 		     s_op->ds_attr.fs_id,  
 		     s_op->ds_attr.dfile_count,
 		     s_op->ds_attr.dist_size, 
 		     s_op->ds_attr.metafile); 

//	gossip_debug(GOSSIP_LB_DEBUG, "\n\n%s: entry\n\n", __func__);    
	//gossip_debug(GOSSIP_LB_DEBUG,"addr=%lld\n", lld(s_op->msgpair.svr_addr));    
	PINT_init_msgpair(s_op, msg_p);

	s_op->msgarray_op.params.job_context = server_job_context;

	PINT_SERVREQ_MIGRATION_POSTER_FILL(
		s_op->msgarray_op.msgpair.req,
		s_op->u.migposter.fs_id,
		s_op->u.migposter.handle,
		s_op->ds_attr.u.datafile.b_size,
		s_op->ds_attr.metafile
		);
	
	s_op->msgarray_op.msgpair.fs_id = s_op->u.migposter.fs_id;
	s_op->msgarray_op.msgpair.handle = s_op->u.migposter.handle;
	s_op->msgarray_op.msgpair.retry_flag = PVFS_MSGPAIR_RETRY;
	s_op->msgarray_op.msgpair.comp_fn = send_migration_request_comp_fn;
	s_op->msgarray_op.msgpair.svr_addr = tmp_addr;

	//gossip_debug(GOSSIP_LB_DEBUG,    "bsize=%lld,addr=%lld,metafile=%llu\n",   lld(s_op->ds_attr.b_size),lld(s_op->msgpair.svr_addr),llu(s_op->ds_attr.metafile));

	/* immediate return: next state jumps to msgpairarray machine */
	js_p->error_code = 0;

	PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);    
	return SM_ACTION_COMPLETE;
}

/*
 *  post flow
 */
static PINT_sm_action post_flow(
	struct PINT_smcb *smcb, job_status_s *js_p){
	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

	gossip_debug(GOSSIP_SERVER_DEBUG, "\n\n%s: entry\n\n", __func__);    
	int ret;
	//int index;

	//unsigned long status_user_tag_resp = 0;
	//unsigned long status_user_tag = 0;
	struct filesystem_configuration_s * fs_config;

	//int flow_in_progress=0;
	//int ack_in_progress=0;

	//char s[1024];
	//struct PINT_decoded_msg decoded_resp;
	//struct PVFS_server_resp* resp = NULL;
	//int retry_limit = 0;
	//PVFS_size* tsize = NULL;
	//job_status_s ack_status;

	struct server_configuration_s *server_config = get_server_config_struct();

	//flow_descriptor* flow_desc = PINT_flow_alloc();
	//if (flow_desc == NULL){
	//	js_p->error_code = -PVFS_ENOMEM;
	//	return SM_ACTION_COMPLETE;
	//}

	s_op->u.migposter.flow_desc = PINT_flow_alloc(); //flow_desc; 
	if (!s_op->u.migposter.flow_desc)
	{
		js_p->error_code = -PVFS_ENOMEM;
		return SM_ACTION_COMPLETE;
	}   
	
	//gossip_debug(GOSSIP_LB_DEBUG, "\n\n s_op->ds_attr.b_size = %lld\n\n",s_op->ds_attr.b_size);
	
	/* must reset the error_code and internal PINT_distribute fields
	 * in case of a retry */
	//PINT_flow_reset(flow_desc);

	/*phase1:post flow*/
	s_op->u.migposter.flow_desc->file_data.fsize = s_op->ds_attr.u.datafile.b_size;
	s_op->u.migposter.flow_desc->file_data.dist = PINT_dist_create("simple_stripe");
	s_op->u.migposter.flow_desc->file_data.server_nr = 0;
	s_op->u.migposter.flow_desc->file_data.server_ct = 1;

	s_op->u.migposter.flow_desc->file_req = PVFS_BYTE;
	s_op->u.migposter.flow_desc->file_req_offset = 0;

	s_op->u.migposter.flow_desc->aggregate_size = s_op->ds_attr.u.datafile.b_size;

	s_op->u.migposter.flow_desc->tag = 0;
	s_op->u.migposter.flow_desc->type = FLOWPROTO_MULTIQUEUE;
	s_op->u.migposter.flow_desc->user_ptr = NULL;


	s_op->u.migposter.flow_desc->src.endpoint_id = TROVE_ENDPOINT;
	s_op->u.migposter.flow_desc->dest.endpoint_id = BMI_ENDPOINT;
	s_op->u.migposter.flow_desc->src.u.trove.handle = s_op->u.migposter.handle;
	s_op->u.migposter.flow_desc->src.u.trove.coll_id = s_op->u.migposter.fs_id;
	s_op->u.migposter.flow_desc->dest.u.bmi.address = s_op->msgarray_op.msgpair.svr_addr;

	fs_config = PINT_config_find_fs_id(server_config, s_op->u.migposter.fs_id);
	if(fs_config)
	{
		/* pick up any buffer settings overrides from fs conf */
		s_op->u.migposter.flow_desc->buffer_size = fs_config->fp_buffer_size;
		s_op->u.migposter.flow_desc->buffers_per_flow = fs_config->fp_buffers_per_flow;
	}

	ret = job_flow(
		s_op->u.migposter.flow_desc, 
		smcb,
		0,
		js_p, 
		&s_op->u.migposter.flow_job_id,
		server_job_context, 
		server_config->server_job_flow_timeout, NULL);
 
	//flow_in_progress = 1;
	
	/* if the flow fails immediately, then we have to do some special
	 * handling.  This function is not equiped to handle the failure
	 * directly, so we instead post a null job that will propigate the error
	 * to the normal state where we interpret flow errors
	 */
/* 	if(ret < 0){ */
/* 		gossip_debug(GOSSIP_LB_DEBUG, "\n\n posted flow failure:%d\n\n",ret); */
/* 	}else if (ret == 1){ */
/* 		gossip_debug(GOSSIP_LB_DEBUG, "\n\n posted flow return immediately: ret = %d,\n\n",ret); */
/* 	}else{ */
/* 		gossip_debug(GOSSIP_LB_DEBUG, "\n\n posted flow success, but to be tested: ret = %d,\n\n",ret); */
/* 	} */

	return ret;
}

/*
 * post complete ack receiver 
 */

static PINT_sm_action post_complete_ack(
	struct PINT_smcb *smcb, job_status_s *js_p){
	
	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

	gossip_debug(GOSSIP_SERVER_DEBUG, "\n\n%s: entry\n\n", __func__);    
	int ret;
	//int index;
	//struct filesystem_configuration_s * fs_config;
	
	//struct PINT_decoded_msg decoded_resp;
	//struct PVFS_server_resp* resp = NULL;
	//int retry_limit = 0;
	//PVFS_size* tsize = NULL;
	//job_status_s ack_status;

	//struct server_configuration_s *server_config = get_server_config_struct();

	s_op->msgarray_op.msgpair.max_resp_sz = PINT_encode_calc_max_size(
		PINT_ENCODE_RESP, 
		PVFS_SERV_WRITE_COMPLETION,
		ENCODING_LE_BFIELD);
	s_op->msgarray_op.msgpair.encoded_resp_p = BMI_memalloc(
		s_op->msgarray_op.msgpair.svr_addr,
		s_op->msgarray_op.msgpair.max_resp_sz,
		BMI_RECV);

	if (!s_op->msgarray_op.msgpair.encoded_resp_p)
	{
		gossip_err("BMI_memalloc (for write ack) failed\n");
		return -PVFS_ENOMEM;
	}
	//gossip_debug(GOSSIP_LB_DEBUG, "bmi memalloc success\n");
	
	/*
	  pre-post this recv with an infinite timeout and adjust it
	  after the flow completes since we don't know how long a flow
	  can take at this point
	*/ 
	ret = job_bmi_recv(
		s_op->msgarray_op.msgpair.svr_addr,
		s_op->msgarray_op.msgpair.encoded_resp_p,
		s_op->msgarray_op.msgpair.max_resp_sz,
		5,
		BMI_PRE_ALLOC,
		smcb, 
		IO_SM_PHASE_FINAL_ACK,
		js_p,
		&s_op->msgarray_op.msgpair.recv_id,
		server_job_context,
		JOB_TIMEOUT_INF, NULL);
	//JOB_TIMEOUT_INF);
	//ack_in_progress = 1;
	//s_op->msgarray_op.msgpair.recv_status.actual_size =  js_p->actual_size;	
	if (ret < 0)
	{
		gossip_err("job_bmi_recv (write ack) failed\n");
	}else{
		gossip_debug(GOSSIP_SERVER_DEBUG, "job_bmi_recv correct:ret = %d\n", ret);	
	} 

//	assert(ret == 0);

	return ret;

}

static PINT_sm_action test_send_one_msg_f(
	struct PINT_smcb *smcb, job_status_s *js_p){
        struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
	int err = -PVFS_EIO;
	job_id_t tmp_id;
	struct server_configuration_s *user_opts = get_server_config_struct();
	int ret;

	/* Decode the received ack */
	struct PINT_decoded_msg decoded_resp;
	ret = PINT_decode(s_op->msgarray_op.msgpair.encoded_resp_p, 
			  PINT_DECODE_RESP,
			  &decoded_resp, /* holds data on decoded resp */
			  s_op->msgarray_op.msgpair.svr_addr, 
			  s_op->msgarray_op.msgpair.recv_status.actual_size);
	gossip_debug(GOSSIP_LB_DEBUG, " \n Client->decoded received ack, actual size = %d, %d \n", js_p->actual_size, decoded_resp.stub_dec.resp.u.write_completion.total_completed);
	PINT_decode_release(&decoded_resp, PINT_ENCODE_RESP);


	/* release encoding of the first ack that we sent */
	PINT_encode_release(&s_op->encoded, PINT_ENCODE_RESP);

	/* zero size for safety */
	s_op->encoded.total_size = 0;

	/*
	  fill in response -- status field is the only generic one we
	  should have to set
	*/
	s_op->resp.op = PVFS_SERV_WRITE_COMPLETION;  /* not IO */
	s_op->resp.status = js_p->error_code;
	s_op->resp.u.write_completion.total_completed = 2222;
	gossip_debug(GOSSIP_LB_DEBUG,
		     "Client-> send to server again :%lld\n",
		     s_op->resp.u.write_completion.total_completed);

	//		s_op->u.migposter.flow_desc->total_transferred;

 	err = PINT_encode( 
 		&s_op->resp, 
 		PINT_ENCODE_RESP, 
 		&(s_op->encoded), 
		s_op->msgarray_op.msgpair.svr_addr,
 		ENCODING_LE_BFIELD); 

 	if (err < 0) 
 	{ 
 		gossip_lerr("Server: IO SM: PINT_encode() failure.\n"); 
 		js_p->error_code = err; 
 		return SM_ACTION_COMPLETE; 
 	} 

	gossip_debug(GOSSIP_SERVER_DEBUG,
		     "send completion ack 3 :%lld\n",
		     lld(s_op->u.migposter.flow_desc->total_transferred));

 	err = job_bmi_send_list( 
	        s_op->msgarray_op.msgpair.svr_addr,
		s_op->encoded.buffer_list, s_op->encoded.size_list, 
 		s_op->encoded.list_count, s_op->encoded.total_size, 5, 
 		s_op->encoded.buffer_type, 0, smcb, 0, js_p, &tmp_id, 
 		server_job_context, user_opts->client_job_bmi_timeout,NULL); 
        

	gossip_debug(GOSSIP_SERVER_DEBUG,
		     "job_bmi_send_list: err=%d\n",
		     err);
	return err;
    
}



static PINT_sm_action update_metadata(
	struct PINT_smcb *smcb, job_status_s *js_p){
	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
	int ret = -PVFS_EINVAL;
	struct server_configuration_s *server_config = get_server_config_struct();
	PINT_sm_msgpair_state *msg_p = NULL;
	PVFS_sys_attr attr;
	PVFS_credentials cred;

	/* Do some decode test */
	//struct PINT_decoded_msg decoded_resp;
	//PINT_encode_release(&s_op->msgarray_op.msgpair.encoded_resp_p, PINT_ENCODE_RESP);
	//ret = PINT_decode(s_op->msgarray_op.msgpair.encoded_resp_p, 
	//		  PINT_DECODE_RESP,
	//		  &decoded_resp, /* holds data on decoded resp */
	//		  s_op->msgarray_op.msgpair.svr_addr, 
	//		  s_op->msgarray_op.msgpair.recv_status.actual_size);
	//gossip_debug(GOSSIP_LB_DEBUG, " \n decode_msg: finish, actual size = %d, %d \n", js_p->actual_size, decoded_resp.stub_dec.resp.u.write_completion.total_completed);
	//PINT_decode_release(&decoded_resp, PINT_ENCODE_RESP);

	/*only set datafile handle*/
	attr.mask = 0;
	js_p->error_code = 0;
	cred.uid = geteuid();
	cred.gid = getegid();
	//gossip_debug(GOSSIP_LB_DEBUG," mig-file-client: posting setattr req:%llu\n",llu(s_op->ds_attr.metafile));

	PINT_init_msgpair(s_op, msg_p);
	s_op->msgarray_op.params.job_context = server_job_context;
	s_op->msgarray_op.params.job_timeout = server_config->client_job_bmi_timeout; 
	s_op->msgarray_op.params.retry_limit = server_config->client_retry_limit;    
	s_op->msgarray_op.params.retry_delay = server_config->client_retry_delay_ms;

	s_op->msgarray_op.params.job_context = server_job_context;

	PINT_SERVREQ_SETATTR_FILL(
		msg_p->req,
		cred,
		s_op->u.migposter.fs_id,
		s_op->ds_attr.metafile,
		PVFS_TYPE_METAFILE,
		attr,
		PVFS_ATTR_META_SINGLE_DFILE,NULL);

	msg_p->req.u.setattr.attr.u.meta.metafile.new =
		s_op->u.migposter.target_handle;
	msg_p->req.u.setattr.attr.u.meta.metafile.old =
		s_op->u.migposter.handle;

	gossip_debug(GOSSIP_LB_DEBUG, "new handle: %lld, old handle : %lld \n", s_op->u.migposter.target_handle, s_op->u.migposter.handle);

	msg_p->fs_id = s_op->u.migposter.fs_id;
	msg_p->handle = s_op->ds_attr.metafile;
	//msg_p->handle = s_op->u.migposter.target_handle;
	msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
	msg_p->comp_fn = update_metadata_comp_fn;

	ret = PINT_cached_config_map_to_server(
		&msg_p->svr_addr, s_op->ds_attr.metafile, msg_p->fs_id);
	
	if (ret)
	{
		gossip_err("Failed to map meta server address\n");
		js_p->error_code = ret;
	}

	js_p->error_code = 0;

	PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);
	return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_datafile_handle(
	struct PINT_smcb *smcb, job_status_s *js_p)
{
	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
	int ret = -PVFS_EINVAL;
	job_id_t j_id;
	//int index;
	//struct server_configuration_s *server_config = get_server_config_struct();
	return SM_ACTION_COMPLETE;
	//gossip_debug(GOSSIP_LB_DEBUG, "(%p) remove: removing dspace " "object %llu,%d\n", s_op, llu(s_op->u.migposter.handle),     s_op->u.migposter.fs_id);

	ret = job_trove_dspace_remove(
		s_op->u.migposter.fs_id,
		s_op->u.migposter.handle,
		TROVE_SYNC, 
		smcb, 0, js_p,
		&j_id, server_job_context, NULL);
	//job_test(j_id,&index,NULL,js_p,server_config->server_job_bmi_timeout,server_job_context);
	return ret;
}

static PINT_sm_action cleanup(
	struct PINT_smcb *smcb, job_status_s *js_p){
	//	struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

	/*anything else to be cleanup*/
	//BMI_set_info(s_op->addr, BMI_DEC_ADDR_REF, NULL);
	//	gossip_debug(GOSSIP_LB_DEBUG, "entered cleanup:%d\n",js_p->error_code);


	js_p->error_code = 0;
	return SM_ACTION_COMPLETE;
}


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

