Index: romio/Makefile.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/Makefile.in,v
retrieving revision 1.34
retrieving revision 1.35
diff -u -w -p -U8 -r1.34 -r1.35
--- romio/Makefile.in	1 Dec 2003 21:52:57 -0000	1.34
+++ romio/Makefile.in	27 Jan 2004 23:27:35 -0000	1.35
@@ -159,8 +159,15 @@
 
 # MPICH2 documentation targets
 mandoc:
 	(cd mpi-io && $(MAKE) mandoc )
 htmldoc:
 	(cd mpi-io && $(MAKE) htmldoc )
 latexdoc:
 	(cd mpi-io && $(MAKE) latexdoc )
+
+
+tags: TAGS
+TAGS:
+	for dir in mpi-io adio/common - ; do \
+		if [ "$$dir" = "-" ] ; then break ; fi ; \
+		(cd $$dir && ${MAKE} TAGS ; ) ; done
Index: romio/README
===================================================================
RCS file: /home/MPI/cvsMaster/romio/README,v
retrieving revision 1.26
retrieving revision 1.27
--- romio/README	18 Feb 2003 16:31:47 -0000	1.26
+++ romio/README	26 May 2004 17:56:42 -0000	1.27
@@ -253,20 +253,21 @@
 mv, cp, rm, ftp.
 
 
 Using ROMIO on NFS
 ------------------
 
 To use ROMIO on NFS, file locking with fcntl must work correctly on
 the NFS installation. On some installations, fcntl locks don't work.
-To get them to work, you need to use Version 3 of NFS and
-have the system administrator mount the NFS file system with the 
-"noac" option (no attribute caching). Turning off attribute caching 
-may reduce performance, but it is necessary for correct behavior.
+To get them to work, you need to use Version 3 of NFS, ensure that the
+lockd daemon is running on all the machines, and have the system
+administrator mount the NFS file system with the "noac" option (no
+attribute caching). Turning off attribute caching may reduce
+performance, but it is necessary for correct behavior.
 
 The following are some instructions we received from Ian Wells of HP
 for setting the noac option on NFS. We have not tried them
 ourselves. We are including them here because you may find 
 them useful. Note that some of the steps may be specific to HP
 systems, and you may need root permission to execute some of the
 commands. 
    
Index: romio/aclocal.m4
===================================================================
RCS file: /home/MPI/cvsMaster/romio/aclocal.m4,v
retrieving revision 1.30
retrieving revision 1.31
--- romio/aclocal.m4	6 Oct 2003 16:04:45 -0000	1.30
+++ romio/aclocal.m4	8 Jan 2004 22:41:16 -0000	1.31
@@ -319,17 +319,17 @@
          MPI_Info_create(&info);
          MPI_Finalize(); 
      }
 EOF
   rm -f conftest
   $CC $USER_CFLAGS -I$MPI_INCLUDE_DIR -o conftest mpitest.c $MPI_LIB > /dev/null 2>&1
   if test -x conftest ; then
       AC_MSG_RESULT(yes)
-      AC_DEFINE(HAVE_MPI_INFO,,[Define if MPI_Info available])
+      AC_DEFINE(HAVE_MPI_INFO,1,[Define if MPI_Info available])
       HAVE_MPI_INFO="#define HAVE_MPI_INFO"
       MPI_FINFO1="!"
       MPI_FINFO2="!"
       MPI_FINFO3="!"
       MPI_FINFO4="!"
   else
       AC_MSG_RESULT(no)
       BUILD_MPI_INFO=1
Index: romio/configure.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/configure.in,v
retrieving revision 1.98
retrieving revision 1.113
--- romio/configure.in	10 Dec 2003 22:44:11 -0000	1.98
+++ romio/configure.in	8 Jun 2004 19:13:59 -0000	1.113
@@ -76,16 +76,22 @@
 TEST_F77=""
 TRY_WEAK_SYMBOLS=1
 #
 # Error handlers (not used with MPICH2, which provides its own routines)
 MPIO_EXTRA_OBJECTS="get_errh.o set_errh.o"
 MPIO_EXTRA_TMP_POBJECTS="get_errh.p set_errh.p"
 MPIO_EXTRA_REAL_POBJECTS="_get_errh.o _set_errh.o"
 #
+# Completion routines for MPIO_Requests.  MPI Implementations with
+# generalized requests do not need these
+MPIO_REQOBJECTS="iotest.o iotestall.o iotestany.o iotestsome.o iowait.o iowaitall.o iowaitany.o iowaitsome.o ioreq_c2f.o ioreq_f2c.o"
+MPIO_REQ_TMP_POBJECTS="iotest.p iowait.p iowaitall.p iowaitany.p iotestall.p iotestany.p iowaitsome.p iotestsome.p"
+MPIO_REQ_REAL_POBJECTS="_iotest.o _iowait.o _iowaitall.o _iowaitany.o _iotestall.o _iotestany.o _iowaitsome.o _iotestsome.o"
+#
 have_aio=no
 #
 known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs"
 known_mpi_impls="mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi"
 #
 # Defaults
 AC_ARG_ENABLE(aio,[
 --enable-aio - Request use of asynchronous I/O routines],,enable_aio=notgiven)
@@ -280,17 +286,17 @@
 # --------------------------------------------------------------------------
 # For historical reasons
 if test -z "$FC" ; then 
     FC=$F77
 fi
 #
 C_DEBUG_FLAG="-g"
 F77_DEBUG_FLAG="-g"
-C_OPT_FLAG="-O"
+C_OPT_FLAG=${CFLAGS:-"-O"}
 case $ARCH in 
      sun4)
      CC=${CC:-gcc}
      F77=${FC:-f77}
      ;;
 
      solaris|solaris86)
      CC=${CC:-cc}
@@ -884,16 +890,20 @@
 # If no system selected, turn of AIO
 if test "$have_aio" != yes ; then
     AC_DEFINE(NO_AIO,1,[Define if AIO should not be used])
 fi
 
 
 AC_HAVE_FUNCS(memalign)
 
+#
+# Question: Should ROMIO under MPICH2 ignore the Fortran tests, since 
+# MPICH2 provides all of the Fortran interface routines?
+#
 if test $NOF77 = 0 ; then
     echo "checking Fortran external names"
     PAC_GET_FORTNAMES
     if test -n "$WDEF" ; then
         CFLAGS="$CFLAGS $WDEF"
     fi
     dnl PAC_PROG_F77_NAME_MANGLE
     dnl (need to set the new name format)
@@ -1012,17 +1022,24 @@
    fi
    PAC_TEST_MPI_SGI_type_is_contig
    PAC_TEST_MPI_COMBINERS
    PAC_TEST_MPI_HAVE_OFFSET_KIND
 fi
 #
 # check if darray and subarray constructors are defined in the MPI 
 # implementation 
-if test $WITHIN_KNOWN_MPI_IMPL = no -o $FROM_MPICH2 != no ; then
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
    PAC_MPI_DARRAY_SUBARRAY
-else
+fi
+if test $FROM_MPICH2 = yes ; then
+   dnl Made this a message instead of a warning because the warning is
+   dnl likely to confuse users.
+   AC_MSG_RESULT("Overriding Array test for MPICH2")
+   dnl unset BUILD_MPI_ARRAY
+   dnl AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,1,[Define if Darray is available])
+   dnl HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
    MPI_FARRAY1="!"
    MPI_FARRAY2="!"
    MPI_FARRAY3="!"
    MPI_FARRAY4="!"
    MPI_FARRAY5="!"
    MPI_FARRAY6="!"
@@ -1041,34 +1058,39 @@
 # Fortran interface for HP already uses one secondary defn. 
 # therefore, do not use this method for profiling interface.
 # build profiling interface explicitly.
    TRY_WEAK_SYMBOLS=0
 fi
 if test $TRY_WEAK_SYMBOLS = 1 ; then
   AC_MSG_CHECKING([for weak symbol support])
   AC_TRY_LINK([
-extern int Foo(int);
+extern int PFoo(int);
 #pragma weak PFoo = Foo
-int Foo(a) { return a; }
+int Foo(int a) { return a; }
 ],[return PFoo(1);],has_pragma_weak=1)
   #
   # Some systems (Linux ia64 and ecc, for example), support weak symbols
   # only within a single object file!  This tests that case.
+  # Note that there is an extern int PFoo declaration before the
+  # pragma.  Some compilers require this in order to make the weak symbol
+  # extenally visible.  
   if test "$has_pragma_weak" = 1 ; then
     AC_MSG_RESULT([pragma weak])
     AC_MSG_CHECKING([that weak symbols are visible to other files])
     rm -f conftest*
     cat >>conftest1.c <<EOF
-extern int Foo(int);
+extern int PFoo(int);
 #pragma weak PFoo = Foo
-int Foo(a) { return a; }
+int Foo(int);
+int Foo(int a) { return a; }
 EOF
     cat >>conftest2.c <<EOF
-int main() {
+extern int PFoo(int);
+int main(int argc, char **argv) {
 return PFoo(0);}
 EOF
     ac_link2='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest1.c conftest2.c $LIBS >conftest.out 2>&1'
     if eval $ac_link2 ; then
         AC_MSG_RESULT(yes)
     else
       echo "$ac_link2" 1>&AC_FD_CC
       echo "Failed program was" 1>&AC_FD_CC
@@ -1080,27 +1102,29 @@
     fi
     rm -f conftest*
   fi
   if test "$has_pragma_weak" = 1 ; then
     HAVE_WEAK_SYMBOLS=1
     AC_DEFINE(HAVE_PRAGMA_WEAK,1,[Define if pragma weak available])
   else
     AC_TRY_LINK([
+extern int PFoo(int);
 #pragma _HP_SECONDARY_DEF Foo PFoo
-int Foo(a) { return a; }
+int Foo(int a) { return a; }
 ],[return PFoo(1);],has_pragma_hp_secondary=1)
     if test "$has_pragma_hp_secondary" = 1 ; then 
         AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
         HAVE_WEAK_SYMBOLS=1
         AC_DEFINE(HAVE_PRAGMA_HP_SEC_DEF,1,[Define for HP weak pragma])
     else
         AC_TRY_LINK([
+extern int PFoo(int);
 #pragma _CRI duplicate PFoo as Foo
-int Foo(a) { return a; }
+int Foo(int a) { return a; }
 ],[return PFoo(1);],has_pragma_cri_duplicate=1)
         if test "$has_pragma_cri_duplicate" = 1 ; then
 	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
 	    HAVE_WEAK_SYMBOLS=1
 	    AC_DEFINE(HAVE_PRAGMA_CRI_DUP,1,[Define for CRAY weak dup])
         else    
             AC_MSG_RESULT(no)
         fi
@@ -1145,45 +1169,20 @@
         AC_DEFINE(NEEDS_INT_CAST_WITH_FLOCK,1,[Define if l_start and l_len data should be cast as int])
     fi
     # FIXME.  Solaris header files define off_t as a UNION if 64bit file
     # sizes are selected.  Gah!
 fi
 
 if test -n "$file_system_nfs" ; then
    # Check for problems with locks
-   AC_MSG_CHECKING([whether file locks work with NFS])
-   AC_TRY_RUN([
-#include <fcntl.h>
-#include <errno.h>
-#include <unistd.h>
-
-int main()
-{
-    struct flock lock;
-    int fd, err;
-
-    lock.l_type = F_WRLCK;
-    lock.l_start = 0;
-    lock.l_whence = SEEK_SET;
-    lock.l_len = 100;
-
-    fd = open("conftest.dat", O_RDWR | O_CREAT, 0644);
-
-    err = fcntl(fd, F_SETLKW, &lock);
-
-   /* printf("err = %d, errno = %d\n", err, errno); */
-    close(fd);
-    return err;
-}],nfs_locks_work=yes,nfs_locks_work=no,nfs_locks_work=unknown)
-    AC_MSG_RESULT($nfs_locks_work)
-    if test "$nfs_locks_work" != "yes" ; then
-        AC_MSG_WARN([File locks do not work with NFS.  See the Installation and
-users manual for instructions on fixing this])
-    fi
+   # We no longer do this within the configure test.  Instead,
+   # we suggest tha the user run maint/nfslock.c
+   AC_MSG_WARN([File locks may not work with NFS.  See the Installation and
+users manual for instructions on testing and if necessary fixing this])
 fi
 if test -n "$file_system_nfs"; then
     AC_DEFINE(NFS,1,[Define for NFS])
 fi
 if test -n "$file_system_ufs"; then
     AC_DEFINE(UFS,1,[Define for UFS])
 fi
 if test -n "$file_system_hfs"; then
@@ -1222,41 +1221,62 @@
         CFLAGS="$CFLAGS -DXFS_MEMALIGN=$pac_cv_memalignval"
     else
         AC_MSG_RESULT(assuming 128 for memory alignment)
         CFLAGS="$CFLAGS -DXFS_MEMALIGN=128"
     fi
 fi
 
 if test -n "$file_system_pvfs"; then
+    # Check for missing int64_t (intel version 8 compiler and -no-gcc
+    # selected)
+    AC_MSG_CHECKING([that pvfs.h can be compiled])
+    AC_TRY_COMPILE([
+#include <pvfs.h>
+],[],pvfs_header_ok=yes,pvfs_header_ok=no)
+    AC_MSG_RESULT($pvfs_header_ok)
+    if test "$pvfs_header_ok" = no -a "$ac_cv_sizeof_long_long" = 8 ; then
+        AC_MSG_CHECKING([if pvfs.h can be compiled if we define int64_t])
+        # Try again, but with int64_t
+        AC_TRY_COMPILE([
+typedef long long int int64_t;
+#include <pvfs.h>
+],[],pvfs_header_ok="yes with int64 definition")
+        AC_MSG_RESULT($pvfs_header_ok)
+    fi
+    if test "$pvfs_header_ok" = "yes with int64 definition" ; then
+        AC_DEFINE(ROMIO_PVFS_NEEDS_INT64_DEFINITION,1,[Define if int64_t must be defined for PVFS])
+    fi
+    if test "$pvfs_header_ok" != "no" ; then
    # Use ROMIO_PVFS instead of PVFS because FREEBSD defines PVFS.
     AC_DEFINE(ROMIO_PVFS,1,[Define for Romio with PVFS])
 fi
+fi
 if test -n "$file_system_pvfs2"; then
     AC_DEFINE(ROMIO_PVFS2,1,[Define for Romio with PVFS2])
 fi
 if test -n "$file_system_pfs"; then
     AC_DEFINE(PFS,1,[Define for PFS])
 fi
 if test -n "$file_system_testfs"; then
     AC_DEFINE(ROMIO_TESTFS,1,[Define for TESTFS])
 fi
 if test -n "$file_system_piofs"; then
     AC_DEFINE(PIOFS,1,[Define for PIOFS])
     USER_CFLAGS="$USER_CFLAGS -bI:/usr/include/piofs/piofs.exp"
     ROMIO_LFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
     USER_FFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
 fi
 if test -n "$mpi_mpich"; then
-   if test "$FROM_MPICH2" = no; then
-      AC_DEFINE(NEEDS_MPI_TEST,1,[Define if mpi_test needed])
-      AC_DEFINE(MPICH,1,[Define if using MPICH])
       if test -z "$arch_SX4" ; then
          MPIOF_H_INCLUDED=1
       fi
+   if test "$FROM_MPICH2" = no; then
+      AC_DEFINE(NEEDS_MPI_TEST,1,[Define if mpi_test needed])
+      AC_DEFINE(MPICH,1,[Define if using MPICH])
    fi
 fi
 if test -n "$mpi_sgi"; then
    AC_DEFINE(MPISGI,1,[Define if SGI MPI])
 fi
 if test -n "$mpi_lam"; then
    AC_DEFINE(MPILAM,1,[Define if using LAM/MPI])
 fi
@@ -1274,16 +1294,24 @@
 # package.  This is used only as part of the MPICH2 build, including 
 # the documentation targets mandoc, htmldoc, and latexdoc
 if test -z "$master_top_srcdir" ; then
     if test "$FROM_MPICH2" = yes ; then
         AC_MSG_WARN([Could not determine master_top_srcdir])
     fi
 fi
 AC_SUBST(master_top_srcdir)
+#
+# Get the master builddir (which may be imported from above)
+if test -z "$master_top_builddir" ; then
+    master_top_builddir=`pwd`
+fi
+export master_top_builddir
+AC_SUBST(master_top_builddir)
+
 # The following definitions are needed within adio/common/status_setb.c
 if test "$FROM_MPICH" = yes ; then
    AC_DEFINE(MPICH,1,[Define if compiling within MPICH])
 elif test "$FROM_MPICH2" = yes ; then 
    AC_DEFINE(MPICH2,1,[Define if compiling within MPICH2])
 elif test "$FROM_MPILAM" = yes ; then
    AC_DEFINE(MPILAM,1,[Define if compiling within LAM/MPI])
 fi
@@ -1309,21 +1337,27 @@
 	fi
     fi
 fi
 if test "$FROM_MPICH2" != no ; then
     # use the error handlers from MPICH2
     MPIO_EXTRA_OBJECTS=
     MPIO_EXTRA_TMP_POBJECTS=
     MPIO_EXTRA_REAL_POBJECTS=
+    # Use generalized request to get the multiple-completion routines
+    MPIO_REQOBJECTS=
+    MPIO_REQ_TMP_POBJECTS=
+    MPIO_REQ_REAL_POBJECTS=
 fi
 AC_SUBST(MPIO_EXTRA_OBJECTS)
 AC_SUBST(MPIO_EXTRA_TMP_POBJECTS)
 AC_SUBST(MPIO_EXTRA_REAL_POBJECTS)
-
+AC_SUBST(MPIO_REQOBJECTS)
+AC_SUBST(MPIO_REQ_TMP_POBJECTS)
+AC_SUBST(MPIO_REQ_REAL_POBJECTS)
 #
 if test $NOF77 = 1 ; then
    F77=":"
 else
    FORTRAN_TEST="fperf fcoll_test fmisc pfcoll_test" 
 fi
 #
 if test $WITHIN_KNOWN_MPI_IMPL = no ; then
@@ -1355,17 +1389,24 @@
    TEST_LIBNAME=""
    MPIRUN=$MPI_BIN_DIR/mpirun
    if test -n "$arch_SX4" || test -n "$arch_hpux" ; then
       TEST_F77=$MPI_BIN_DIR/mpif90
    else
       TEST_F77=$MPI_BIN_DIR/mpif77
    fi
    CC=$MPI_BIN_DIR/mpicc
-   EXTRA_DIRS="mpi-io/fortran mpi2-other/info mpi2-other/info/fortran mpi2-other/array mpi2-other/array/fortran"
+#   if test $FROM_MPICH2 != yes ; then
+#       BUILD_MPI_ARRAY=1
+#       BUILD_MPI_INFO=1
+#   fi
+   # A later test will insert the mpi2-other/info and array directories based
+   # on the value of BUILD_MPI_xxxx.  This lets MPICH2 turn these off,
+   # since MPICH2 provides these routines elsewhere
+   EXTRA_DIRS="mpi-io/fortran"
    # Some older implementations of the ADI do not include the 
    # MPID_Status_set_bytes routine.   This uses either the 
    # environment variable ADI3_WITHOUT_SET_BYTES or the
    # with arg --without-setbytes
    if test "$ADI2_WITHOUT_SET_BYTES" != yes -a \
            "$with_setbytes" != no ; then
        AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
    fi
@@ -1386,19 +1427,22 @@
 elif test $FROM_MPICH2 = yes ; then
    # For now, separate the mpich2 from mpich cases
    MPICH_HOME=`dirname $ROMIO_HOME`
    MPICH_HOME=`dirname $MPICH_HOME`
    MPICH_HOME=`dirname $MPICH_HOME`
    if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
    # No special compiler script.
    # BUT we need the include paths
-   CC="$CC -I${use_top_srcdir}/src/include -I${top_build_dir}/src/include"
-   TEST_CC="$CC"
-   MPI_LIB="$LIBNAME"
+   # CC="$CC -I${use_top_srcdir}/src/include -I${top_build_dir}/src/include"
+   # TEST_CC="$CC"
+   # MPI_LIB="$LIBNAME"
+   CC=${top_build_dir}/bin/mpicc
+   TEST_CC=${top_build_dir}/bin/mpicc
+   TEST_F77=${top_build_dir}/bin/mpif77
    ROMIO_INCLUDE=""
    USER_CFLAGS=""
    USER_FFLAGS=""
    TEST_LIBNAME=""
    MPIRUN=$MPI_BIN_DIR/mpiexec
    #
    # Turn off the building of the Fortran interface and the Info routines
    EXTRA_DIRS=""
@@ -1446,18 +1490,24 @@
 fi
 AC_SUBST(EXTRA_SRC_DIRS)
 AC_SUBST(FILE_SYS_DIRS)
 
 #
 CFLAGS="$CFLAGS -DHAVE_ROMIOCONF_H"
 #
 
+if test -n "$MPIOF_H_INCLUDED"; then
+   F77MPIOINC=""
+else 
+   F77MPIOINC="include 'mpiof.h'"
+fi
+
 AC_CHECK_HEADERS(unistd.h,
-        AC_MSG_CHECKING(for large file defines)
+        AC_MSG_CHECKING([for large file defines])
         AC_TRY_COMPILE([
                 #include <unistd.h>
                 ], [
                 #ifndef _LFS64_LARGEFILE
                 #error no largefile defines
                 #endif
                 ],
                 CFLAGS="${CFLAGS} -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64"
@@ -1494,16 +1544,17 @@
 AC_SUBST(MAKE)
 AC_SUBST(arch_IRIX)
 AC_SUBST(ROMIO_HOME)
 AC_SUBST(LIBNAME)
 AC_SUBST(TEST_LIBNAME)
 AC_SUBST(LL)
 AC_SUBST(F77GETARG)
 AC_SUBST(F77IARGC)
+AC_SUBST(F77MPIOINC)
 AC_SUBST(FTESTDEFINE)
 AC_SUBST(FORTRAN_MPI_OFFSET)
 AC_SUBST(FROM_MPICH)
 AC_SUBST(FROM_MPICH2)
 AC_SUBST(FROM_LAM)
 AC_SUBST(WITHIN_KNOWN_MPI_IMPL)
 AC_SUBST(NEEDS_MPI_FINT)
 AC_SUBST(HAVE_MPI_INFO)
@@ -1521,16 +1572,17 @@
 AC_SUBST(MPI_FARRAY2)
 AC_SUBST(MPI_FARRAY3)
 AC_SUBST(MPI_FARRAY4)
 AC_SUBST(MPI_FARRAY5)
 AC_SUBST(MPI_FARRAY6)
 AC_SUBST(MPI_FARRAY7)
 AC_SUBST(MPI_OFFSET_KIND1)
 AC_SUBST(MPI_OFFSET_KIND2)
+AC_SUBST(MPIO_REQOBJECTS)
 AC_SUBST(TEST_CC)
 AC_SUBST(TEST_F77)
 AC_SUBST(ROMIO_INCLUDE)
 AC_SUBST(ROMIO_LFLAGS)
 AC_SUBST(ROMIO_LIBLIST)
 AC_SUBST(ROMIO_TCFLAGS)
 AC_SUBST(ROMIO_TCPPFLAGS)
 AC_SUBST(ROMIO_TFFLAGS)
@@ -1541,16 +1593,17 @@
 AC_SUBST(MAKE_DEPEND_C)
 dnl
 dnl Support shared libraries
 if test -z "$ENABLE_SHLIB" ; then
    ENABLE_SHLIB=none
 fi
 AC_SUBST(ENABLE_SHLIB)
 AC_SUBST(CC_SHL)
+AC_SUBST(LIBTOOL)
 # Remove the .a from the library file name (so that we can use .so or
 # other appropriate suffix)
 SHLIBNAME=`echo $LIBNAME | sed 's/\.a//'`
 AC_SUBST(SHLIBNAME)
 dnl
 if test ! -d adio ; then mkdir adio ; fi
 if test ! -d adio/include ; then mkdir adio/include ; fi
 if test ! -d mpi2-other ; then mkdir mpi2-other ; fi
@@ -1584,23 +1637,13 @@
 Please register your copy of ROMIO with us by sending email
 to majordomo@mcs.anl.gov with the message
 subscribe romio-users
 This will enable us to notify you of new releases of ROMIO
 as well as bug fixes.
 
 EOF
 fi
-if test $FROM_MPICH2 = yes -a "$NOF77" = 0 ; then
-      sed 5d test/fcoll_test.f > test/tmp
-      mv test/tmp test/fcoll_test.f
-      sed 5d test/pfcoll_test.f > test/tmp
-      mv test/tmp test/fcoll_test.f
-      sed 5d test/fperf.f > test/tmp
-      mv test/tmp test/fperf.f
-      sed 5d test/fmisc.f > test/tmp
-      mv test/tmp test/fmisc.f
-fi
 if test $FROM_MPICH = no -a $FROM_MPICH2 = no ; then
    AC_MSG_RESULT([Configure done. Now type make])
 fi
 dnl PAC_SUBDIR_CACHE_CLEANUP
 exit 0
Index: romio/configure2.in
===================================================================
RCS file: romio/configure2.in
--- romio/configure2.in	8 Oct 2003 14:59:50 -0000	1.36
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,1471 +0,0 @@
-# build with
-# autoconf -output=configure2 --localdir=../confdb configure2.in
-# (or wherever the confdb is)
-# The following usage message is out-of-date
-# It is retained only to remind us which options were defined.
-
-usage_msg="
-Usage: ${progname} [-file_system=FILE_SYSTEM] [-arch=ARCH_TYPE] [-mpi=MPI_IMPL]
-                [-mpilib=MPI_LIBRARY]
-		[-mpibindir=MPI_BIN_DIR]
-                [-cc=C_COMPILER] [-fc=FORTRAN_COMPILER] [-nof77] 
-                [-cflags=CFLAGS] [-fflags=FFLAGS] [-f90=F90_COMPILER] [-debug] 
-                [-mpiolib=MPIO_LIBRARY] [-ar_nolocal] 
-                [-noranlib] [-ar=AR_COMMAND] [-prefix=INSTALL_DIR]  
-                [-longlongsize=LONGLONGSIZE] [-disable-weak-symbols]
-
-where
-   FILE_SYSTEM  = the file system(s) for which ROMIO is to be configured.
-                  Valid values are pfs, piofs, hfs, xfs, sfs, pvfs, ufs,
-                  and nfs (case-sensitive). They correspond to Intel's PFS, 
-                  IBM's PIOFS, HP/Convex's HFS, SGI's XFS, NEC's SFS, 
-                  Clemson University's PVFS (for Linux clusters), any Unix 
-                  file system, and NFS. 
-                  To configure for multiple file systems, use "+" as a 
-                  separator; e.g., ufs+nfs
-   ARCH_TYPE    = the type of machine for which ROMIO is to be configured.
-                  Not needed on most machines, because ROMIO can usually
-                  find the arch_type on its own. Needed if you are 
-                  cross-compiling for a different architecture.
-                  Valid values are sun4, solaris, solaris86, rs6000,
-                  paragon, hpux, sppux, IRIX, IRIX32, IRIXN32, IRIX64, SX4, 
-                  alpha, freebsd, LINUX, and LINUX_ALPHA.  (case-sensitive)
-   MPI_IMPL     = the MPI implementation with which ROMIO will be used
-                  Valid values are mpich, sgi, hp. (case-sensitive)
-                  Valid implementations are MPICH 1.1.1 or higher,
-                  SGI's MPI 3.1 or higher, HP MPI 1.3 or higher, LAM, 
-                  and Cray MPI.
-   MPI_INCLUDE_DIR = the full path of the directory where mpi.h is located.
-                  Not needed if the directory is in the compiler's 
-                  default include path
-   MPI_LIBRARY  = name of the file containing the MPI library (full path).
-                  Not needed if the library is in the compiler's default
-                  list of libraries
-   MPI_BIN_DIR  = the full path of the directory that contains the MPI
-                  versions of the compilers, such as mpicc and mpif77.
-                  Use only if the ROMIO configure cannot find the
-                  necessary commands
-   C_COMPILER   = the C compiler to use. If not specified, ROMIO uses a 
-                  default compiler depending on the machine.
-   FORTRAN_COMPILER = the Fortran compiler to use. If not specified, ROMIO 
-                  uses a default compiler depending on the machine.
-   CFLAGS       = flags to give to the C compiler
-   FFLAGS       = flags to give to the Fortran compiler
-   F90_COMPILER = the Fortran 90 compiler to use. If not specified, 
-                  ROMIO uses f90.
-   MPIO_LIBRARY = name of the MPI-IO library to be built (full path).
-                  Default is "this_directory"/lib/ARCH_TYPE/libmpio.a.
-   AR_COMMAND   = an alternate archiver (ar) command to use.
-   INSTALL_DIR  = directory where ROMIO is to be installed
-   LONGLONGSIZE = size of long long in bytes.
- 
-The option '-nof77' prevents the compilation of routines that require a
-Fortran compiler.  If you select this option, you cannot use the
-Fortran interface of MPI-IO.
-
-If '-debug' is used, ROMIO will be configured with the '-g' compiler option
-for debugging.
-
-The option '-ar_nolocal' prevents the library archive command from
-attempting to use the local directory for temporary space.  This option
-should be used when (a) there isn't much space (less than 10 MB)
-available in the partition where ROMIO resides and (b) there is enough
-space in /tmp (or wherever ar places temporary files by default).
-
-The option '-noranlib' causes the 'ranlib' step (needed on some systems
-to build an object library) to be skipped.  This is particularly useful
-on systems where 'ranlib' is optional (allowed but not needed; because it
-is allowed, configure chooses to use it just in case) but can fail (some
-'ranlib's are implemented as scripts using 'ar'; if they don't use the
-local directory, they can fail (destroying the library in the process) if
-the temporary directory (usually '/tmp') does not have enough space.
-
-The option -disable-weak-symbols disables the use of weak symbols, even if 
-available, for building the profiling interface.
-"
-#
-AC_INIT(adio/include/romioconf.h.in)
-echo " "
-echo "Configuring ROMIO Version 1.2.6"
-echo " "
-CONFIGURE_ARGS="$*"
-if test -n "$CONFIGURE_ARGS" ; then
-    echo "Configuring with args $CONFIGURE_ARGS"
-fi
-
-print_error() {
-    echo "*# $*" 2>&1 ;
-}
-
-AC_CONFIG_HEADER(adio/include/romioconf.h)
-dnl
-NOF77=0
-ARCH=""
-arch_IRIX=""
-MPI=""
-MPI_INCLUDE_DIR=""
-ROMIO_INCLUDE=""
-MPI_LIB=""
-LIBNAME=""
-TEST_LIBNAME=""
-FILE_SYSTEM=""
-DEBUG=no
-MIPS=0
-BITS=0
-FROM_MPICH=${FROM_MPICH:-0}
-FROM_MPICH2=${FROM_MPICH2:-0}
-CFLAGS=${CFLAGS:-""}
-LL="\%lld"
-AR_LOCAL=l
-HAVE_MPI_INFO=""
-BUILD_MPI_INFO=""
-MPI_FINFO1=""
-MPI_FINFO2=""
-MPI_FINFO3=""
-MPI_FINFO4=""
-MPI_FARRAY1=""
-MPI_FARRAY2=""
-MPI_FARRAY3=""
-MPI_FARRAY4=""
-MPI_FARRAY5=""
-MPI_FARRAY6=""
-MPI_FARRAY7=""
-DEFS=""
-ROMIO_LFLAGS=""
-ROMIO_LIBLIST=""
-ROMIO_TCFLAGS=""
-ROMIO_TCPPFLAGS=""
-ROMIO_TFFLAGS=""
-NOPROFILE=0
-MPIRUN=""
-FORTRAN_TEST=""
-MAKE=${MAKE:-"make"}
-# foll. needed for f77 test programs
-F77GETARG="call getarg(i,str)"
-F77IARGC="iargc()"
-F77MPIOINC=""
-FTESTDEFINE=""
-FORTRAN_MPI_OFFSET=""
-MPIOF_H_INCLUDED=0
-MPI_OFFSET_KIND1="!"
-MPI_OFFSET_KIND2="!"
-F90=""
-TEST_CC=""
-TEST_F77=""
-TRY_WEAK_SYMBOLS=1
-#
-known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs"
-known_mpi_impls="mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi"
-#
-# Defaults
-AC_ARG_ENABLE(aio,[
---enable-aio - Request use of asynchronous I/O routines],,enable_aio=notgiven)
-AC_ARG_ENABLE(echo, 
-[--enable-echo  - Turn on strong echoing. The default is enable=no.] ,set -x)
-AC_ARG_ENABLE(f77,
-[--enable-f77 - Turn on support for Fortran 77 (default)],,enable_f77=yes)
-AC_ARG_WITH(file-system,[
---with-file-system=name - Build with support for the named file systems],,)
-AC_ARG_WITH(mpi,[
---with-mpi=name - Specify MPI implementation to build ROMIO for],,)
-dnl
-if test "$enable_f77" != "yes" ; then
-   NOF77=1
-fi
-MPI=$with_mpi
-FILE_SYSTEM=$with_file_system
-#
-for arg
-do
-case $arg in
-  -arch=* | --arch=*)
-     ARCH=`echo $arg|sed 's/-*arch=//'`
-     eval "arch_`echo $ARCH`=1"
-     ;;
-
-  -debug | --debug | --enable-g | -enable-g)
-     echo "Configuring for a debugging version"
-     DEBUG=yes
-     ;;
-  -from_mpich | --from_mpich)
-     FROM_MPICH=1
-     ;;
-
-  -noprofile | --noprofile | --disable-profile | -disable-profile )
-     echo "profiling interface will not be built"
-     NOPROFILE=1
-     ;;
-
-  -disable-weak-symbols|--disable-weak-symbols)
-     TRY_WEAK_SYMBOLS=0
-     ;;
-esac
-done
-#
-AC_CONFIG_AUX_DIR(../../../confdb)
-dnl PAC_ARG_CACHING
-
-rm -f config.log
-#
-# Check that an arch was set
-# If it wasn't set, try to guess using "util/tarch"
-#
-if test -z "$ARCH" -a -x $srcdir/util/tarch ; then
-    AC_MSG_CHECKING(for architecture)
-    ARCH=`$srcdir/util/tarch | sed s/-/_/g`
-    if test -z "$ARCH" ; then
-       AC_MSG_RESULT(Unknown!)
-       AC_MSG_ERROR([Error: Couldn't guess target architecture, you must
-set an architecture type with -arch=<value>])
-    fi
-    eval "arch_$ARCH=1"
-    AC_MSG_RESULT($ARCH)
-fi
-#
-# check for valid architecture.  Use __ so that _ALPHA_ does not match
-# LINUX_ALPHA_
-#### WE SHOULD REMOVE THIS SOON
-grep __"$ARCH"_ $srcdir/.config_params > /dev/null 2>&1
-if test $? != 0 ; then
-   AC_MSG_WARN([Unknown architecture $arch... proceeding anyway])
-fi
-#
-#
-#
-# Find the home directory if not specified
-if test "X$srcdir" != "X." -a -s $srcdir/mpi-io/Makefile.in ; then 
-    ROMIO_HOME_TRIAL=$srcdir
-else
-    # Take advantage of autoconf2 features
-    ROMIO_HOME_TRIAL=$ac_srcdir
-    dnl PAC_GETWD(ROMIO_HOME_TRIAL,mpi-io/Makefile.in)
-fi
-echo "ROMIO home directory is $ROMIO_HOME_TRIAL"
-ROMIO_HOME=$ROMIO_HOME_TRIAL
-#
-# Create the "autoconf" style directory names...
-#
-# mandir is the root for the man pages
-if test -z "$mandir" ; then mandir='${prefix}/man' ; fi
-AC_SUBST(mandir)
-if test -z "$docdir" ; then docdir='${prefix}/doc' ; fi
-AC_SUBST(docdir)
-if test -z "$htmldir" ; then htmldir='${prefix}/www' ; fi
-AC_SUBST(htmldir) 
-#
-# check for valid file system
-if test -n "$FILE_SYSTEM" ; then
-   # if multiple filesystems are passed in, they are '+'-delimited
-   # we could set the IFS to tokenize FILE_SYSTEM, but the FILE_SYSTEM env var
-   # is used in multiple places in the build system: get rid of the '+'s so we
-   # can use the 'for x in $FILE_SYSTEM ...' idiom 
-   FILE_SYSTEM=`echo $FILE_SYSTEM|sed -e 's/\+/ /g'`
-   for x in $FILE_SYSTEM
-   do
-      found=no
-      # We could also do test -d "ad_$y" to test for known file systems
-      # based on having access to the adio code.  Then adding a file 
-      # system would not require changing configure to change known_filesystems
-      for y in $known_filesystems ; do 
-          if test $x = $y ; then
-	      found=yes
-	      eval "file_system_`echo $x`=1"
-	      break
-	  fi
-      done
-      if test "$found" = "no" ; then
-         AC_MSG_WARN([Unknown file system $x... proceeding anyway])
-      fi
-   done
-fi
-#
-# check for valid MPI implementation
-if test -n "$MPI" ; then
-   found=no
-   for mpi in $known_mpi_impls ; do
-      if test "${MPI}_mpi" = "$mpi" ; then
-          found=yes
-	  break
-      fi
-   done
-   if test $found = no ; then
-      AC_MSG_WARN([Unknown MPI implementation $MPI... proceeding anyway])
-   fi
-fi
-#
-# check for valid MPI include directory if specified
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   if test -n "$MPI_INCLUDE_DIR"; then
-      if test ! -f "$MPI_INCLUDE_DIR/mpi.h" ; then
-         AC_MSG_ERROR([Include file $MPI_INCLUDE_DIR/mpi.h not found])
-      fi
-   else
-#     assume that mpi.h is in the default path
-#     set MPI_INCLUDE_DIR to ".", so that it translates to -I. in the
-#     compile command. Some compilers complain if it's only -I
-      MPI_INCLUDE_DIR=.
-   fi
-else 
-   MPI_INCLUDE_DIR=.
-fi
-#
-# check for valid MPI library if specified
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   if test -n "$MPI_LIB" ; then
-      if test ! -f "$MPI_LIB" ; then
-         AC_MSG_ERROR([MPI library $MPI_LIB not found])
-      fi
-   fi
-fi
-#
-#
-AR="${AR:-ar} cr$AR_LOCAL"
-if test -z "$RANLIB" ; then
-    AC_PROG_RANLIB
-fi
-MAKE=${MAKE:-make}
-#
-# USER_CFLAGS and USER_FFLAGS are used only in test/Makefile.in
-if test $DEBUG = "yes"; then
-    USER_CFLAGS="$CFLAGS -g"
-    USER_FFLAGS="$FFLAGS -g"
-else
-    USER_CFLAGS="$CFLAGS -O"
-    USER_FFLAGS="$FFLAGS -O"
-fi
-#
-if test -n "$arch_sun4" ; then 
-    CC=${CC:-gcc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-	if test "$CC" = "gcc"; then
-           CFLAGS="$CFLAGS -g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
-	else
-           CFLAGS="$CFLAGS -g"
-        fi
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    if test "$enable_aio" != "no" ; then
-        # Check for aio
-	AC_SEARCH_LIBS(aiowrite,aio rt)
-	if test "$ac_cv_search_aiowrite" = "no" ; then
-	    enable_aio=no
-	elif test "$ac_cv_search_aiowrite" != "none required" ; then
-	    ROMIO_LIBLIST="$ROMIO_LIBLIST $ac_cv_search_aiowrite"
-        fi
-    fi
-    if test "$enable_aio" = "no" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else 
-        AC_DEFINE(AIO_SUN,,[Define for SUN0S 4])
-    fi
-
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-fi
-#
-if test -n "$arch_solaris" || test -n "$arch_solaris86" ; then
-    CC=${CC:-cc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-        if test "$CC" = "gcc" ; then
-            CFLAGS="$CFLAGS -g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
-        else 
-            CFLAGS="$CFLAGS -g -v"
-        fi
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    if test "$enable_aio" != "no" ; then
-        # Check for aio
-	AC_SEARCH_LIBS(aiowrite,aio rt)
-	if test "$ac_cv_search_aiowrite" = "no" ; then
-	    enable_aio=no
-	elif test "$ac_cv_search_aiowrite" != "none required" ; then
-	    ROMIO_LIBLIST="$ROMIO_LIBLIST $ac_cv_search_aiowrite"
-	    MPI_LIB="$MPI_LIB -laio"
-        fi
-    fi
-    if test "$enable_aio" = "no" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else 
-        AC_DEFINE(AIO_SUN,,[Define for SUN0S 4])
-    fi
-
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-    AC_DEFINE(SOLARIS,,[Define for Solaris])
-    if test $MPI = "mpich" ; then
-        TEST_CC=mpicc
-        TEST_F77=mpif77
-    else
-        TEST_CC="$CC"
-        TEST_F77="$F77"
-    fi
-    AR="ar cr"
-# solaris does not have l option to ar
-# solaris f90 does not have 8-byte integer type
-# (it does now!!!! 11/29/01)
-fi
-#
-if test -n "$arch_rs6000"; then
-    F77=$FC
-    if test -z "$CC"; then
-       AC_PROGRAMS_CHECK(CC, mpcc, cc)
-       echo "Using $CC"
-    fi
-    if test $NOF77 = 0 && test -z "$FC"; then 
-       AC_PROGRAMS_CHECK(F77, mpxlf, f77)
-       echo "Using $F77"
-    fi
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    # Check that aio is available (many systems appear to have aio
-    # either installed improperly or turned off).
-    # The test is the following: if not cross compiling, try to run a 
-    # program that includes a *reference* to aio_write but does not call it
-    # If the libraries are not set up correctly, then this will fail.
-    AC_MSG_CHECKING([whether aio routines can be used])
-    AC_TRY_RUN([
-int main( int argc, char **argv )
-{
-    if (argc > 10) aio_write();
-    return 0;
-}
-],aio_runs=yes,aio_runs=no,aio_runs=unknown)
-    AC_MSG_RESULT($aio_runs)						 
-    if test "$enable_aio" != "no" -a "$aio_runs" = "no" ; then
-        enable_aio=no
-    fi
-    if test "$enable_aio" = "no" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else
-        AC_DEFINE(NO_FD_IN_AIOCB,,[Define for no fd in the aiocb])
-        AC_DEFINE(AIO_HANDLE_IN_AIOCB,,[Define for aio handle in aiocb])
-    fi
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        if test "$CC" = "mpcc" || test "$CC" = "mpCC" ; then
-            file_system_piofs=1
-            FILE_SYSTEM="piofs"
-            AC_MSG_RESULT([configuring for file systems piofs, ufs, and nfs])
-        else 
-            AC_MSG_RESULT([configuring for file systems ufs and nfs])
-        fi
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="$FILE_SYSTEM ufs nfs"
-    fi
-    AC_DEFINE(AIX,,[Define for AIX])
-# assume long long exists.
-    longlongsize=${longlongsize:-8} 
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi    
-#
-if test -n "$arch_paragon"; then
-    CC=${CC:-icc}
-    F77=${FC:-if77}
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g"
-    else 
-	if test "$CC" = "icc"; then
-           CFLAGS="$CFLAGS -Knoieee -Mvect -O3"
-	else
-           CFLAGS="$CFLAGS -O"
-        fi
-    fi
-    AR="ar860 cr$AR_LOCAL"
-    MPI_LIB="$MPI_LIB -nx"
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_pfs=1
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="pfs ufs nfs"
-        AC_MSG_RESULT([configuring for file systems pfs, ufs, and nfs])
-    fi
-    AC_DEFINE(PARAGON,,[Define for Intel Paragon])
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-# NO_AIO is if configuring for NFS/UFS. It doesn't affect PFS asynch. I/O.
-# long long does not exist
-    longlongsize=${longlongsize:-0} 
-fi    
-#
-if test -n "$arch_tflop" || test -n "$arch_tflops"; then
-    CC=${CC:-pgcc}
-    F77=${FC:-pgf77}
-    TFLOP_FLAGS="-cougar -D__PUMA"
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g $TFLOP_FLAGS"
-    else
-       if test "$CC" = "pgcc"; then
-           CFLAGS="$CFLAGS -Knoieee -Mvect -O3 $TFLOP_FLAGS"
-       else
-           CFLAGS="$CFLAGS -O $TFLOP_FLAGS"
-       fi
-    fi
-    AR="xar cr$AR_LOCAL"
-        RANLIB="xranlib"
-    MPI_LIB="$MPI_LIB"
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        FILE_SYSTEM="ufs"
-        AC_MSG_RESULT([configuring for file system ufs])
-    fi
-fi
-#
-if test -n "$arch_freebsd" || test -n "$arch_LINUX" || test -n "$arch_LINUX_ALPHA" || test -n "$arch_netbsd" || test -n "$arch_openbsd" ; then
-    CC=${CC:-gcc}
-    if test -n "$arch_freebsd" || test -n "$arch_netbsd" || test -n "$arch_openbsd"; then
-       F77=${FC:-f77}
-       AC_DEFINE(FREEBSD,,[Define for FreeBSD])
-       PAC_HAVE_MOUNT_NFS
-       longlongsize=${longlongsize:-0}
-# printf doesn't work properly and no integer*8 as far as I can tell
-    else 
-       F77=${FC:-g77}
-       AC_DEFINE(LINUX,,[Define for Linux])
-    fi
-    if test $DEBUG = "yes" ; then
-	if test "$CC" = "gcc" ; then
-            CFLAGS="$CFLAGS -g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
-        else
-	    CFLAGS="$CFLAGS -g"
-        fi
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    if test "$enable_aio" != "yes" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else
-        # Try to find the aio routines
-	use_aio=no
-        AC_HEADER_CHECK(aio.h,has_aio_h=yes,has_aio_h=no)
-	add_lib=""
-	AC_SEARCH_LIBS(aio_write,aio,add_lib="-laio")
-	# What function do we want -lrt for?  In recent Linux, aio_write64
-	# is here, as is lio_listio
-	AC_SEARCH_LIBS(aio_write64,rt,add_lib="$add_lib -lrt")
-	AC_SEARCH_LIBS(pthread_create,pthread,[add_lib="$add_lib -lpthread"
-has_pthread=yes],[has_pthread=no])
-        AC_FUNC_CHECK(aio_write,has_aio_write=yes,has_aio_write=no)
-	if test "$has_aio_h" = "yes" -a "$has_aio_write" = "yes" -a \
-	        "$has_pthread" = "yes" ; then
-	    use_aio=yes	
-	fi    
-	# Check for aiocb_t as a shorthand for struct aiocb
-	AC_MSG_CHECKING([for aiocb_t])
-	AC_TRY_COMPILE([#include <aio.h>],
-[aiocb_t a;],has_aiocb_t=yes,has_aiocb_t=no)
-	AC_MSG_RESULT($has_aiocb_t)
-	if test "$has_aiocb_t" = "no" ; then 
-	    AC_DEFINE(NEEDS_AIOCB_T,,[Define for aiocb_t definition needed])
-        fi
-	if test "$use_aio" = "yes" ; then
-	    ROMIO_LIBLIST="$ROMIO_LIBLIST $add_lib"
-	else
-            AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-	fi
-    fi
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-fi    
-#
-if test -n "$arch_SX4" ; then
-    CC=${CC:-mpicc}
-    F77=${FC:-mpif90}
-    if test $DEBUG = "yes" ; then
-        CFLAGS="$CFLAGS -g"
-        FFLAGS="$FFLAGS -g"
-    else
-        USER_FFLAGS="$FFLAGS -Chopt"
-        CFLAGS="$CFLAGS -O"
-        FFLAGS="$FFLAGS -Chopt"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    AC_DEFINE(SX4,,[Define for NEC SX4])
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_sfs=1
-        file_system_nfs=1
-        FILE_SYSTEM="sfs nfs"
-        AC_MSG_RESULT([configuring for file systems sfs and nfs])
-    fi
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi
-#
-if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g +w1"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    RANLIB=":"
-    if test -z "$MPI"; then
-        if test -f "/opt/mpi/include/mpi.h" ; then
-            echo "assuming that you want to use ROMIO with HP MPI"
-            MPI=hp
-        else 
-            echo "assuming that you want to use ROMIO with MPICH"
-            MPI=mpich
-        fi            
-    fi
-    if test $MPI = "mpich" ; then
-        mpi_mpich=1
-        MPI_LIB="$MPI_LIB -lV3"
-        CC=${CC:-cc -Ae}
-        F77=${FC:-f77 +U77}
-    fi
-    if test $MPI = "hp" ; then
-        mpi_hp=1
-        CC=${CC:-mpicc -Ae}
-        F77=${FC:-mpif77 +U77}
-    fi
-    if test $MPI = "lam" && test "$FC" != ""; then
-        FC="$FC +U77"
-    fi
-    FTESTDEFINE="external iargc, getarg"
-    if test -n "$arch_hpux" ; then
-        CFLAGS="$CFLAGS -D_LARGEFILE64_SOURCE"
-        AC_DEFINE(HPUX,,[Define for HPUX])
-        if test $MPI = "hp" ; then
-           F77=${FC:-mpif90 +U77}
-        else
-           F77=${FC:-f90 +U77}
-        fi
-    else
-        AC_DEFINE(SPPUX,,[Define for SPPUX (Convex)])
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        if test -n "$arch_hpux" ; then
-	   AC_MSG_CHECKING([for struct flock64])
-           AC_TRY_COMPILE([#include <fcntl.h>],[
-struct flock64 fl; int i=F_SETLKW64;],flock64_ok="yes",flock64_ok="no")
-           AC_MSG_RESULT($flock64_ok)
-        else
-            flock64_ok="yes"
-        fi
-        if test $flock64_ok = "yes" ; then
-            file_system_hfs=1
-            file_system_nfs=1
-            FILE_SYSTEM="hfs nfs"
-            AC_MSG_RESULT([configuring for file systems hfs and nfs])
-        else
-            file_system_ufs=1
-            file_system_nfs=1
-            FILE_SYSTEM="ufs nfs"
-            AC_MSG_RESULT([no flock64; configuring for file systems ufs and nfs])
-        fi
-    fi
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-    if test "$CC" != "gcc" ; then
-        ROMIO_TCFLAGS="-Ae"
-    fi
-    if test "$F77" != "g77" ; then
-        ROMIO_TFFLAGS="+U77"
-    fi
-fi
-#
-if test -n "$arch_alpha" || test -n "$arch_ALPHA" ; then
-    CC=${CC:-cc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g -std1 -warnprotos -verbose"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    AC_DEFINE(AIO_PRIORITY_DEFAULT,,[Define for AIO priority is default])
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-    AC_DEFINE(DEC,,[Define for DEC/Compaq/HP Alpha])
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-    ROMIO_LIBLIST="$ROMIO_LIBLIST -laio"
-fi    
-#
-if test -n "$arch_CRAY" ; then
-    CC=${CC:-cc}
-    F77=${FC:-f90}
-    NOF77=1
-    FTESTDEFINE="integer ilen"
-    F77GETARG="call pxfgetarg(i, str, ilen, ierr)"
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    RANLIB=":"
-    CFLAGS="$CFLAGS -D_UNICOS"
-    AC_DEFINE(CRAY,,[Define if Cray])
-    if test -z "$MPI" || test -n "$mpi_sgi" ; then
-        MPI=cray
-        mpi_cray=1
-        mpi_sgi=""
-# above is to disable configure tests specific to SGI MPI
-        AC_DEFINE(MPISGI,,[Define if SGI MPI])
-        AC_DEFINE(HAVE_MPI_COMBINERS,,[Define if MPI supports datatype combiners])
-        AC_DEFINE(NO_MPI_SGI_type_is_contig,,[Define if no types show contig])
-    fi
-#       MPISGI needed because of error in Cray's and SGI's 
-#       MPI_Type_get_contents (does not increment reference count).
-#       Others needed because MPISGI needed.
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi
-#
-if test -n "$arch_sgi" ; then
-    arch_IRIX=1
-    ARCH=IRIX
-fi
-if test -n "$arch_IRIX64" ; then
-    arch_IRIX=1
-fi
-if test -n "$arch_IRIX32" ; then
-    arch_IRIX=1
-fi
-if test -n "$arch_IRIXN32" ; then
-    arch_IRIX=1
-fi
-if test -n "$arch_sgi5" ; then
-    arch_IRIX5=1
-    ARCH=IRIX
-fi
-#
-PAC_GET_SPECIAL_SYSTEM_INFO
-#
-# special case 'sgi5' for use on MESHINE which is much like an SGI running
-# irix 5 with r4400 chips, but does not have 'hinv', so above code doesn't
-# work
-if test -n "$arch_sgi5"; then
-   osversion=5
-   cputype=4400
-   IRIXARCH="$ARCH_$osversion"
-   IRIXARCH="$IRIXARCH_$cputype"
-# now set arch_IRIX to 1
-   arch_IRIX=1
-   echo "IRIX-specific architecture is $IRIXARCH"
-   AC_DEFINE(IRIX,,[Define if IRIX])
-fi
-#
-if test -n "$arch_IRIX"; then
-    CC=${CC:-cc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g -fullwarn"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-   if test $osversion = 4 ; then
-	RANLIB="ar ts"
-        if test -n "$mpi_sgi"; then
-            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 4.x])
-        fi
-   elif test $osversion = 5 ; then
-        if test -n "$mpi_sgi"; then
-            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 5.x])
-        fi
-   elif test $osversion = 6 ; then
-	if test -z "$MPI"; then
-	    if test "$FROM_MPICH2" = "1" ; then
-	        # Building with MPICH2.  Distinguish from MPICH-1
-		MPI=mpich2
-		mpi_mpich2=1
-            elif test -f "/usr/include/mpi.h" ; then
-                AC_MSG_WARN([assuming that you want to use ROMIO with SGI\'s MPI])
-                MPI=sgi
-                mpi_sgi=1
-            else 
-	        AC_MSG_WARN([assuming that you want to use ROMIO with MPICH])
-                MPI=mpich
-                mpi_mpich=1
-            fi            
-	fi
-        RANLIB=":"
-        AC_DEFINE(AIO_SIGNOTIFY_NONE,,[Define if no signotify])
-	if test $cputype -ge 5000 ; then
-            MIPS=4
-        else 
-            MIPS=3
-        fi
-   fi
-   if test -n "$mpi_sgi" && test -z "$MPI_LIB" ; then
-       MPI_LIB="-lmpi"
-   fi
-#  check if pread64 is defined
-   PAC_HAVE_PREAD64
-#
-   if test -z "$FILE_SYSTEM" ; then
-       file_system_nfs=1
-       FILE_SYSTEM="nfs"
-       AC_MSG_CHECKING(for xfs)
-       AC_TRY_COMPILE([
-#include <aio.h>],
-[aiocb64_t *t1;],file_system_xfs=1;FILE_SYSTEM="xfs $FILE_SYSTEM";)
-       if test "$file_system_xfs" = 1 ; then 
-          AC_MSG_RESULT(yes)
-       else
-          AC_MSG_RESULT(no)
-          file_system_ufs=1
-          FILE_SYSTEM="ufs $FILE_SYSTEM"
-       fi
-       AC_MSG_RESULT([configuring for file systems $FILE_SYSTEM])
-   fi
-   AC_DEFINE(IRIX,,[Define if IRIX])
-   MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-   MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi
-
-#
-# If we haven't found an architecture, try for a default
-if test -z "$CC" ; then
-    AC_PROG_CC
-    AC_PROG_F77
-    if test -z "$FILE_SYSTEM" ; then
-        FILE_SYSTEM="ufs"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-fi
-
-AC_HAVE_FUNCS(memalign)
-
-if test $NOF77 = 0 ; then
-    echo "checking Fortran external names"
-    PAC_GET_FORTNAMES
-    if test -n "$WDEF" ; then
-        CFLAGS="$CFLAGS $WDEF"
-    fi
-    dnl PAC_PROG_F77_NAME_MANGLE
-    dnl (need to set the new name format)
-    rm -f test/mpif.h
-    if test "$MPI_INCLUDE_DIR" != "." && test $FROM_MPICH = 0 && \
-       test $FROM_MPICH2 = 0 ; then
-        if test ! -d test ; then mkdir test ; fi
-        ln -s $MPI_INCLUDE_DIR/mpif.h test
-    fi
-else 
-    F77=":"
-fi
-#
-AC_C_INLINE
-
-# Header files
-AC_CHECK_HEADERS(unistd.h)
-#
-CROSS_SIZEOF_INT=${CROSS_SIZEOF_INT:-0}
-CROSS_SIZEOF_VOID_P=${CROSS_SIZEOF_VOID_P:-0}
-AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
-AC_CHECK_SIZEOF(void*,$CROSS_SIZEOF_VOID_P)
-AC_CACHE_CHECK([for int large enough for pointers],
-pac_cv_int_hold_pointer,[
-if test "$ac_cv_sizeof_int" = "0" -o \
-	"$ac_cv_sizeof_voidp" = "0" ; then
-    pac_cv_int_hold_pointer=unknown
-elif test "$ac_cv_sizeof_int" -lt "$ac_cv_sizeof_voidp" ; then
-    pac_cv_int_hold_pointer=no
-else
-    pac_cv_int_hold_pointer=yes
-fi
-])
-if test "$pac_cv_int_hold_pointer" != yes ; then
-    AC_DEFINE(INT_LT_POINTER,,[Define if int smaller than pointer])
-fi
-#
-dnl The original ROMIO configure used a set of complex tests here; this
-dnl is a partial reworking using the autoconf2 sizeof macros, and allowing
-dnl for the standardized CROSS_xxx varaibles for cross-compilation environments
-dnl PAC_LONG_LONG_64()
-CROSS_SIZEOF_LONG_LONG=${CROSS_SIZEOF_LONG_LONG:-0}
-AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
-if test "$ac_sizeof_long_long" != 0 ; then
-    if test "$ac_sizeof_long_long" = "8" ; then
-       AC_DEFINE(HAVE_LONG_LONG_64,,[Define if long long is 64 bits])
-       MPI_OFFSET_TYPE="long long"
-       DEFINE_MPI_OFFSET="typedef long long MPI_Offset;"
-       FORTRAN_MPI_OFFSET="integer*8"
-       LL="\%lld"
-    elif test "$ac_sizeof_long_long" = "$ac_sizeof_int" ; then
-       MPI_OFFSET_TYPE="int"
-       DEFINE_MPI_OFFSET="typedef int MPI_Offset;"
-       FORTRAN_MPI_OFFSET="integer"
-       AC_DEFINE(MPI_OFFSET_IS_INT,,[Define if MPI_Offset is int])
-       LL="\%d"
-       MPI_OFFSET_KIND1="!"
-       MPI_OFFSET_KIND2="!"
-    else
-       echo "defining MPI_Offset as long in C and integer in Fortran" 
-       MPI_OFFSET_TYPE="long"
-       DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
-       FORTRAN_MPI_OFFSET="integer"
-       LL="\%ld"
-       MPI_OFFSET_KIND1="!"
-       MPI_OFFSET_KIND2="!"
-    fi
-else
-    echo "defining MPI_Offset as long in C and integer in Fortran" 
-    MPI_OFFSET_TYPE="long"
-    DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
-    FORTRAN_MPI_OFFSET="integer"
-    LL="\%ld"
-    MPI_OFFSET_KIND1="!"
-    MPI_OFFSET_KIND2="!"
-fi
-
-
-#
-if test -n "$longlongsize"; then
-   if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-       PAC_MPI_LONG_LONG_INT
-   else
-       AC_DEFINE(HAVE_MPI_LONG_LONG_INT,,[Define if supports long long int])
-   fi
-fi
-#
-if test -n "$OFFSET_KIND" -a "A$MPI_OFFSET_KIND1" = "A!" ; then 
-  MPI_OFFSET_KIND1="        INTEGER MPI_OFFSET_KIND"
-  MPI_OFFSET_KIND2="        PARAMETER (MPI_OFFSET_KIND=$OFFSET_KIND)"
-else
- if test "$FORTRAN_MPI_OFFSET" = "integer*8" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 ; then
-   PAC_MPI_OFFSET_KIND
- fi
- #
-  if test "$FORTRAN_MPI_OFFSET" = "integer" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 ; then
-   PAC_MPI_OFFSET_KIND_4BYTE
-  fi
-fi
-#
-# check if MPI_Info functions are defined in the MPI implementation
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   PAC_MPI_INFO
-else
-   AC_DEFINE(HAVE_MPI_INFO,,[Define if MPI Info is available])
-   HAVE_MPI_INFO="#define HAVE_MPI_INFO"
-   MPI_FINFO1="!"
-   MPI_FINFO2="!"
-   MPI_FINFO3="!"
-   MPI_FINFO4="!"
-fi   
-#
-if test -n "$mpi_sgi"; then
-   if test -z "$HAVE_MPI_INFO" ; then
-      PAC_CHECK_MPI_SGI_INFO_NULL  # is MPI_INFO_NULL defined in mpi.h?
-   fi
-   PAC_TEST_MPI_SGI_type_is_contig
-   PAC_TEST_MPI_COMBINERS
-   PAC_TEST_MPI_HAVE_OFFSET_KIND
-fi
-#
-# check if darray and subarray constructors are defined in the MPI implementation
-if test $FROM_MPICH = 0 ; then
-   PAC_MPI_DARRAY_SUBARRAY
-else
-   AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,,[Define if Darray is available])
-   HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
-   MPI_FARRAY1="!"
-   MPI_FARRAY2="!"
-   MPI_FARRAY3="!"
-   MPI_FARRAY4="!"
-   MPI_FARRAY5="!"
-   MPI_FARRAY6="!"
-   MPI_FARRAY7="!"
-fi   
-#
-# Check to see if the compiler accepts prototypes
-dnl PAC_CHECK_CC_PROTOTYPES(AC_DEFINE(HAVE_PROTOTYPES))
-#
-#
-# Test for weak symbol support...
-# We can't put # in the message because it causes autoconf to generate
-# incorrect code
-HAVE_WEAK_SYMBOLS=0
-if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
-# multiple secondary definitions not allowed by HP compilers
-# Fortran interface for HP already uses one secondary defn. 
-# therefore, do not use this method for profiling interface.
-# build profiling interface explicitly.
-   TRY_WEAK_SYMBOLS=0
-fi
-if test $TRY_WEAK_SYMBOLS = 1 ; then
-  AC_MSG_CHECKING(for weak symbol support)
-  AC_TRY_LINK([
-#pragma weak PFoo = Foo
-int Foo(a) { return a; }
-],[return PFoo(1);],has_pragma_weak=1)
-  #
-  # Some systems (Linux ia64 and ecc, for example), support weak symbols
-  # only within a single object file!  This tests that case.
-  if test "$has_pragma_weak" = 1 ; then
-    AC_MSG_RESULT([pragma weak])
-    AC_MSG_CHECKING([that weak symbols are visible to other files])
-    rm -f conftest*
-    cat >>conftest1.c <<EOF
-#pragma weak PFoo = Foo
-int Foo(int);
-int Foo(a) { return a; }
-EOF
-    cat >>conftest2.c <<EOF
-int main() {
-return PFoo(0);}
-EOF
-    ac_link2='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest1.c conftest2.c $LIBS >conftest.out 2>&1'
-    if eval $ac_link2 ; then
-        AC_MSG_RESULT(yes)
-    else
-      echo "$ac_link2" >>config.log
-      echo "Failed program was" >>config.log
-      cat conftest1.c >>config.log
-      cat conftest2.c >>config.log
-      if test -s conftest.out ; then cat conftest.out >> config.log ; fi
-      AC_MSG_RESULT(no)
-      has_pragma_weak=0
-    fi
-    rm -f conftest*
-  fi
-  if test "$has_pragma_weak" = 1 ; then
-    HAVE_WEAK_SYMBOLS=1
-    AC_DEFINE(HAVE_WEAK_SYMBOLS,,[Define if weak symbols available])
-    AC_DEFINE(HAVE_PRAGMA_WEAK,,[Define if pragma weak available])
-  else
-    AC_TRY_LINK([
-#pragma _HP_SECONDARY_DEF Foo PFoo
-int Foo(a) { return a; }
-],[return PFoo(1);],has_pragma_hp_secondary=1)
-    if test "$has_pragma_hp_secondary" = 1 ; then 
-        AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
-        HAVE_WEAK_SYMBOLS=1
-        AC_DEFINE(HAVE_WEAK_SYMBOLS,,[Define if weak symbols available])
-        AC_DEFINE(HAVE_PRAGMA_HP_SEC_DEF,,[Define for HP weak pragma])
-    else
-        AC_TRY_LINK([
-#pragma _CRI duplicate PFoo as Foo
-int Foo(a) { return a; }
-],[return PFoo(1);],has_pragma_cri_duplicate=1)
-        if test "$has_pragma_cri_duplicate" = 1 ; then
-	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
-	    HAVE_WEAK_SYMBOLS=1
-	    AC_DEFINE(HAVE_WEAK_SYMBOLS,,[Define if weak symbols available])
-	    AC_DEFINE(HAVE_PRAGMA_CRI_DUP,,[Define for CRAY weak dup])
-        else    
-            AC_MSG_RESULT(no)
-        fi
-    fi
-  fi
-fi
-AC_SUBST(HAVE_WEAK_SYMBOLS)
-#
-# if FILE_SYSTEM is not set above, use ufs and nfs as default
-#
-if test -z "$FILE_SYSTEM" ; then
-    file_system_ufs=1
-    file_system_nfs=1
-    FILE_SYSTEM="ufs nfs"
-    AC_MSG_RESULT([configuring for file systems ufs and nfs])
-fi
-#
-if test -n "$file_system_nfs" ; then
-   # Check for problems with locks
-   AC_MSG_CHECKING([whether file locks work with NFS])
-   AC_TRY_RUN([
-#include <fcntl.h>
-#include <errno.h>
-#include <unistd.h>
-
-int main()
-{
-    struct flock lock;
-    int fd, err;
-
-    lock.l_type = F_WRLCK;
-    lock.l_start = 0;
-    lock.l_whence = SEEK_SET;
-    lock.l_len = 100;
-
-    fd = open("conftest.dat", O_RDWR | O_CREAT, 0644);
-
-    err = fcntl(fd, F_SETLKW, &lock);
-
-   /* printf("err = %d, errno = %d\n", err, errno); */
-    close(fd);
-    return err;
-}],nfs_locks_work=yes,nfs_locks_work=no,nfs_locks_work=unknown)
-    AC_MSG_RESULT($nfs_locks_work)
-    if test "$nfs_locks_work" != "yes" ; then
-        AC_MSG_WARN([File locks do not work with NFS.  See the Installation and
-users manual for instructions on fixing this])
-    fi
-fi
-if test -n "$file_system_nfs"; then
-    AC_DEFINE(NFS,,[Define for NFS])
-fi
-if test -n "$file_system_ufs"; then
-    AC_DEFINE(UFS,,[Define for UFS])
-fi
-if test -n "$file_system_hfs"; then
-    AC_DEFINE(HFS,,[Define for HFS])
-fi
-if test -n "$file_system_sfs"; then
-    AC_DEFINE(SFS,,[Define for SFS])
-fi
-if test -n "$file_system_xfs"; then
-    AC_DEFINE(XFS,,[Define for XFS])
-    # Check for memalign value (this was P A C_GET_XFS_MEMALIGN,
-    # switched to autoconf 2)
-    AC_CACHE_CHECK([for memory alignment needed for direct I/O],
-pac_cv_memalignval,[
-/bin/rm -f confmemalignval
-/bin/rm -f /tmp/romio_tmp.bin
-AC_TRY_RUN([#include <stdio.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdio.h>
-main() { 
-  struct dioattr st;
-  int fd = open("/tmp/romio_tmp.bin", O_RDWR | O_CREAT, 0644);
-  FILE *f=fopen("confmemalignval","w");
-  if (fd == -1) exit(1);
-  if (!f) exit(1);
-  fcntl(fd, F_DIOINFO, &st);
-  fprintf( f, "%u\n", st.d_mem);
-  exit(0);
-}],pac_cv_memalignval=`cat confmemalignval`,pac_cv_memalignval="unknown",pac_cv_memalignval="unknown")
-    /bin/rm -f confmemalignval
-    /bin/rm -f /tmp/romio_tmp.bin
-])
-    if test -n "$pac_cv_memalignval" -a "$pac_cv_memalignval" != 0 -a \
-    "$pac_cv_memalignval" != "unknown" ; then
-        CFLAGS="$CFLAGS -DXFS_MEMALIGN=$pac_cv_memalignval"
-    else
-        AC_MSG_RESULT(assuming 128 for memory alignment)
-        CFLAGS="$CFLAGS -DXFS_MEMALIGN=128"
-    fi
-fi
-
-if test -n "$file_system_pvfs"; then
-   # Use ROMIO_PVFS instead of PVFS because FREEBSD defines PVFS.
-    AC_DEFINE(ROMIO_PVFS,,[Define for Romio with PVFS])
-fi
-if test -n "$file_system_pvfs2"; then
-    AC_DEFINE(ROMIO_PVFS2,,[Define for Romio with PVFS2])
-fi
-if test -n "$file_system_pfs"; then
-    AC_DEFINE(PFS,,[Define for PFS])
-fi
-if test -n "$file_system_testfs"; then
-    AC_DEFINE(ROMIO_TESTFS,,[Define for TESTFS])
-fi
-if test -n "$file_system_piofs"; then
-    AC_DEFINE(PIOFS,,[Define for PIOFS])
-    USER_CFLAGS="$USER_CFLAGS -bI:/usr/include/piofs/piofs.exp"
-    ROMIO_LFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
-    USER_FFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
-fi
-if test -n "$mpi_mpich"; then
-   if test "$FROM_MPICH2" = 0; then
-      AC_DEFINE(NEEDS_MPI_TEST,,[Define if mpi_test needed])
-      AC_DEFINE(MPICH,,[Define if using MPICH])
-      if test -z "$arch_SX4" ; then
-         MPIOF_H_INCLUDED=1
-      fi
-   fi
-fi
-if test -n "$mpi_sgi"; then
-   AC_DEFINE(MPISGI,,[Define if SGI MPI])
-fi
-if test -n "$mpi_lam"; then
-   AC_DEFINE(MPILAM,,[Define if using LAM/MPI])
-fi
-if test -n "$mpi_hp"; then
-   AC_DEFINE(MPIHP,,[Define if using HP MPI])
-   if test "$NOF77" = 0; then
-      PAC_CHECK_MPIOF_H
-   fi
-fi
-#
-PAC_FUNC_STRERROR
-if test -z "$srcdir" -o "$srcdir" = "." ; then srcdir="$ROMIO_HOME" ; fi
-AC_SUBST(srcdir)
-if test "$FROM_MPICH2" = 0 ; then 
-    if test -z "$LIBNAME"; then
-        LIBNAME="$ROMIO_HOME/lib/$ARCH/libmpio.a"
-    fi
-    #
-    if test ! -d $ROMIO_HOME/lib ; then 
-        mkdir $ROMIO_HOME/lib
-    fi
-    if test ! -d $ROMIO_HOME/lib/$ARCH ; then 
-        mkdir $ROMIO_HOME/lib/$ARCH
-    fi
-else
-    MPILIBNAME=${MPILIBNAME:-mpich}
-    if test -n "$top_build_dir" -a -d "$top_build_dir/lib" ; then
-        LIBNAME=$top_build_dir/lib/lib${MPILIBNAME}.a
-    else
-        LIBNAME="$ROMIO_HOME/lib${MPILIBNAME}.a"
-    fi
-fi
-#
-if test $NOF77 = 1 ; then
-   F77=":"
-else
-   FORTRAN_TEST="fperf fcoll_test fmisc pfcoll_test" 
-fi
-#
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   PAC_TEST_MPI
-   PAC_NEEDS_FINT
-else
-   NEEDS_MPI_FINT=""
-fi
-#
-if test "$MPI_INCLUDE_DIR" = "." ; then
-   ROMIO_INCLUDE="-I../include"
-else 
-   ROMIO_INCLUDE="-I../include -I$MPI_INCLUDE_DIR"
-fi
-#
-TEST_LIBNAME=$LIBNAME
-MPIRUN=mpirun
-#
-# if MPICH, use mpicc in test programs
-#
-if test $FROM_MPICH = 1 ; then
-   MPICH_HOME=`dirname $ROMIO_HOME`
-   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
-   TEST_CC=$MPI_BIN_DIR/mpicc
-   MPI_LIB=""
-   ROMIO_INCLUDE=""
-   USER_CFLAGS=""
-   USER_FFLAGS=""
-   TEST_LIBNAME=""
-   MPIRUN=$MPI_BIN_DIR/mpirun
-   if test -n "$arch_SX4" || test -n "$arch_hpux" ; then
-      TEST_F77=$MPI_BIN_DIR/mpif90
-   else
-      TEST_F77=$MPI_BIN_DIR/mpif77
-   fi
-   CC=$MPI_BIN_DIR/mpicc
-   AC_DEFINE(HAVE_STATUS_SET_BYTES,,[Define if status_set_bytes available])
-fi
-# For now, separate the mpich2 from mpich cases
-if test $FROM_MPICH2 = 1 ; then
-   MPICH_HOME=`dirname $ROMIO_HOME`
-   MPICH_HOME=`dirname $MPICH_HOME`
-   MPICH_HOME=`dirname $MPICH_HOME`
-   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
-   # No special compiler script.
-   # BUT we need the include paths
-   CC="$CC -I${use_top_srcdir}/src/include -I${top_build_dir}/src/include"
-   TEST_CC="$CC"
-   MPI_LIB="$LIBNAME"
-   ROMIO_INCLUDE=""
-   USER_CFLAGS=""
-   USER_FFLAGS=""
-   TEST_LIBNAME=""
-   MPIRUN=$MPI_BIN_DIR/mpiexec
-   AC_DEFINE(HAVE_STATUS_SET_BYTES,,[Define if status_set_bytes available])
-   AC_DEFINE(HAVE_MPI_GREQUEST,,[Define if generalized requests avaliable])
-fi
-#
-#
-# feature tests:  we can't test features if building as part of MPICH because
-# we don't yet have an implementation against which we can test
-#
-if test "$FROM_MPICH2" = 0 -a "$FROM_MPICH" = 0 ; then
-   PAC_TEST_MPIR_STATUS_SET_BYTES
-   PAC_TEST_MPI_GREQUEST
-   AC_DEFINE(PRINT_ERR_MSG,,[Define for printing error messages])
-fi
-#
-if test -z "$TEST_CC" ; then
-   TEST_CC="$CC"
-fi
-if test -z "$TEST_F77" ; then
-   TEST_F77="$F77"
-fi
-#
-CFLAGS="$CFLAGS -DHAVE_ROMIOCONF_H"
-#
-echo "setting CC to $CC"
-echo "setting F77 to $F77"
-echo "setting TEST_CC to $TEST_CC"
-echo "setting TEST_F77 to $TEST_F77"
-echo "setting CFLAGS to $CFLAGS"
-echo "setting USER_CFLAGS to $USER_CFLAGS"
-echo "setting USER_FFLAGS to $USER_FFLAGS"
-#
-VPATH='VPATH = .:${srcdir}'
-AC_SUBST(VPATH)
-AC_SUBST(ARCH)
-AC_SUBST(FILE_SYSTEM)
-AC_SUBST(CC)
-AC_SUBST(CFLAGS)
-AC_SUBST(USER_CFLAGS)
-AC_SUBST(USER_FFLAGS)
-AC_SUBST(MIPS)
-AC_SUBST(BITS)
-AC_SUBST(MPI)
-AC_SUBST(AR)
-AC_SUBST(RANLIB)
-AC_SUBST(MPI_INCLUDE_DIR)
-AC_SUBST(MPI_LIB)
-AC_SUBST(F77)
-AC_SUBST(NOF77)
-AC_SUBST(NOPROFILE)
-AC_SUBST(MAKE)
-AC_SUBST(arch_IRIX)
-AC_SUBST(ROMIO_HOME)
-AC_SUBST(LIBNAME)
-AC_SUBST(TEST_LIBNAME)
-AC_SUBST(LL)
-AC_SUBST(F77GETARG)
-AC_SUBST(F77IARGC)
-AC_SUBST(FTESTDEFINE)
-AC_SUBST(FORTRAN_MPI_OFFSET)
-AC_SUBST(FROM_MPICH)
-AC_SUBST(FROM_MPICH2)
-AC_SUBST(NEEDS_MPI_FINT)
-AC_SUBST(HAVE_MPI_INFO)
-AC_SUBST(BUILD_MPI_INFO)
-AC_SUBST(HAVE_MPI_DARRAY_SUBARRAY)
-AC_SUBST(BUILD_MPI_ARRAY)
-AC_SUBST(DEFINE_MPI_OFFSET)
-AC_SUBST(MPI_OFFSET_TYPE)
-AC_SUBST(MPI_FINFO1)
-AC_SUBST(MPI_FINFO2)
-AC_SUBST(MPI_FINFO3)
-AC_SUBST(MPI_FINFO4)
-AC_SUBST(MPI_FARRAY1)
-AC_SUBST(MPI_FARRAY2)
-AC_SUBST(MPI_FARRAY3)
-AC_SUBST(MPI_FARRAY4)
-AC_SUBST(MPI_FARRAY5)
-AC_SUBST(MPI_FARRAY6)
-AC_SUBST(MPI_FARRAY7)
-AC_SUBST(MPI_OFFSET_KIND1)
-AC_SUBST(MPI_OFFSET_KIND2)
-AC_SUBST(TEST_CC)
-AC_SUBST(TEST_F77)
-AC_SUBST(ROMIO_INCLUDE)
-AC_SUBST(ROMIO_LFLAGS)
-AC_SUBST(ROMIO_LIBLIST)
-AC_SUBST(ROMIO_TCFLAGS)
-AC_SUBST(ROMIO_TCPPFLAGS)
-AC_SUBST(ROMIO_TFFLAGS)
-AC_SUBST(MPIRUN)
-AC_SUBST(FORTRAN_TEST)
-dnl
-dnl Dependency handling
-AC_SUBST(MAKE_DEPEND_C)
-if test ! -d adio ; then mkdir adio ; fi
-if test ! -d adio/include ; then mkdir adio/include ; fi
-if test ! -d mpi2-other ; then mkdir mpi2-other ; fi
-# 
-# Make sure we remove any configuration file incase there is out-of-date data.
-# We remove the version in include in case this is a vpath build
-rm -f adio/include/romioconf.h ${use_top_srcdir}/src/mpi/romio/adio/include/romioconf.h ${use_top_srcdir}/adio/include/romioconf.h
-#
-# Create makefiles for all of the adio devices.  Only the ones that 
-# are active will be called by the top level ROMIO make
-AC_OUTPUT_COMMANDS([chmod 755 util/romioinstall test/runtests])
-AC_OUTPUT(Makefile localdefs mpi-io/Makefile mpi2-other/info/Makefile \
-		   mpi2-other/array/Makefile adio/common/Makefile \
-		   test/Makefile test/misc.c test/large_file.c \
-		   test/runtests util/romioinstall include/mpio.h \
-		   include/mpiof.h \
-		   adio/ad_nfs/Makefile adio/ad_ufs/Makefile \
-		   adio/ad_xfs/Makefile adio/ad_hfs/Makefile \
-		   adio/ad_sfs/Makefile adio/ad_pfs/Makefile \
-		   adio/ad_testfs/Makefile adio/ad_pvfs/Makefile \
-		   adio/ad_pvfs2/Makefile adio/ad_piofs/Makefile \
-                   mpi-io/fortran/Makefile mpi2-other/info/fortran/Makefile \
-                   mpi2-other/array/fortran/Makefile test/fmisc.f \
-                   test/fcoll_test.f test/pfcoll_test.f test/fperf.f )
-#
-rm -f *.o
-if test "$ROMIO_NO_BANNER" != "yes" -a "$FROM_MPICH" = 0 -a \
-         $FROM_MPICH2 = 0 ; then
-cat <<EOF
-
-Please register your copy of ROMIO with us by sending email
-to majordomo@mcs.anl.gov with the message
-subscribe romio-users
-This will enable us to notify you of new releases of ROMIO
-as well as bug fixes.
-
-EOF
-fi
-if test $FROM_MPICH2 = 1 -a "$NOF77" = 0 ; then
-      sed 5d test/fcoll_test.f > test/tmp
-      mv test/tmp test/fcoll_test.f
-      sed 5d test/pfcoll_test.f > test/tmp
-      mv test/tmp test/fcoll_test.f
-      sed 5d test/fperf.f > test/tmp
-      mv test/tmp test/fperf.f
-      sed 5d test/fmisc.f > test/tmp
-      mv test/tmp test/fmisc.f
-fi
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   AC_MSG_RESULT([Configure done. Now type make])
-fi
-dnl PAC_SUBDIR_CACHE_CLEANUP
-exit 0
Index: romio/adio/ad_hfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_hfs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_hfs/.cvsignore	1 Aug 2003 13:30:17 -0000	1.2
+++ romio/adio/ad_hfs/.cvsignore	19 Jan 2004 14:49:35 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_nfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_nfs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_nfs/.cvsignore	1 Aug 2003 13:30:17 -0000	1.2
+++ romio/adio/ad_nfs/.cvsignore	19 Jan 2004 14:49:35 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_ntfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_ntfs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_ntfs/.cvsignore	1 Aug 2003 13:30:17 -0000	1.2
+++ romio/adio/ad_ntfs/.cvsignore	19 Jan 2004 14:49:35 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_pfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pfs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_pfs/.cvsignore	1 Aug 2003 13:30:17 -0000	1.2
+++ romio/adio/ad_pfs/.cvsignore	19 Jan 2004 14:49:35 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_piofs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_piofs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_piofs/.cvsignore	1 Aug 2003 13:30:18 -0000	1.2
+++ romio/adio/ad_piofs/.cvsignore	19 Jan 2004 14:49:36 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_pvfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_pvfs/.cvsignore	1 Aug 2003 13:30:18 -0000	1.2
+++ romio/adio/ad_pvfs/.cvsignore	19 Jan 2004 14:49:36 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_pvfs/ad_pvfs.h
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs/ad_pvfs.h,v
retrieving revision 1.3
retrieving revision 1.5
--- romio/adio/ad_pvfs/ad_pvfs.h	24 Oct 2002 17:00:57 -0000	1.3
+++ romio/adio/ad_pvfs/ad_pvfs.h	7 Jun 2004 19:26:28 -0000	1.5
@@ -1,19 +1,27 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs.h,v 1.3 2002/10/24 17:00:57 gropp Exp $    
+ *   $Id: ad_pvfs.h,v 1.5 2004/06/07 19:26:28 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #ifndef AD_PVFS_INCLUDE
 #define AD_PVFS_INCLUDE
 
+#ifndef ROMIOCONF_H_INCLUDED
+#include "romioconf.h"
+#define ROMIOCONG_H_INCLUDED
+#endif
+#ifdef ROMIO_PVFS_NEEDS_INT64_DEFINITION
+typedef long long int int64_t;
+#endif
+
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <fcntl.h>
 #include <pvfs.h>
 #include "adio.h"
 #include "pvfs_proto.h"
 
Index: romio/adio/ad_pvfs/ad_pvfs_flush.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs/ad_pvfs_flush.c,v
retrieving revision 1.11
retrieving revision 1.12
--- romio/adio/ad_pvfs/ad_pvfs_flush.c	18 Apr 2003 20:15:01 -0000	1.11
+++ romio/adio/ad_pvfs/ad_pvfs_flush.c	20 May 2004 19:05:17 -0000	1.12
@@ -1,26 +1,38 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs_flush.c,v 1.11 2003/04/18 20:15:01 David Exp $    
+ *   $Id: ad_pvfs_flush.c,v 1.12 2004/05/20 19:05:17 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs.h"
 
 void ADIOI_PVFS_Flush(ADIO_File fd, int *error_code)
 {
-    int err;
+    int err, rank, dummy=0, dummy_in=0;
 #ifndef PRINT_ERR_MSG
     static char myname[] = "ADIOI_PVFS_FLUSH";
 #endif
 
+    /* a collective routine: because we do not cache data in PVFS1, one process
+     * can initiate the fsync operation and broadcast the result to the others.
+     * One catch: MPI_File_sync has special meaning with respect to file system
+     * consistency.  Ensure no clients have outstanding write operations.
+     */
+
+    MPI_Comm_rank(fd->comm, &rank);
+    MPI_Reduce(&dummy_in, &dummy, 1, MPI_INT, MPI_SUM, 
+		    fd->hints->ranklist[0], fd->comm);
+    if (rank == fd->hints->ranklist[0]) {
     err = pvfs_fsync(fd->fd_sys);
+    }
+    MPI_Bcast(&err, 1, MPI_INT, 0, fd->comm);
 
     if (err == -1) {
 #ifdef MPICH2
 	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
 	    "**io %s", strerror(errno));
 #elif defined(PRINT_ERR_MSG)
 	*error_code = MPI_ERR_UNKNOWN;
 #else /* MPICH-1 */
Index: romio/adio/ad_pvfs/ad_pvfs_resize.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs/ad_pvfs_resize.c,v
retrieving revision 1.11
retrieving revision 1.13
--- romio/adio/ad_pvfs/ad_pvfs_resize.c	18 Apr 2003 20:15:01 -0000	1.11
+++ romio/adio/ad_pvfs/ad_pvfs_resize.c	7 Jun 2004 16:42:26 -0000	1.13
@@ -1,26 +1,35 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs_resize.c,v 1.11 2003/04/18 20:15:01 David Exp $    
+ *   $Id: ad_pvfs_resize.c,v 1.13 2004/06/07 16:42:26 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs.h"
 
 void ADIOI_PVFS_Resize(ADIO_File fd, ADIO_Offset size, int *error_code)
 {
     int err;
+    int ret, rank;
 #ifndef PRINT_ERR_MSG
     static char myname[] = "ADIOI_PVFS_RESIZE";
 #endif
     
+    /* because MPI_File_set_size is a collective operation, and PVFS1 clients
+     * do not cache metadata locally, one client can resize and broadcast the
+     * result to the others */
+    MPI_Comm_rank(fd->comm, &rank);
+    if (rank == fd->hints->ranklist[0]) {
     err = pvfs_ftruncate64(fd->fd_sys, size);
+    }
+    MPI_Bcast(&err, 1, MPI_INT, 0, fd->comm);
+
     if (err == -1) {
 #ifdef MPICH2
 	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
 	    "**io %s", strerror(errno));
 #elif defined(PRINT_ERR_MSG)
 	*error_code = MPI_ERR_UNKNOWN;
 #else /* MPICH-1 */
 	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
Index: romio/adio/ad_pvfs2/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_pvfs2/.cvsignore	1 Aug 2003 13:30:18 -0000	1.2
+++ romio/adio/ad_pvfs2/.cvsignore	19 Jan 2004 14:49:36 -0000	1.3
@@ -1,2 +1,5 @@
 Makefile
 .deps
+*.bb
+*.bbg
+
Index: romio/adio/ad_pvfs2/ad_pvfs2_close.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_close.c,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_pvfs2/ad_pvfs2_close.c	27 Jun 2003 23:23:16 -0000	1.2
+++ romio/adio/ad_pvfs2/ad_pvfs2_close.c	20 May 2004 19:13:57 -0000	1.3
@@ -1,19 +1,22 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_close.c,v 1.2 2003/06/27 23:23:16 robl Exp $
+ *   $Id: ad_pvfs2_close.c,v 1.3 2004/05/20 19:13:57 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 
 void ADIOI_PVFS2_Close(ADIO_File fd, int *error_code)
 {
     ADIOI_Free(fd->fs_ptr);
-    /* pvfs2 doesn't have a 'close' */
+    /* pvfs2 doesn't have a 'close', but MPI-IO semantics dictate that we
+     * ensure all data has been flushed  */
+    /* XXX: reduce and sync? sync on all? */
+
     *error_code = MPI_SUCCESS;
 }
 /* 
  * vim: ts=8 sts=4 sw=4 noexpandtab 
  */
Index: romio/adio/ad_pvfs2/ad_pvfs2_common.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_common.c,v
retrieving revision 1.7
retrieving revision 1.9
--- romio/adio/ad_pvfs2/ad_pvfs2_common.c	5 Sep 2003 20:43:58 -0000	1.7
+++ romio/adio/ad_pvfs2/ad_pvfs2_common.c	25 Mar 2004 22:17:45 -0000	1.9
@@ -1,75 +1,63 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_common.c,v 1.7 2003/09/05 20:43:58 robl Exp $
+ *   $Id: ad_pvfs2_common.c,v 1.9 2004/03/25 22:17:45 robl Exp $
  *
  *   Copyright (C) 2003 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 #include "ad_pvfs2_common.h"
 #include <unistd.h>
 #include <sys/types.h>
 
 /* maybe give romio access to the globalconfig struct */
 /* keyval hack to both tell us if we've already initialized pvfs2 and also
  * close it down when mpi exits */
 int ADIOI_PVFS2_Initialized = MPI_KEYVAL_INVALID;
 
-PVFS_fs_id * ADIOI_PVFS2_fs_id_list;
-pvfs_mntlist ADIOI_PVFS2_mntlist;
-
 void ADIOI_PVFS2_End(int *error_code)
 {
     int ret;
     ret = PVFS_sys_finalize();
     if (ret < 0 ) {
-	*error_code = MPI_UNDEFINED;
+	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
     } else {
 	*error_code = MPI_SUCCESS;
     }
 }
 
 int ADIOI_PVFS2_End_call(MPI_Comm comm, int keyval, 
 	void *attribute_val, void *extra_state)
 {
     int error_code;
     ADIOI_PVFS2_End(&error_code);
     return error_code;
 }
 
 void ADIOI_PVFS2_Init(int *error_code )
 {
-	PVFS_sysresp_init resp_init;
 	int ret;
 
 	/* do nothing if we've already fired up the pvfs2 interface */
 	if (ADIOI_PVFS2_Initialized != MPI_KEYVAL_INVALID) {
 		*error_code = MPI_SUCCESS;
 		return;
 	}
 
-	ret = PVFS_util_parse_pvfstab(&ADIOI_PVFS2_mntlist);
-	if (ret < 0) {
-	    /* XXX: better error handling */
-	    fprintf(stderr, "error parsing pvfstab\n");
-	    *error_code = MPI_UNDEFINED;
-	    return;
-	}
-	ret = PVFS_sys_initialize(ADIOI_PVFS2_mntlist, ADIOI_PVFS2_DEBUG_MASK, 
-		&resp_init);
+	ret = PVFS_util_init_defaults();
 	if (ret < 0 ) {
 	    /* XXX: better error handling */
-	    fprintf(stderr, "error initializing pvfs\n");
-	    *error_code = MPI_UNDEFINED;
+	    PVFS_perror("PVFS_util_init_defaults", ret);
+	    ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 	    return;
 	}
-	ADIOI_PVFS2_fs_id_list = resp_init.fsid_list;
+
 	MPI_Keyval_create(MPI_NULL_COPY_FN, ADIOI_PVFS2_End_call,
 		&ADIOI_PVFS2_Initialized, (void *)0); 
 	/* just like romio does, we make a dummy attribute so we 
 	 * get cleaned up */
 	MPI_Attr_put(MPI_COMM_WORLD, ADIOI_PVFS2_Initialized, (void *)0);
 }
 
 void ADIOI_PVFS2_makeattribs(PVFS_sys_attr * attribs)
@@ -82,18 +70,17 @@
     attribs->mask =  PVFS_ATTR_SYS_ALL_SETABLE;
 }
 
 
 void ADIOI_PVFS2_makecredentials(PVFS_credentials * credentials)
 {
     memset(credentials, 0, sizeof(PVFS_credentials));
 
-    credentials->uid = geteuid();
-    credentials->gid = getegid();
+    PVFS_util_gen_credentials(credentials);
 }
 
 /* pvfs_error_convert: given a pvfs error code, make it into the appropriate
  * mpi error code */ 
 int ADIOI_PVFS2_pvfs_error_convert(int pvfs_error, int *mpi_error)
 {
     *mpi_error = MPI_UNDEFINED;
     return 0;
Index: romio/adio/ad_pvfs2/ad_pvfs2_common.h
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_common.h,v
retrieving revision 1.8
retrieving revision 1.10
--- romio/adio/ad_pvfs2/ad_pvfs2_common.h	18 Sep 2003 23:13:18 -0000	1.8
+++ romio/adio/ad_pvfs2/ad_pvfs2_common.h	25 Mar 2004 22:22:34 -0000	1.10
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*-
  * vim: ts=8 sts=4 sw=4 noexpandtab
- *   $Id: ad_pvfs2_common.h,v 1.8 2003/09/18 23:13:18 robl Exp $    
+ *   $Id: ad_pvfs2_common.h,v 1.10 2004/03/25 22:22:34 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #ifndef _AD_PVFS2_h
 #define _AD_PVFS2_H
 #include "ad_pvfs2.h"
@@ -13,24 +13,22 @@
 /* useful values:
  *  0:		    no debugging
  *  CLIENT_DEBUG:   debug client state machines
  */
 #define ADIOI_PVFS2_DEBUG_MASK 0
 
 
 struct ADIOI_PVFS2_fs_s {
-    PVFS_pinode_reference pinode_refn;
+    PVFS_object_ref object_ref;
     PVFS_credentials credentials;
 } ADIOI_PVFS2_fs_s;
 
 typedef struct ADIOI_PVFS2_fs_s ADIOI_PVFS2_fs;
 
-extern PVFS_fs_id * ADIOI_PVFS2_fs_id_list;
-extern pvfs_mntlist ADIOI_PVFS2_mntlist;
 
 void ADIOI_PVFS2_Init(int *error_code );
 void ADIOI_PVFS2_makeattribs(PVFS_sys_attr * attribs);
 void ADIOI_PVFS2_makecredentials(PVFS_credentials * credentials);
 void ADIOI_PVFS2_End(int *error_code);
 int ADIOI_PVFS2_End_call(MPI_Comm comm, int keyval, 
 	void *attribute_val, void *extra_state);
 int ADIOI_PVFS2_pvfs_error_convert(int pvfs_error, int *mpi_error);
Index: romio/adio/ad_pvfs2/ad_pvfs2_delete.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_delete.c,v
retrieving revision 1.5
retrieving revision 1.8
--- romio/adio/ad_pvfs2/ad_pvfs2_delete.c	5 Sep 2003 20:43:58 -0000	1.5
+++ romio/adio/ad_pvfs2/ad_pvfs2_delete.c	20 May 2004 20:31:05 -0000	1.8
@@ -1,62 +1,52 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_delete.c,v 1.5 2003/09/05 20:43:58 robl Exp $    
+ *   $Id: ad_pvfs2_delete.c,v 1.8 2004/05/20 20:31:05 robl Exp $    
  *
  *   Copyright (C) 2003 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 #include "adio.h"
 
 #include "ad_pvfs2_common.h"
 
 void ADIOI_PVFS2_Delete(char *filename, int *error_code)
 {
     PVFS_credentials credentials;
     PVFS_sysresp_getparent resp_getparent;
-    int ret, i, mnt_index;
+    int ret;
+    PVFS_fs_id cur_fs;
     char pvfs_path[PVFS_NAME_MAX] = {0};
 
     ADIOI_PVFS2_Init(error_code);
     if (*error_code != MPI_SUCCESS) 
     {
 	ADIOI_PVFS2_pvfs_error_convert(0, error_code);
 	return;
     }
 
     /* in most cases we'll store the credentials in the fs struct, but we don't
      * have one of those in Delete  */
     ADIOI_PVFS2_makecredentials(&credentials);
 
     /* given the filename, figure out which pvfs filesystem it is on */
-    for (i=0; i<ADIOI_PVFS2_mntlist.ptab_count; i++) {
-	ret = PVFS_util_remove_dir_prefix(filename, 
-		ADIOI_PVFS2_mntlist.ptab_array[i].mnt_dir, 
-		pvfs_path, PVFS_NAME_MAX);
-	if (ret == 0) {
-	    mnt_index = i;
-	    break;
-	}
-    }
-    if (mnt_index == -1) {
-	fprintf(stderr, "Error: could not find filesystem for %s in pvfstab",
-		filename);
+    ret = PVFS_util_resolve(filename, &cur_fs, pvfs_path, PVFS_NAME_MAX);
+    if (ret < 0) {
+	PVFS_perror("PVFS_util_resolve", ret);
 	/* TODO: pick a good error for this */
 	ret = -1;
 	goto resolve_error;
     }
-
-    ret = PVFS_sys_getparent(ADIOI_PVFS2_fs_id_list[mnt_index], pvfs_path,
-	    credentials, &resp_getparent);
+    ret = PVFS_sys_getparent(cur_fs, pvfs_path, &credentials, &resp_getparent);
 
     ret = PVFS_sys_remove(resp_getparent.basename, 
-	    resp_getparent.parent_refn, credentials);
+	    resp_getparent.parent_ref, &credentials);
     if (ret < 0) {
 	/* XXX: better error handling */
 	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 	return;
     }
     *error_code = MPI_SUCCESS;
     return;
 
Index: romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c,v
retrieving revision 1.3
retrieving revision 1.5
--- romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c	5 Aug 2003 22:59:20 -0000	1.3
+++ romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c	20 May 2004 20:31:05 -0000	1.5
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_fcntl.c,v 1.3 2003/08/05 22:59:20 robl Exp $    
+ *   $Id: ad_pvfs2_fcntl.c,v 1.5 2004/05/20 20:31:05 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 #include "adio_extern.h"
 #include "ad_pvfs2_common.h"
@@ -16,18 +16,18 @@
     ADIOI_PVFS2_fs *pvfs_fs;
     PVFS_sysresp_getattr resp_getattr;
 
     pvfs_fs = (ADIOI_PVFS2_fs*)fd->fs_ptr;
 
     switch(flag) {
 
     case ADIO_FCNTL_GET_FSIZE:
-	ret = PVFS_sys_getattr(pvfs_fs->pinode_refn, PVFS_ATTR_SYS_SIZE, 
-		pvfs_fs->credentials, &resp_getattr);
+	ret = PVFS_sys_getattr(pvfs_fs->object_ref, PVFS_ATTR_SYS_SIZE, 
+		&(pvfs_fs->credentials), &resp_getattr);
 	if (ret < 0 ) {
 	    ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 	} else {
 	    *error_code = MPI_SUCCESS;
 	}
 	fcntl_struct->fsize = resp_getattr.attr.size;
 	return;
 
Index: romio/adio/ad_pvfs2/ad_pvfs2_flush.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_flush.c,v
retrieving revision 1.3
retrieving revision 1.9
--- romio/adio/ad_pvfs2/ad_pvfs2_flush.c	30 Oct 2003 18:53:40 -0000	1.3
+++ romio/adio/ad_pvfs2/ad_pvfs2_flush.c	20 May 2004 20:31:05 -0000	1.9
@@ -1,41 +1,49 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_flush.c,v 1.3 2003/10/30 18:53:40 robl Exp $    
+ *   $Id: ad_pvfs2_flush.c,v 1.9 2004/05/20 20:31:05 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 #include "ad_pvfs2_common.h"
 
-/* we want to be a bit clever here:  at scale, every client sending a flush
- * will stress the server unnecessarily.  One process should wait for everyone
- * to catch up, do the sync, then broadcast the result.
+/* we want to be a bit clever here:  at scale, if every client sends a
+ * flush request, it will stress the PVFS2 servers with redundant
+ * PVFS_sys_flush requests.  Instead, one process should wait for
+ * everyone to catch up, do the sync, then broadcast the result.  We can
+ * get away with this thanks to PVFS2's stateless design 
  */
+
 void ADIOI_PVFS2_Flush(ADIO_File fd, int *error_code)
 {
-    int ret, rank, tmprank, dummy1, dummy2;
+    int ret, rank, dummy=0, dummy_in=0; 
     ADIOI_PVFS2_fs *pvfs_fs;
 
     *error_code = MPI_SUCCESS;
 
     pvfs_fs = (ADIOI_PVFS2_fs*)fd->fs_ptr;
 
     MPI_Comm_rank(fd->comm, &rank);
 
-    /* the cheapest way we know to let one process know everyone is here */
-    MPI_Gather(&dummy1, 1, MPI_INT, &dummy2, 1, MPI_INT, 0, fd->comm);
 
-    if (rank == 0) {
-	ret = PVFS_sys_flush(pvfs_fs->pinode_refn, pvfs_fs->credentials);
+    /* unlike ADIOI_PVFS2_Resize, MPI_File_sync() does not perform any
+     * syncronization */
+    MPI_Reduce(&dummy_in, &dummy, 1, MPI_INT, MPI_SUM, 
+	    fd->hints->ranklist[0], fd->comm);
+
+    /* io_worker computed in ADIO_Open */
+    if (rank == fd->hints->ranklist[0]) {
+	ret = PVFS_sys_flush(pvfs_fs->object_ref, &(pvfs_fs->credentials));
 	MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
-    }
+    } else {
     MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
+    }
     if (ret < 0)
 	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 }
 
 /* 
  * vim: ts=8 sts=4 sw=4 noexpandtab 
  */
Index: romio/adio/ad_pvfs2/ad_pvfs2_open.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_open.c,v
retrieving revision 1.11
retrieving revision 1.14
--- romio/adio/ad_pvfs2/ad_pvfs2_open.c	2 Nov 2003 15:55:18 -0000	1.11
+++ romio/adio/ad_pvfs2/ad_pvfs2_open.c	20 May 2004 20:31:05 -0000	1.14
@@ -1,22 +1,22 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*-
  * vim: ts=8 sts=4 sw=4 noexpandtab
- *   $Id: ad_pvfs2_open.c,v 1.11 2003/11/02 15:55:18 rross Exp $
+ *   $Id: ad_pvfs2_open.c,v 1.14 2004/05/20 20:31:05 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 #include "ad_pvfs2_common.h"
 
 struct open_status_s {
     int error;
-    PVFS_pinode_reference pinode_refn;
+    PVFS_object_ref object_ref;
 };
 typedef struct open_status_s open_status;
     
     /* steps for getting a handle:  (it gets a little convoluted, but at least
      * it's deterministic) 
      * . lookup the file.  
      * . if lookup succeeds, but we were passed MPI_MODE_EXCL, that's an error
      * . if lookup fails, the file might not exist. 
@@ -39,128 +39,123 @@
 
     ADIOI_PVFS2_makeattribs(&attribs);
 
     memset(&resp_lookup, 0, sizeof(resp_lookup));
     memset(&resp_getparent, 0, sizeof(resp_getparent));
     memset(&resp_create, 0, sizeof(resp_create));
 
     ret = PVFS_sys_lookup(fs_id, pvfs_name,
-	    pvfs2_fs->credentials, &resp_lookup, PVFS2_LOOKUP_LINK_FOLLOW);
+	    &(pvfs2_fs->credentials), &resp_lookup, PVFS2_LOOKUP_LINK_FOLLOW);
     if ( (ret < 0) ) { /* XXX: check what the error was */
 	if (access_mode & MPI_MODE_CREATE)  {
 	    ret = PVFS_sys_getparent(fs_id, pvfs_name,
-		    pvfs2_fs->credentials, &resp_getparent); 
+		    &(pvfs2_fs->credentials), &resp_getparent); 
 	    if (ret < 0) {
 		fprintf(stderr, "pvfs_sys_getparent returns with %d\n", ret);
 		o_status->error = ret;
 		return;
 	    } 
 	    ret = PVFS_sys_create(resp_getparent.basename, 
-		    resp_getparent.parent_refn, attribs, 
-		    pvfs2_fs->credentials, &resp_create); 
+		    resp_getparent.parent_ref, attribs, 
+		    &(pvfs2_fs->credentials), NULL, &resp_create); 
 
 	    if (ret < 0) { /* XXX: should only do this for EEXISTS */
 		ret = PVFS_sys_lookup(fs_id, pvfs_name,
-			pvfs2_fs->credentials, &resp_lookup, 
+			&(pvfs2_fs->credentials), &resp_lookup, 
 			PVFS2_LOOKUP_LINK_FOLLOW);
 		if ( ret < 0 ) {
 		    o_status->error = ret;
 		    return;
 		}
 		o_status->error = ret;
-		o_status->pinode_refn = resp_lookup.pinode_refn;
+		o_status->object_ref = resp_lookup.ref;
 		return;
 	    }
-	    o_status->pinode_refn = resp_create.pinode_refn;
+	    o_status->object_ref = resp_create.ref;
 	} else {
 	    fprintf(stderr, "cannot create file without MPI_MODE_CREATE\n");
 	    o_status->error = ret;
 	    return;
 	}
     } else if (access_mode & MPI_MODE_EXCL) {
 	/* lookup should not succeed if opened with EXCL */
 	o_status->error = -1; /* XXX: what should it be? */
 	return;
     } else {
-	o_status->pinode_refn = resp_lookup.pinode_refn;
+	o_status->object_ref = resp_lookup.ref;
     }
     o_status->error = ret;
     return;
 
 }
 
 
 /* if MPI_File_open was called with MPI_MODE_CREATE|MPI_MODE_EXCL, then we have
  * a little problem: our usual open-and-broadcast test will not work because
  * only one person (the first aggregator) will perform the open w/ CREATE|EXCL
  */
 void ADIOI_PVFS2_Open(ADIO_File fd, int *error_code)
 {
-    int rank, ret, i, mnt_index=-1;
+    int rank, ret;
+    PVFS_fs_id cur_fs;
     char pvfs_path[PVFS_NAME_MAX] = {0};
 
     ADIOI_PVFS2_fs *pvfs2_fs;
 
     /* since one process is doing the open, that means one process is also
-     * doing the error checking.  define a struct for both the pinode and the
-     * error code to broadcast to all the processors */
+     * doing the error checking.  define a struct for both the object reference
+     * and the error code to broadcast to all the processors */
 
     open_status o_status;
     MPI_Datatype open_status_type;
     MPI_Datatype types[2] = {MPI_INT, MPI_BYTE};
-    int lens[2] = {1, sizeof(PVFS_pinode_reference)};
+    int lens[2] = {1, sizeof(PVFS_object_ref)};
     MPI_Aint offsets[2];
     
     pvfs2_fs = (ADIOI_PVFS2_fs *)ADIOI_Malloc(sizeof(ADIOI_PVFS2_fs));
     if (pvfs2_fs == NULL) {
 	/* graceful way to handle out of memory? */
 	ADIOI_PVFS2_pvfs_error_convert(0, error_code);
 	return;
     }
 
     MPI_Comm_rank(fd->comm, &rank);
 
     MPI_Address(&o_status.error, &offsets[0]);
-    MPI_Address(&o_status.pinode_refn, &offsets[1]);
+    MPI_Address(&o_status.object_ref, &offsets[1]);
 
     MPI_Type_struct(2, lens, offsets, types, &open_status_type);
     MPI_Type_commit(&open_status_type);
 
     ADIOI_PVFS2_Init(error_code);
     if (*error_code != MPI_SUCCESS)
     {
-	/* XXX: handle errors */
+	ADIOI_PVFS2_pvfs_error_convert(0, error_code);
 	return;
     }
 
     ADIOI_PVFS2_makecredentials(&(pvfs2_fs->credentials));
 
     /* we only have to do this on one node. we'll broadcast the handle to
      * everyone else in the communicator */
 
     if (rank == fd->hints->ranklist[0]) {
 	/* given the filename, figure out which pvfs filesystem it is on */
-	for(i=0; i<ADIOI_PVFS2_mntlist.ptab_count; i++) {
-	    ret = PVFS_util_remove_dir_prefix(fd->filename, 
-		    ADIOI_PVFS2_mntlist.ptab_array[i].mnt_dir, 
+	ret = PVFS_util_resolve(fd->filename, &cur_fs, 
 		    pvfs_path, PVFS_NAME_MAX);
-	    if (ret == 0) {
-		mnt_index = i;
-		break;
-	    }
-	}
-	if (mnt_index == -1) {
-	    fprintf(stderr, "Error: could not find filesystem for %s in pvfstab", fd->filename);
+	if (ret < 0 ) {
+	    PVFS_perror("PVFS_util_resolve", ret);
 	    /* TODO: pick a good error for this */
 	    o_status.error = -1;
-	} else 
-	    fake_an_open(ADIOI_PVFS2_fs_id_list[mnt_index], pvfs_path,
+	} else  {
+	    fake_an_open(cur_fs, pvfs_path,
 		    fd->access_mode, pvfs2_fs, &o_status);
     }
+    }
 
     /* NOTE: if MPI_MODE_EXCL was set, ADIO_Open will call
      * ADIOI_PVFS2_Open from just one processor.  This really confuses MPI when
      * one procesor on a communicator broadcasts to no listners.  
      *
      * Since ADIO_Open will close the file and call ADIOI_PVFS2_Open again (but
      * w/o EXCL), we can bail out right here and return early */
     if ( (fd->access_mode & MPI_MODE_EXCL)  ) {
@@ -170,25 +165,25 @@
 	} else {
 	    ADIOI_Free(pvfs2_fs);
 	    ADIOI_PVFS2_pvfs_error_convert(o_status.error, error_code);
 	} 
 	MPI_Type_free(&open_status_type);
 	return;
     } 
 
-    /* broadcast status and (if successful) valid pinode refn */
+    /* broadcast status and (if successful) valid object reference */
     MPI_Bcast(MPI_BOTTOM, 1, open_status_type, 0, fd->comm);
 
     if (o_status.error != 0 ) { 
 	ADIOI_Free(pvfs2_fs);
 	ADIOI_PVFS2_pvfs_error_convert(o_status.error, error_code);
 	return;
     }
 
-    pvfs2_fs->pinode_refn = o_status.pinode_refn;
+    pvfs2_fs->object_ref = o_status.object_ref;
     fd->fs_ptr = pvfs2_fs;
 
     MPI_Type_free(&open_status_type);
 
     *error_code = MPI_SUCCESS;
     return;
 }
Index: romio/adio/ad_pvfs2/ad_pvfs2_read.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_read.c,v
retrieving revision 1.7
retrieving revision 1.10
--- romio/adio/ad_pvfs2/ad_pvfs2_read.c	7 Aug 2003 23:34:31 -0000	1.7
+++ romio/adio/ad_pvfs2/ad_pvfs2_read.c	7 Jun 2004 20:48:15 -0000	1.10
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_read.c,v 1.7 2003/08/07 23:34:31 robl Exp $
+ *   $Id: ad_pvfs2_read.c,v 1.10 2004/06/07 20:48:15 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "adio.h"
 #include "adio_extern.h"
 #include "ad_pvfs2.h"
@@ -34,26 +34,26 @@
 
     ret = PVFS_Request_contiguous(len, PVFS_BYTE, &file_req);
     if (ret < 0) {
 	fprintf(stderr, "pvfs_request_contig returns with %d\n", ret);
 	goto error_request;
     }
 
     if (file_ptr_type == ADIO_EXPLICIT_OFFSET) {
-	ret = PVFS_sys_read(pvfs_fs->pinode_refn, file_req, offset, buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_read(pvfs_fs->object_ref, file_req, offset, buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0 ) {
 	    fprintf(stderr, "pvfs_sys_read returns with %d\n", ret);
 	    goto error_read;
 	}
 	fd->fp_sys_posn = offset + (int)resp_io.total_completed;
     } else { 
-	ret = PVFS_sys_read(pvfs_fs->pinode_refn, file_req, fd->fp_ind, buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_read(pvfs_fs->object_ref, file_req, fd->fp_ind, buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0) {
 	    fprintf(stderr, "pvfs_sys_read returns with %d\n", ret);
 	    goto error_read;
 	}
 	fd->fp_ind += (int)resp_io.total_completed;
 	fd->fp_sys_posn = fd->fp_ind;
     }
 #ifdef HAVE_STATUS_SET_BYTES
@@ -69,17 +69,719 @@
 }
 
 
 void ADIOI_PVFS2_ReadStrided(ADIO_File fd, void *buf, int count,
                        MPI_Datatype datatype, int file_ptr_type,
                        ADIO_Offset offset, ADIO_Status *status, int
                        *error_code)
 {
-    /* for now, defer to the generic operations. pvfs2 should have a lot of
-     * ogood ways to express strided io, however... */
-    ADIOI_GEN_ReadStrided(fd, buf, count, datatype, 
-	    file_ptr_type, offset, status, error_code);
+    /* offset is in units of etype relative to the filetype. */
+    ADIOI_Flatlist_node *flat_buf, *flat_file;
+    int i, j, k,  brd_size, frd_size=0, st_index=0;
+    int bufsize, sum, n_etypes_in_filetype, size_in_filetype;
+    int n_filetypes, etype_in_filetype;
+    ADIO_Offset abs_off_in_filetype=0;
+    int filetype_size, etype_size, buftype_size;
+    MPI_Aint filetype_extent, buftype_extent; 
+    int buf_count, buftype_is_contig, filetype_is_contig;
+    ADIO_Offset off, disp, start_off;
+    int flag, st_frd_size, st_n_filetypes;
+
+    int mem_list_count, file_list_count;
+    PVFS_size *mem_offsets;
+    int64_t *file_offsets;
+    int *mem_lengths;
+    int32_t *file_lengths;
+    int total_blks_to_read;
+
+    int max_mem_list, max_file_list;
+
+    int b_blks_read;
+    int f_data_read;
+    int size_read=0, n_read_lists, extra_blks;
+
+    int end_brd_size, end_frd_size;
+    int start_k, start_j, new_file_read, new_buffer_read;
+    int start_mem_offset;
+    PVFS_Request mem_req, file_req;
+    ADIOI_PVFS2_fs * pvfs_fs;
+    PVFS_sysresp_io resp_io;
+    int err_flag=0;
+
+#define MAX_ARRAY_SIZE 64
+
+#ifndef PRINT_ERR_MESG
+  static char myname[] = "ADIOI_PVFS2_ReadStrided";
+#endif
+
+    *error_code = MPI_SUCCESS;  /* changed below if error */
+
+    ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
+    ADIOI_Datatype_iscontig(fd->filetype, &filetype_is_contig);
+    MPI_Type_size(fd->filetype, &filetype_size);
+    if ( ! filetype_size ) {
+	*error_code = MPI_SUCCESS; 
+	return;
+    }
+
+    MPI_Type_extent(fd->filetype, &filetype_extent);
+    MPI_Type_size(datatype, &buftype_size);
+    MPI_Type_extent(datatype, &buftype_extent);
+    etype_size = fd->etype_size;
+
+    bufsize = buftype_size * count;
+    
+    pvfs_fs = (ADIOI_PVFS2_fs*)fd->fs_ptr;
+
+    if (!buftype_is_contig && filetype_is_contig) {
+
+/* noncontiguous in memory, contiguous in file. */
+        int64_t file_offsets;
+	int32_t file_lengths;
+
+	ADIOI_Flatten_datatype(datatype);
+	flat_buf = ADIOI_Flatlist;
+	while (flat_buf->type != datatype) flat_buf = flat_buf->next;
+
+	off = (file_ptr_type == ADIO_INDIVIDUAL) ? fd->fp_ind : 
+	    fd->disp + etype_size * offset;
+
+	file_list_count = 1;
+	file_offsets = off;
+	file_lengths = 0;
+	total_blks_to_read = count*flat_buf->count;
+	b_blks_read = 0;
+
+	/* allocate arrays according to max usage */
+	if (total_blks_to_read > MAX_ARRAY_SIZE)
+	    mem_list_count = MAX_ARRAY_SIZE;
+	else mem_list_count = total_blks_to_read;
+	mem_offsets = (PVFS_size*)ADIOI_Malloc(mem_list_count*sizeof(PVFS_size));
+	mem_lengths = (int*)ADIOI_Malloc(mem_list_count*sizeof(int));
+
+	j = 0;
+	/* step through each block in memory, filling memory arrays */
+	while (b_blks_read < total_blks_to_read) {
+	    for (i=0; i<flat_buf->count; i++) {
+		mem_offsets[b_blks_read % MAX_ARRAY_SIZE] = 
+		    /* TODO: fix this compiler warning */
+		    ((PVFS_size)buf + j*buftype_extent + flat_buf->indices[i]);
+		mem_lengths[b_blks_read % MAX_ARRAY_SIZE] = 
+		    flat_buf->blocklens[i];
+		file_lengths += flat_buf->blocklens[i];
+		b_blks_read++;
+		if (!(b_blks_read % MAX_ARRAY_SIZE) ||
+		    (b_blks_read == total_blks_to_read)) {
+
+		    /* in the case of the last read list call,
+		       adjust mem_list_count */
+		    if (b_blks_read == total_blks_to_read) {
+		        mem_list_count = total_blks_to_read % MAX_ARRAY_SIZE;
+			/* in case last read list call fills max arrays */
+			if (!mem_list_count) mem_list_count = MAX_ARRAY_SIZE;
+		    }
+		    err_flag = PVFS_Request_hindexed(mem_list_count, 
+			    mem_lengths, mem_offsets, PVFS_BYTE, &mem_req);
+		    if (err_flag < 0) break;
+		    err_flag = PVFS_Request_contiguous(file_lengths, 
+			    PVFS_BYTE, &file_req);
+		    if (err_flag < 0) break;
+		    err_flag = PVFS_sys_read(pvfs_fs->object_ref, file_req, 
+			    file_offsets, PVFS_BOTTOM, mem_req, 
+			    &(pvfs_fs->credentials), &resp_io);
+		  
+		    /* in the case of error or the last read list call, 
+		     * leave here */
+		    if (err_flag || b_blks_read == total_blks_to_read) break;
+
+		    file_offsets += file_lengths;
+		    file_lengths = 0;
+		} 
+	    } /* for (i=0; i<flat_buf->count; i++) */
+	    j++;
+	} /* while (b_blks_read < total_blks_to_read) */
+	ADIOI_Free(mem_offsets);
+	ADIOI_Free(mem_lengths);
+
+        if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind = off;
+
+	fd->fp_sys_posn = -1;  /* set it to null. */
+
+#ifdef HAVE_STATUS_SET_BYTES
+	MPIR_Status_set_bytes(status, datatype, bufsize);
+	/* This isa temporary way of filling in status.  The right way is to
+	   keep tracke of how much data was actually read adn placed in buf
+	   by ADIOI_BUFFERED_READ. */
+#endif
+	ADIOI_Delete_flattened(datatype);
+
+	return;
+    } /* if (!buftype_is_contig && filetype_is_contig) */
+
+    /* know file is noncontiguous from above */
+    /* noncontiguous in file */
+
+    /* filetype already flattened in ADIO_Open */
+    flat_file = ADIOI_Flatlist;
+    while (flat_file->type != fd->filetype) flat_file = flat_file->next;
+
+    disp = fd->disp;
+
+    /* for each case - ADIO_Individual pointer or explicit, find the file
+       offset in bytes (offset), n_filetypes (how many filetypes into
+       file to start), frd_size (remaining amount of data in present
+       file block), and st_index (start point in terms of blocks in
+       starting filetype) */
+    if (file_ptr_type == ADIO_INDIVIDUAL) {
+        offset = fd->fp_ind; /* in bytes */
+	n_filetypes = -1;
+	flag = 0;
+	while (!flag) {
+	    n_filetypes++;
+	    for (i=0; i<flat_file->count; i++) {
+	        if (disp + flat_file->indices[i] + 
+		    (ADIO_Offset) n_filetypes*filetype_extent +
+		    flat_file->blocklens[i]  >= offset) {
+		    st_index = i;
+		    frd_size = (int) (disp + flat_file->indices[i] + 
+				      (ADIO_Offset) n_filetypes*filetype_extent
+				      + flat_file->blocklens[i] - offset);
+		    flag = 1;
+		    break;
+		}
+	    }
+	} /* while (!flag) */
+    } /* if (file_ptr_type == ADIOI_INDIVIDUAL) */
+    else {
+        n_etypes_in_filetype = filetype_size/etype_size;
+	n_filetypes = (int) (offset / n_etypes_in_filetype);
+	etype_in_filetype = (int) (offset % n_etypes_in_filetype);
+	size_in_filetype = etype_in_filetype * etype_size;
+	
+	sum = 0;
+	for (i=0; i<flat_file->count; i++) {
+	    sum += flat_file->blocklens[i];
+	    if (sum > size_in_filetype) {
+	        st_index = i;
+		frd_size = sum - size_in_filetype;
+		abs_off_in_filetype = flat_file->indices[i] +
+		    size_in_filetype - (sum - flat_file->blocklens[i]);
+		break;
+	    }
+	}
+	
+	/* abs. offset in bytes in the file */
+	offset = disp + (ADIO_Offset) n_filetypes*filetype_extent + 
+	    abs_off_in_filetype;
+    } /* else [file_ptr_type != ADIOI_INDIVIDUAL] */
+
+    start_off = offset;
+    st_frd_size = frd_size;
+    st_n_filetypes = n_filetypes;
+    
+    if (buftype_is_contig && !filetype_is_contig) {
+
+/* contiguous in memory, noncontiguous in file. should be the most
+   common case. */
+
+        int mem_lengths;
+	char *mem_offsets;
+	
+	i = 0;
+	j = st_index;
+	n_filetypes = st_n_filetypes;
+	
+	mem_list_count = 1;
+	
+	/* determine how many blocks in file to read */
+	f_data_read = ADIOI_MIN(st_frd_size, bufsize);
+	total_blks_to_read = 1;
+	j++;
+	while (f_data_read < bufsize) {
+	    f_data_read += flat_file->blocklens[j];
+	    total_blks_to_read++;
+	    if (j<(flat_file->count-1)) j++;
+	    else j = 0;	
+	}
+      
+	j = st_index;
+	n_filetypes = st_n_filetypes;
+	n_read_lists = total_blks_to_read/MAX_ARRAY_SIZE;
+	extra_blks = total_blks_to_read%MAX_ARRAY_SIZE;
+	
+	mem_offsets = buf;
+	mem_lengths = 0;
+	
+	/* if at least one full readlist, allocate file arrays
+	   at max array size and don't free until very end */
+	if (n_read_lists) {
+	    file_offsets = (int64_t*)ADIOI_Malloc(MAX_ARRAY_SIZE*
+						  sizeof(int64_t));
+	    file_lengths = (int32_t*)ADIOI_Malloc(MAX_ARRAY_SIZE*
+						  sizeof(int32_t));
+	}
+	/* if there's no full readlist allocate file arrays according
+	   to needed size (extra_blks) */
+	else {
+	    file_offsets = (int64_t*)ADIOI_Malloc(extra_blks*
+						  sizeof(int64_t));
+	    file_lengths = (int32_t*)ADIOI_Malloc(extra_blks*
+						  sizeof(int32_t));
+	}
+	
+	/* for file arrays that are of MAX_ARRAY_SIZE, build arrays */
+	for (i=0; i<n_read_lists; i++) {
+	    file_list_count = MAX_ARRAY_SIZE;
+	    if(!i) {
+	        file_offsets[0] = offset;
+		file_lengths[0] = st_frd_size;
+		mem_lengths = st_frd_size;
+	    }
+	    for (k=0; k<MAX_ARRAY_SIZE; k++) {
+	        if (i || k) {
+		    file_offsets[k] = disp + n_filetypes*filetype_extent
+		      + flat_file->indices[j];
+		    file_lengths[k] = flat_file->blocklens[j];
+		    mem_lengths += file_lengths[k];
+		}
+		if (j<(flat_file->count - 1)) j++;
+		else {
+		    j = 0;
+		    n_filetypes++;
+		}
+	    } /* for (k=0; k<MAX_ARRAY_SIZE; k++) */
+	    err_flag = PVFS_Request_contiguous(mem_lengths, 
+		    PVFS_BYTE, &mem_req);
+	    if (err_flag < 0) 
+		goto error_state;
+	    err_flag = PVFS_Request_hindexed(file_list_count, file_lengths, 
+		    file_offsets, PVFS_BYTE, &file_req);
+	    if (err_flag < 0)
+		goto error_state;
+	    /* PVFS_Request_hindexed already expresses the offsets into the
+	     * file, so we should not pass in an offset if we are using
+	     * hindexed for the file type */
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    mem_offsets, mem_req, &(pvfs_fs->credentials), &resp_io);
+	    if (err_flag < 0)
+		goto error_state;
+	    mem_offsets += mem_lengths;
+	    mem_lengths = 0;
+	} /* for (i=0; i<n_read_lists; i++) */
+
+	/* for file arrays smaller than MAX_ARRAY_SIZE (last read_list call) */
+	if (extra_blks) {
+	    file_list_count = extra_blks;
+	    if(!i) {
+	        file_offsets[0] = offset;
+		file_lengths[0] = st_frd_size;
+	    }
+	    for (k=0; k<extra_blks; k++) {
+	        if(i || k) {
+		    file_offsets[k] = disp + n_filetypes*filetype_extent +
+		      flat_file->indices[j];
+		    if (k == (extra_blks - 1)) {
+		        file_lengths[k] = bufsize - (int32_t) mem_lengths
+			  - (int32_t) mem_offsets + (int32_t)  buf;
+		    }
+		    else file_lengths[k] = flat_file->blocklens[j];
+		} /* if(i || k) */
+		mem_lengths += file_lengths[k];
+		if (j<(flat_file->count - 1)) j++;
+		else {
+		    j = 0;
+		    n_filetypes++;
+		}
+	    } /* for (k=0; k<extra_blks; k++) */
+	    err_flag = PVFS_Request_contiguous(mem_lengths, 
+		    PVFS_BYTE, &mem_req);
+	    if (err_flag < 0)
+		goto error_state;
+	    err_flag = PVFS_Request_hindexed(file_list_count, file_lengths, 
+		    file_offsets, PVFS_BYTE, &file_req);
+	    if (err_flag < 0)
+		goto error_state;
+	    /* as above, use 0 for 'offset' when using hindexed file type*/
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    mem_offsets, mem_req, &(pvfs_fs->credentials), &resp_io);
+	    if (err_flag < 0)
+		goto error_state;
+	}
+    }
+    else {
+/* noncontiguous in memory as well as in file */
+      
+        ADIOI_Flatten_datatype(datatype);
+	flat_buf = ADIOI_Flatlist;
+	while (flat_buf->type != datatype) flat_buf = flat_buf->next;
+
+	size_read = 0;
+	n_filetypes = st_n_filetypes;
+	frd_size = st_frd_size;
+	brd_size = flat_buf->blocklens[0];
+	buf_count = 0;
+	start_mem_offset = 0;
+	start_k = k = 0;
+	start_j = st_index;
+	max_mem_list = 0;
+	max_file_list = 0;
+
+	/* run through and file max_file_list and max_mem_list so that you 
+	   can allocate the file and memory arrays less than MAX_ARRAY_SIZE
+	   if possible */
+
+	while (size_read < bufsize) {
+	    k = start_k;
+	    new_buffer_read = 0;
+	    mem_list_count = 0;
+	    while ((mem_list_count < MAX_ARRAY_SIZE) && 
+		   (new_buffer_read < bufsize-size_read)) {
+	        /* find mem_list_count and file_list_count such that both are
+		   less than MAX_ARRAY_SIZE, the sum of their lengths are
+		   equal, and the sum of all the data read and data to be
+		   read in the next immediate read list is less than
+		   bufsize */
+	        if(mem_list_count) {
+		    if((new_buffer_read + flat_buf->blocklens[k] + 
+			size_read) > bufsize) {
+		        end_brd_size = new_buffer_read + 
+			    flat_buf->blocklens[k] - (bufsize - size_read);
+			new_buffer_read = bufsize - size_read;
+		    }
+		    else {
+		        new_buffer_read += flat_buf->blocklens[k];
+			end_brd_size = flat_buf->blocklens[k];
+		    }
+		}
+		else {
+		    if (brd_size > (bufsize - size_read)) {
+		        new_buffer_read = bufsize - size_read;
+			brd_size = new_buffer_read;
+		    }
+		    else new_buffer_read = brd_size;
+		}
+		mem_list_count++;
+		k = (k + 1)%flat_buf->count;
+	     } /* while ((mem_list_count < MAX_ARRAY_SIZE) && 
+	       (new_buffer_read < bufsize-size_read)) */
+	    j = start_j;
+	    new_file_read = 0;
+	    file_list_count = 0;
+	    while ((file_list_count < MAX_ARRAY_SIZE) && 
+		   (new_file_read < new_buffer_read)) {
+	        if(file_list_count) {
+		    if((new_file_read + flat_file->blocklens[j]) > 
+		       new_buffer_read) {
+		        end_frd_size = new_buffer_read - new_file_read;
+			new_file_read = new_buffer_read;
+			j--;
+		    }
+		    else {
+		        new_file_read += flat_file->blocklens[j];
+			end_frd_size = flat_file->blocklens[j];
+		    }
+		}
+		else {
+		    if (frd_size > new_buffer_read) {
+		        new_file_read = new_buffer_read;
+			frd_size = new_file_read;
+		    }
+		    else new_file_read = frd_size;
+		}
+		file_list_count++;
+		if (j < (flat_file->count - 1)) j++;
+		else j = 0;
+		
+		k = start_k;
+		if ((new_file_read < new_buffer_read) && 
+		    (file_list_count == MAX_ARRAY_SIZE)) {
+		    new_buffer_read = 0;
+		    mem_list_count = 0;
+		    while (new_buffer_read < new_file_read) {
+		        if(mem_list_count) {
+			    if((new_buffer_read + flat_buf->blocklens[k]) >
+			       new_file_read) {
+			        end_brd_size = new_file_read - new_buffer_read;
+				new_buffer_read = new_file_read;
+				k--;
+			    }
+			    else {
+			        new_buffer_read += flat_buf->blocklens[k];
+				end_brd_size = flat_buf->blocklens[k];
+			    }
+			}
+			else {
+			    new_buffer_read = brd_size;
+			    if (brd_size > (bufsize - size_read)) {
+			        new_buffer_read = bufsize - size_read;
+				brd_size = new_buffer_read;
+			    }
+			}
+			mem_list_count++;
+			k = (k + 1)%flat_buf->count;
+		    } /* while (new_buffer_read < new_file_read) */
+		} /* if ((new_file_read < new_buffer_read) && (file_list_count
+		     == MAX_ARRAY_SIZE)) */
+	    } /* while ((mem_list_count < MAX_ARRAY_SIZE) && 
+		 (new_buffer_read < bufsize-size_read)) */
+
+	    /*  fakes filling the readlist arrays of lengths found above  */
+	    k = start_k;
+	    j = start_j;
+	    for (i=0; i<mem_list_count; i++) {	     
+		if(i) {
+		    if (i == (mem_list_count - 1)) {
+			if (flat_buf->blocklens[k] == end_brd_size)
+			    brd_size = flat_buf->blocklens[(k+1)%
+							  flat_buf->count];
+			else {
+			    brd_size = flat_buf->blocklens[k] - end_brd_size;
+			    k--;
+			    buf_count--;
+			}
+		    }
+		}
+		buf_count++;
+		k = (k + 1)%flat_buf->count;
+	    } /* for (i=0; i<mem_list_count; i++) */
+	    for (i=0; i<file_list_count; i++) {
+		if (i) {
+		    if (i == (file_list_count - 1)) {
+			if (flat_file->blocklens[j] == end_frd_size)
+			    frd_size = flat_file->blocklens[(j+1)%
+							  flat_file->count];   
+			else {
+			    frd_size = flat_file->blocklens[j] - end_frd_size;
+			    j--;
+			}
+		    }
+		}
+		if (j < flat_file->count - 1) j++;
+		else {
+		    j = 0;
+		    n_filetypes++;
+		}
+	    } /* for (i=0; i<file_list_count; i++) */
+	    size_read += new_buffer_read;
+	    start_k = k;
+	    start_j = j;
+	    if (max_mem_list < mem_list_count)
+	        max_mem_list = mem_list_count;
+	    if (max_file_list < file_list_count)
+	        max_file_list = file_list_count;
+	    if (max_mem_list == max_mem_list == MAX_ARRAY_SIZE)
+	        break;
+	} /* while (size_read < bufsize) */
+
+	mem_offsets = (PVFS_size*)ADIOI_Malloc(max_mem_list*sizeof(PVFS_size*));
+	mem_lengths = (int *)ADIOI_Malloc(max_mem_list*sizeof(int));
+	file_offsets = (int64_t *)ADIOI_Malloc(max_file_list*sizeof(int64_t));
+	file_lengths = (int32_t *)ADIOI_Malloc(max_file_list*sizeof(int32_t));
+	    
+	size_read = 0;
+	n_filetypes = st_n_filetypes;
+	frd_size = st_frd_size;
+	brd_size = flat_buf->blocklens[0];
+	buf_count = 0;
+	start_mem_offset = 0;
+	start_k = k = 0;
+	start_j = st_index;
+
+	/*  this section calculates mem_list_count and file_list_count
+	    and also finds the possibly odd sized last array elements
+	    in new_frd_size and new_brd_size  */
+	
+	while (size_read < bufsize) {
+	    k = start_k;
+	    new_buffer_read = 0;
+	    mem_list_count = 0;
+	    while ((mem_list_count < MAX_ARRAY_SIZE) && 
+		   (new_buffer_read < bufsize-size_read)) {
+	        /* find mem_list_count and file_list_count such that both are
+		   less than MAX_ARRAY_SIZE, the sum of their lengths are
+		   equal, and the sum of all the data read and data to be
+		   read in the next immediate read list is less than
+		   bufsize */
+	        if(mem_list_count) {
+		    if((new_buffer_read + flat_buf->blocklens[k] + 
+			size_read) > bufsize) {
+		        end_brd_size = new_buffer_read + 
+			    flat_buf->blocklens[k] - (bufsize - size_read);
+			new_buffer_read = bufsize - size_read;
+		    }
+		    else {
+		        new_buffer_read += flat_buf->blocklens[k];
+			end_brd_size = flat_buf->blocklens[k];
+		    }
+		}
+		else {
+		    if (brd_size > (bufsize - size_read)) {
+		        new_buffer_read = bufsize - size_read;
+			brd_size = new_buffer_read;
+		    }
+		    else new_buffer_read = brd_size;
+		}
+		mem_list_count++;
+		k = (k + 1)%flat_buf->count;
+	     } /* while ((mem_list_count < MAX_ARRAY_SIZE) && 
+	       (new_buffer_read < bufsize-size_read)) */
+	    j = start_j;
+	    new_file_read = 0;
+	    file_list_count = 0;
+	    while ((file_list_count < MAX_ARRAY_SIZE) && 
+		   (new_file_read < new_buffer_read)) {
+	        if(file_list_count) {
+		    if((new_file_read + flat_file->blocklens[j]) > 
+		       new_buffer_read) {
+		        end_frd_size = new_buffer_read - new_file_read;
+			new_file_read = new_buffer_read;
+			j--;
+		    }
+		    else {
+		        new_file_read += flat_file->blocklens[j];
+			end_frd_size = flat_file->blocklens[j];
+		    }
+		}
+		else {
+		    if (frd_size > new_buffer_read) {
+		        new_file_read = new_buffer_read;
+			frd_size = new_file_read;
+		    }
+		    else new_file_read = frd_size;
+		}
+		file_list_count++;
+		if (j < (flat_file->count - 1)) j++;
+		else j = 0;
+		
+		k = start_k;
+		if ((new_file_read < new_buffer_read) && 
+		    (file_list_count == MAX_ARRAY_SIZE)) {
+		    new_buffer_read = 0;
+		    mem_list_count = 0;
+		    while (new_buffer_read < new_file_read) {
+		        if(mem_list_count) {
+			    if((new_buffer_read + flat_buf->blocklens[k]) >
+			       new_file_read) {
+			        end_brd_size = new_file_read - new_buffer_read;
+				new_buffer_read = new_file_read;
+				k--;
+			    }
+			    else {
+			        new_buffer_read += flat_buf->blocklens[k];
+				end_brd_size = flat_buf->blocklens[k];
+			    }
+			}
+			else {
+			    new_buffer_read = brd_size;
+			    if (brd_size > (bufsize - size_read)) {
+			        new_buffer_read = bufsize - size_read;
+				brd_size = new_buffer_read;
+			    }
+			}
+			mem_list_count++;
+			k = (k + 1)%flat_buf->count;
+		    } /* while (new_buffer_read < new_file_read) */
+		} /* if ((new_file_read < new_buffer_read) && (file_list_count
+		     == MAX_ARRAY_SIZE)) */
+	    } /* while ((mem_list_count < MAX_ARRAY_SIZE) && 
+		 (new_buffer_read < bufsize-size_read)) */
+
+	    /*  fills the allocated readlist arrays  */
+	    k = start_k;
+	    j = start_j;
+	    for (i=0; i<mem_list_count; i++) {	     
+	        mem_offsets[i] = ((PVFS_size)buf + buftype_extent*
+					 (buf_count/flat_buf->count) +
+					 (int)flat_buf->indices[k]);
+		if(!i) {
+		    mem_lengths[0] = brd_size;
+		    mem_offsets[0] += flat_buf->blocklens[k] - brd_size;
+		}
+		else {
+		    if (i == (mem_list_count - 1)) {
+		        mem_lengths[i] = end_brd_size;
+			if (flat_buf->blocklens[k] == end_brd_size)
+			    brd_size = flat_buf->blocklens[(k+1)%
+							  flat_buf->count];
+			else {
+			    brd_size = flat_buf->blocklens[k] - end_brd_size;
+			    k--;
+			    buf_count--;
+			}
+		    }
+		    else {
+		        mem_lengths[i] = flat_buf->blocklens[k];
+		    }
+		}
+		buf_count++;
+		k = (k + 1)%flat_buf->count;
+	    } /* for (i=0; i<mem_list_count; i++) */
+	    for (i=0; i<file_list_count; i++) {
+	        file_offsets[i] = disp + flat_file->indices[j] + n_filetypes *
+		    filetype_extent;
+	        if (!i) {
+		    file_lengths[0] = frd_size;
+		    file_offsets[0] += flat_file->blocklens[j] - frd_size;
+		}
+		else {
+		    if (i == (file_list_count - 1)) {
+		        file_lengths[i] = end_frd_size;
+			if (flat_file->blocklens[j] == end_frd_size)
+			    frd_size = flat_file->blocklens[(j+1)%
+							  flat_file->count];   
+			else {
+			    frd_size = flat_file->blocklens[j] - end_frd_size;
+			    j--;
+			}
+		    }
+		    else file_lengths[i] = flat_file->blocklens[j];
+		}
+		if (j < flat_file->count - 1) j++;
+		else {
+		    j = 0;
+		    n_filetypes++;
+		}
+	    } /* for (i=0; i<file_list_count; i++) */
+	    err_flag = PVFS_Request_hindexed(mem_list_count, mem_lengths, 
+		    mem_offsets, PVFS_BYTE, &mem_req);
+	    if (err_flag < 0 ) 
+		goto error_state;
+	    err_flag = PVFS_Request_hindexed(file_list_count, file_lengths, 
+		    file_offsets, PVFS_BYTE, &file_req);
+	    if (err_flag < 0)
+		goto error_state;
+	    /* offset will be expressed in memory and file datatypes */
+	    err_flag = PVFS_sys_read(pvfs_fs->object_ref, file_req, 0, 
+		    PVFS_BOTTOM, mem_req, &(pvfs_fs->credentials), &resp_io);
+	    size_read += new_buffer_read;
+	    start_k = k;
+	    start_j = j;
+	} /* while (size_read < bufsize) */
+	ADIOI_Free(mem_offsets);
+	ADIOI_Free(mem_lengths);
+    }
+    ADIOI_Free(file_offsets);
+    ADIOI_Free(file_lengths);
+    
+    if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind = off;
+
+error_state:
+    if (err_flag) {
+	ADIOI_PVFS2_pvfs_error_convert(err_flag, error_code);
+    }
+    else *error_code = MPI_SUCCESS;
+    
+    fd->fp_sys_posn = -1;   /* set it to null. */
+
+#ifdef HAVE_STATUS_SET_BYTES
+    MPIR_Status_set_bytes(status, datatype, bufsize);
+    /* This is a temporary way of filling in status. The right way is to 
+       keep track of how much data was actually read and placed in buf 
+       by ADIOI_BUFFERED_READ. */
+#endif
+    
+    if (!buftype_is_contig) ADIOI_Delete_flattened(datatype);
 }
 
 /*
  * vim: ts=8 sts=4 sw=4 noexpandtab 
  */
Index: romio/adio/ad_pvfs2/ad_pvfs2_resize.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_resize.c,v
retrieving revision 1.4
retrieving revision 1.10
--- romio/adio/ad_pvfs2/ad_pvfs2_resize.c	4 Sep 2003 23:20:09 -0000	1.4
+++ romio/adio/ad_pvfs2/ad_pvfs2_resize.c	20 May 2004 20:31:05 -0000	1.10
@@ -1,29 +1,46 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_resize.c,v 1.4 2003/09/04 23:20:09 robl Exp $
+ *   $Id: ad_pvfs2_resize.c,v 1.10 2004/05/20 20:31:05 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 #include "ad_pvfs2_common.h"
 
+/* as with ADIOI_PVFS2_Flush, implement the resize operation in a scalable
+ * manner. one process does the work, then broadcasts the result to everyone
+ * else.  fortunately, this operation is defined to be collective */
 void ADIOI_PVFS2_Resize(ADIO_File fd, ADIO_Offset size, int *error_code)
 {
-    int ret;
+    int ret, rank;
     ADIOI_PVFS2_fs *pvfs_fs;
 
+    *error_code = MPI_SUCCESS;
+
     pvfs_fs = (ADIOI_PVFS2_fs*)fd->fs_ptr;
 
-    ret = PVFS_sys_truncate(pvfs_fs->pinode_refn, size, pvfs_fs->credentials);
-    if (ret < 0 ) {
-	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
+    MPI_Comm_rank(fd->comm, &rank);
+
+    /* We desginate one node in the communicator to be an 'io_worker' in 
+     * ADIO_Open.  This node can perform operations on files and then 
+     * inform the other nodes of the result */
+
+    /* we know all processes have reached this point because we did an
+     * MPI_Barrier in MPI_File_set_size() */
+
+    if (rank == fd->hints->ranklist[0]) {
+	ret = PVFS_sys_truncate(pvfs_fs->object_ref, 
+		size, &(pvfs_fs->credentials));
+	MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
     } else {
-	*error_code = MPI_SUCCESS;
+	MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
     }
+    if (ret < 0 ) 
+	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 }
 
 /*
  * vim: ts=8 sts=4 sw=4 noexpandtab 
  */
Index: romio/adio/ad_pvfs2/ad_pvfs2_write.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_pvfs2/ad_pvfs2_write.c,v
retrieving revision 1.11
retrieving revision 1.13
--- romio/adio/ad_pvfs2/ad_pvfs2_write.c	5 Sep 2003 20:47:47 -0000	1.11
+++ romio/adio/ad_pvfs2/ad_pvfs2_write.c	20 May 2004 20:31:05 -0000	1.13
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- 
  *   vim: ts=8 sts=4 sw=4 noexpandtab
- *   $Id: ad_pvfs2_write.c,v 1.11 2003/09/05 20:47:47 robl Exp $
+ *   $Id: ad_pvfs2_write.c,v 1.13 2004/05/20 20:31:05 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "ad_pvfs2.h"
 #include "adio_extern.h"
 
@@ -33,26 +33,26 @@
 
     ret = PVFS_Request_contiguous(len, PVFS_BYTE, &file_req);
     if (ret < 0) {
 	fprintf(stderr, "pvfs_request_contig returns with %d\n", ret);
 	goto error_request;
     }
 
     if (file_ptr_type == ADIO_EXPLICIT_OFFSET) {
-	ret = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, offset,  buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_write(pvfs_fs->object_ref, file_req, offset,  buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0 ) {
 	    fprintf(stderr, "pvfs_sys_write returns with %d\n", ret);
 	    goto error_write;
 	}
 	fd->fp_sys_posn = offset + (int) resp_io.total_completed;
     } else {
-	ret = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, fd->fp_ind, buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_write(pvfs_fs->object_ref, file_req, fd->fp_ind, buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0) {
 	    fprintf(stderr, "pvfs_sys_write returns with %d\n", ret);
 	    goto error_write;
 	}
 	fd->fp_ind += (int)resp_io.total_completed;
 	fd->fp_sys_posn = fd->fp_ind;
     }
 #ifdef HAVE_STATUS_SET_BYTES
@@ -200,19 +200,19 @@
 		    }
 
 		    err_flag = PVFS_Request_hindexed(mem_list_count, 
 			    mem_lengths, mem_offsets, PVFS_BYTE, &mem_req);
 		    if (err_flag < 0) break;
 		    err_flag = PVFS_Request_contiguous(file_lengths, 
 			    PVFS_BYTE, &file_req);
 		    if (err_flag < 0) break;
-		    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 
+		    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 
 			    file_offsets, PVFS_BOTTOM, mem_req, 
-			    pvfs_fs->credentials, &resp_io);
+			    &(pvfs_fs->credentials), &resp_io);
 		  
 		    /* in the case of error or the last read list call, 
 		     * leave here */
 		    if (err_flag || b_blks_wrote == total_blks_to_write) break;
 
 		    file_offsets += file_lengths;
 		    file_lengths = 0;
 		} 
@@ -380,18 +380,18 @@
 		goto error_state;
 	    err_flag = PVFS_Request_hindexed(file_list_count, file_lengths, 
 		    file_offsets, PVFS_BYTE, &file_req);
 	    if (err_flag < 0)
 		goto error_state;
 	    /* PVFS_Request_hindexed already expresses the offsets into the
 	     * file, so we should not pass in an offset if we are using
 	     * hindexed for the file type */
-	    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 0, 
-		    mem_offsets, mem_req, pvfs_fs->credentials, &resp_io);
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    mem_offsets, mem_req, &(pvfs_fs->credentials), &resp_io);
 	    if (err_flag < 0)
 		goto error_state;
 
             mem_offsets += mem_lengths;
             mem_lengths = 0;
         } /* for (i=0; i<n_write_lists; i++) */
 
         /* for file arrays smaller than MAX_ARRAY_SIZE (last read_list call) */
@@ -422,18 +422,18 @@
 		    PVFS_BYTE, &mem_req);
 	    if (err_flag < 0)
 		goto error_state;
 	    err_flag = PVFS_Request_hindexed(file_list_count, file_lengths, 
 		    file_offsets, PVFS_BYTE, &file_req);
 	    if (err_flag < 0)
 		goto error_state;
 	    /* as above, use 0 for 'offset' when using hindexed file type*/
-	    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 0, 
-		    mem_offsets, mem_req, pvfs_fs->credentials, &resp_io);
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    mem_offsets, mem_req, &(pvfs_fs->credentials), &resp_io);
 	    if (err_flag < 0)
 		goto error_state;
         }
     } 
     else {
         /* noncontiguous in memory as well as in file */
 
         ADIOI_Flatten_datatype(datatype);
@@ -776,18 +776,18 @@
 		    mem_offsets, PVFS_BYTE, &mem_req);
 	    if (err_flag < 0 ) 
 		goto error_state;
 	    err_flag = PVFS_Request_hindexed(file_list_count, file_lengths, 
 		    file_offsets, PVFS_BYTE, &file_req);
 	    if (err_flag < 0)
 		goto error_state;
 	    /* offset will be expressed in memory and file datatypes */
-	    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 0, 
-		    PVFS_BOTTOM, mem_req, pvfs_fs->credentials, &resp_io);
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    PVFS_BOTTOM, mem_req, &(pvfs_fs->credentials), &resp_io);
 	    size_wrote += new_buffer_write;
 	    start_k = k;
 	    start_j = j;
 	} /* while (size_wrote < bufsize) */
 	ADIOI_Free(mem_offsets);
 	ADIOI_Free(mem_lengths);
     }
     ADIOI_Free(file_offsets);
Index: romio/adio/ad_sfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_sfs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_sfs/.cvsignore	1 Aug 2003 13:30:18 -0000	1.2
+++ romio/adio/ad_sfs/.cvsignore	19 Jan 2004 14:49:36 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_testfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_testfs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_testfs/.cvsignore	1 Aug 2003 13:30:19 -0000	1.2
+++ romio/adio/ad_testfs/.cvsignore	19 Jan 2004 14:49:36 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_ufs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_ufs/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/adio/ad_ufs/.cvsignore	1 Aug 2003 13:30:19 -0000	1.2
+++ romio/adio/ad_ufs/.cvsignore	19 Jan 2004 14:49:37 -0000	1.3
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_xfs/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/ad_xfs/.cvsignore,v
retrieving revision 1.3
retrieving revision 1.4
--- romio/adio/ad_xfs/.cvsignore	1 Aug 2003 13:30:19 -0000	1.3
+++ romio/adio/ad_xfs/.cvsignore	19 Jan 2004 14:49:37 -0000	1.4
@@ -1,4 +1,5 @@
 Makefile
 *.safe
-
 .deps
+*.bb
+*.bbg
Index: romio/adio/common/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/common/.cvsignore,v
retrieving revision 1.3
retrieving revision 1.4
--- romio/adio/common/.cvsignore	1 Aug 2003 13:30:19 -0000	1.3
+++ romio/adio/common/.cvsignore	19 Jan 2004 14:49:37 -0000	1.4
@@ -1,5 +1,6 @@
 Makefile
 Debug*
 Release*
-
 .deps
+*.bb
+*.bbg
Index: romio/adio/common/Makefile.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/common/Makefile.in,v
retrieving revision 1.12
retrieving revision 1.15
--- romio/adio/common/Makefile.in	7 Oct 2003 22:12:29 -0000	1.12
+++ romio/adio/common/Makefile.in	6 Feb 2004 15:57:24 -0000	1.15
@@ -14,17 +14,18 @@
 @VPATH@
 
 AD_OBJECTS = ad_close.o ad_init.o ad_end.o ad_open.o setfn.o flatten.o \
       async_list.o req_malloc.o malloc.o ad_read_coll.o eof_offset.o \
       ad_write_coll.o lock.o ad_read_str.o ad_write_str.o iscontig.o \
       get_fp_posn.o ad_seek.o ad_delete.o ad_flush.o ad_hints.o error.o \
       ad_fstype.o ad_get_sh_fp.o ad_set_sh_fp.o shfp_fname.o byte_offset.o \
       status_setb.o ad_aggregate.o cb_config_list.o \
-      ad_read_str_naive.o gencheck.o ad_set_view.o ad_iopen.o
+      ad_read_str_naive.o gencheck.o ad_set_view.o ad_iopen.o \
+      ad_write_str_naive.o
 
 all: $(LIBNAME)
 	@if [ "@ENABLE_SHLIB@" != "none" ] ; then \
 	    $(MAKE) $(SHLIBNAME).la ;\
 	fi
 
 .SUFFIXES: $(SUFFIXES) .p .lo
 
@@ -39,8 +40,14 @@
 
 AD_LOOBJECTS = $(AD_OBJECTS:.o=.lo)
 
 $(SHLIBNAME).la: $(AD_LOOBJECTS)
 	$(AR) $(SHLIBNAME).la $(AD_LOOBJECTS)
 
 clean:
 	@rm -f *.o *.lo
+
+tags: TAGS
+SOURCES = ${AD_OBJECTS:.o=.c}
+HEADERS = 
+TAGS:${HEADERS} ${SOURCES}
+	here=`cd ../../../../.. && pwd` ; cd ${srcdir} && etags -o $$here/TAGS --append ${HEADERS} ${SOURCES}
Index: romio/adio/common/ad_open.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/common/ad_open.c,v
retrieving revision 1.23
retrieving revision 1.27
--- romio/adio/common/ad_open.c	5 Sep 2003 22:35:49 -0000	1.23
+++ romio/adio/common/ad_open.c	20 May 2004 07:43:36 -0000	1.27
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_open.c,v 1.23 2003/09/05 22:35:49 gropp Exp $    
+ *   $Id: ad_open.c,v 1.27 2004/05/20 07:43:36 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "adio.h"
 #include "adio_extern.h"
 #include "adio_cb_config_list.h"
@@ -24,17 +24,17 @@
     ADIO_File fd;
     ADIO_cb_name_array array;
     int orig_amode_excl, orig_amode_wronly, err, rank, procs, agg_rank;
     char *value;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "ADIO_OPEN";
 #endif
 
-    int rank_ct;
+    int rank_ct, max_error_code;
     int *tmp_ranklist;
     MPI_Comm aggregator_comm = MPI_COMM_NULL; /* just for deferred opens */
 
     *error_code = MPI_SUCCESS;
 
     fd = (ADIO_File) ADIOI_Malloc(sizeof(struct ADIOI_FileD));
     if (fd == NULL) {
 	/* NEED TO HANDLE ENOMEM ERRORS */
@@ -121,17 +121,17 @@
 	*error_code = MPI_ERR_UNKNOWN;
 #else
 	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR, myname,
 				      "Open Error", "%s", 
 				      "No aggregators match");
 	ADIOI_Error(MPI_FILE_NULL, *error_code, myname);
 #endif
 	fd = ADIO_FILE_NULL;
-	return fd;
+        goto fn_exit;
     }
 
     /* deferred open: 
      * we can only do this if 'fd->hints->deferred_open' is set (which means
      * the user hinted 'no_indep_rw' and collective buffering).  Furthermore,
      * we only do this if our collective read/write routines use our generic
      * function, and not an fs-specific routine (we can defer opens only if we
      * use our aggreagation code). 
@@ -148,24 +148,28 @@
 	    /* MPI_Comm_split will create a communication group of aggregators.
 	     * for non-aggregators it will return MPI_COMM_NULL .  we rely on
 	     * fd->agg_comm == MPI_COMM_NULL for non-aggregators in several
 	     * tests in the code  */
 	    if (is_aggregator(rank, fd)) {
 		    MPI_Comm_split(fd->comm, 1, 0, &aggregator_comm);
 		    fd->agg_comm = aggregator_comm;
 		    MPI_Comm_rank(fd->agg_comm, &agg_rank);
-		    if (agg_rank == 0) fd->io_worker = 1;
+		    if (agg_rank == 0) {
+			    fd->io_worker = 1;
+		    }
 	    } else {
 		    MPI_Comm_split(fd->comm, MPI_UNDEFINED, 0, &aggregator_comm);
 		    fd->agg_comm = aggregator_comm;
 	    }
 
     } else {
-	    if (rank == 0) fd->io_worker = 1;
+	    if (rank == 0) {
+		    fd->io_worker = 1;
+	    }
     }
 
     orig_amode_excl = access_mode;
 
     /* we used to do this EXCL|CREAT workaround in MPI_File_open, but if we are
      * doing deferred open, we more easily know who the aggregators are in
      * ADIO_Open */
     if ((access_mode & MPI_MODE_CREATE) && (access_mode & MPI_MODE_EXCL)) {
@@ -179,24 +183,17 @@
 		MPI_Bcast(error_code, 1, MPI_INT, 0, fd->comm);
 		/* if no error, close the file and reopen normally below */
 		if (*error_code == MPI_SUCCESS) 
 			(*(fd->fns->ADIOI_xxx_Close))(fd, error_code);
        }
        else MPI_Bcast(error_code, 1, MPI_INT, 0, fd->comm);
 
        if (*error_code != MPI_SUCCESS) {
-	       /* copied from below */
-	       ADIOI_Free(fd->fns);
-	       MPI_Comm_free(&(fd->comm));
-	       free(fd->filename);
-	       MPI_Info_free(&(fd->info));
-	       ADIOI_Free(fd);
-	       fd = ADIO_FILE_NULL;
-	       return fd;
+           goto fn_exit;
        } 
        else {
 	       /* turn off EXCL for real open */
 	       access_mode = access_mode ^ MPI_MODE_EXCL; 
        }
     }
 
     /* if we are doing deferred open, non-aggregators should return now */
@@ -204,17 +201,17 @@
 		    ADIOI_Uses_generic_read(fd) &&
 		    ADIOI_Uses_generic_write(fd) ) {
 	    if (fd->agg_comm == MPI_COMM_NULL) {
 		    /* we might have turned off EXCL for the aggregators.
 		     * restore access_mode that non-aggregators get the right
 		     * value from get_amode */
 		    fd->access_mode = orig_amode_excl;
 		    *error_code = MPI_SUCCESS;
-		    return fd;
+            goto fn_exit;
 	    }
     }
 
 /* For writing with data sieving, a read-modify-write is needed. If 
    the file is opened for write_only, the read will fail. Therefore,
    if write_only, open the file as read_write, but record it as write_only
    in fd, so that get_amode returns the right answer. */
 
@@ -235,24 +232,55 @@
 
     /* if we turned off EXCL earlier, then we should turn it back on */
     if (fd->access_mode != orig_amode_excl) fd->access_mode = orig_amode_excl;
 
     /* for deferred open: this process has opened the file (because if we are
      * not an aggregaor and we are doing deferred open, we returned earlier)*/
     fd->is_open = 1;
 
-    /* if error, free and set fd to NULL */
-    if (*error_code != MPI_SUCCESS) {
-	ADIOI_Free(fd->fns);
-	MPI_Comm_free(&(fd->comm));
-	free(fd->filename);
-	MPI_Info_free(&(fd->info));
+ fn_exit:
+    MPI_Allreduce(error_code, &max_error_code, 1, MPI_INT, MPI_MAX, comm);
+    if (max_error_code != MPI_SUCCESS) {
+
+        /* If the file was successfully opened, close it */
+        if (*error_code == MPI_SUCCESS) {
+        
+            /* in the deferred open case, only those who have actually
+               opened the file should close it */
+            if (fd->hints->deferred_open && 
+                ADIOI_Uses_generic_read(fd) &&
+                ADIOI_Uses_generic_write(fd) ) {
+                if (fd->agg_comm != MPI_COMM_NULL) {
+                    (*(fd->fns->ADIOI_xxx_Close))(fd, error_code);
+                }
+            }
+            else {
+                (*(fd->fns->ADIOI_xxx_Close))(fd, error_code);
+            }
+        }
+
+	if (fd->fns) ADIOI_Free(fd->fns);
+	if (fd->filename) free(fd->filename);
+	if (fd->info != MPI_INFO_NULL) MPI_Info_free(&(fd->info));
 	ADIOI_Free(fd);
 	fd = ADIO_FILE_NULL;
+	if (*error_code == MPI_SUCCESS)
+	{
+#ifdef MPICH2
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**oremote_fail", 0);
+#elif defined(PRINT_ERR_MSG)
+	    *error_code = MPI_ERR_UNKNOWN;
+#else
+	    *error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR, myname,
+		"Open Error", "%s", 
+		"Open failed on a remote node");
+	    ADIOI_Error(MPI_FILE_NULL, *error_code, myname);
+#endif
+	}
     }
 
     return fd;
 }
 
 /* a simple linear search. possible enancement: add a my_cb_nodes_index member
  * ( index into cb_nodes, else -1 if not aggregator ) for faster lookups 
  *
@@ -265,10 +293,8 @@
         int i;
         
         for (i=0; i< fd->hints->cb_nodes; i++ ) {
                 if ( rank == fd->hints->ranklist[i] )
                         return 1;
         }
         return 0;
 }
-
-
Index: romio/adio/common/ad_write_str.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/common/ad_write_str.c,v
retrieving revision 1.11
retrieving revision 1.12
--- romio/adio/common/ad_write_str.c	26 Jul 2003 23:16:57 -0000	1.11
+++ romio/adio/common/ad_write_str.c	16 Dec 2003 21:51:22 -0000	1.12
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_write_str.c,v 1.11 2003/07/26 23:16:57 David Exp $    
+ *   $Id: ad_write_str.c,v 1.12 2003/12/16 21:51:22 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "adio.h"
 #include "adio_extern.h"
 
@@ -96,16 +96,31 @@
     int buf_count, buftype_is_contig, filetype_is_contig;
     ADIO_Offset userbuf_off;
     ADIO_Offset off, req_off, disp, end_offset=0, writebuf_off, start_off;
     char *writebuf;
     int flag, st_fwr_size, st_n_filetypes, writebuf_len, write_sz;
     ADIO_Status status1;
     int new_bwr_size, new_fwr_size, max_bufsize;
 
+    if (fd->hints->ds_write == ADIOI_HINT_DISABLE) {
+    	/* if user has disabled data sieving on reads, use naive
+	 * approach instead.
+	 */
+	ADIOI_GEN_WriteStrided_naive(fd, 
+				    buf,
+				    count,
+				    datatype,
+				    file_ptr_type,
+				    offset,
+				    status,
+				    error_code);
+    	return;
+    }
+
     *error_code = MPI_SUCCESS;  /* changed below if error */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fd->filetype, &filetype_is_contig);
 
     MPI_Type_size(fd->filetype, &filetype_size);
     if ( ! filetype_size ) {
 	*error_code = MPI_SUCCESS; 
Index: romio/adio/common/ad_write_str_naive.c
===================================================================
RCS file: romio/adio/common/ad_write_str_naive.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ romio/adio/common/ad_write_str_naive.c	16 Dec 2003 21:51:23 -0000	1.1
@@ -0,0 +1,375 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_write_str_naive.c,v 1.1 2003/12/16 21:51:23 robl Exp $
+ *
+ *   Copyright (C) 2001 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "adio.h"
+#include "adio_extern.h"
+
+void ADIOI_GEN_WriteStrided_naive(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype buftype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code)
+{
+    /* offset is in units of etype relative to the filetype. */
+
+    ADIOI_Flatlist_node *flat_buf, *flat_file;
+    /* bwr == buffer write; fwr == file write */
+    int bwr_size, fwr_size=0, b_index;
+    int bufsize, size, sum, n_etypes_in_filetype, size_in_filetype;
+    int n_filetypes, etype_in_filetype;
+    ADIO_Offset abs_off_in_filetype=0;
+    int filetype_size, etype_size, buftype_size, req_len;
+    MPI_Aint filetype_extent, buftype_extent; 
+    int buf_count, buftype_is_contig, filetype_is_contig;
+    ADIO_Offset userbuf_off;
+    ADIO_Offset off, req_off, disp, end_offset=0, start_off;
+    ADIO_Status status1;
+
+    *error_code = MPI_SUCCESS;  /* changed below if error */
+
+    ADIOI_Datatype_iscontig(buftype, &buftype_is_contig);
+    ADIOI_Datatype_iscontig(fd->filetype, &filetype_is_contig);
+
+    MPI_Type_size(fd->filetype, &filetype_size);
+    if ( ! filetype_size ) {
+	*error_code = MPI_SUCCESS; 
+	return;
+    }
+
+    MPI_Type_extent(fd->filetype, &filetype_extent);
+    MPI_Type_size(buftype, &buftype_size);
+    MPI_Type_extent(buftype, &buftype_extent);
+    etype_size = fd->etype_size;
+
+    bufsize = buftype_size * count;
+
+    /* contiguous in buftype and filetype is handled elsewhere */
+
+    if (!buftype_is_contig && filetype_is_contig) {
+    	int b_count;
+	/* noncontiguous in memory, contiguous in file. */
+
+	ADIOI_Flatten_datatype(buftype);
+	flat_buf = ADIOI_Flatlist;
+	while (flat_buf->type != buftype) flat_buf = flat_buf->next;
+
+        off = (file_ptr_type == ADIO_INDIVIDUAL) ? fd->fp_ind : 
+              fd->disp + etype_size * offset;
+
+	start_off = off;
+	end_offset = off + bufsize - 1;
+
+	/* if atomicity is true, lock (exclusive) the region to be accessed */
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_WRITE_LOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+	/* for each region in the buffer, grab the data and put it in
+	 * place
+	 */
+        for (b_count=0; b_count < count; b_count++) {
+            for (b_index=0; b_index < flat_buf->count; b_index++) {
+                userbuf_off = b_count*buftype_extent + 
+		              flat_buf->indices[b_index];
+		req_off = off;
+		req_len = flat_buf->blocklens[b_index];
+
+		ADIO_WriteContig(fd, 
+				(char *) buf + userbuf_off,
+				req_len, 
+				MPI_BYTE, 
+		    		ADIO_EXPLICIT_OFFSET,
+				req_off,
+				&status1,
+				error_code);
+		if (*error_code != MPI_SUCCESS) return;
+
+		/* off is (potentially) used to save the final offset later */
+                off += flat_buf->blocklens[b_index];
+            }
+	}
+
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_UNLOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+        if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind = off;
+
+    }
+
+    else {  /* noncontiguous in file */
+    	int f_index, st_fwr_size, st_index = 0, st_n_filetypes;
+	int flag;
+
+        /* First we're going to calculate a set of values for use in all
+	 * the noncontiguous in file cases:
+	 * start_off - starting byte position of data in file
+	 * end_offset - last byte offset to be acessed in the file
+	 * st_n_filetypes - how far into the file we start in terms of
+	 *                  whole filetypes
+	 * st_index - index of block in first filetype that we will be
+	 *            starting in (?)
+	 * st_fwr_size - size of the data in the first filetype block
+	 *               that we will write (accounts for being part-way
+	 *               into writing this block of the filetype
+	 *
+	 */
+
+	/* filetype already flattened in ADIO_Open */
+	flat_file = ADIOI_Flatlist;
+	while (flat_file->type != fd->filetype) flat_file = flat_file->next;
+	disp = fd->disp;
+
+	if (file_ptr_type == ADIO_INDIVIDUAL) {
+	    start_off = fd->fp_ind; /* in bytes */
+	    n_filetypes = -1;
+	    flag = 0;
+	    while (!flag) {
+                n_filetypes++;
+		for (f_index=0; f_index < flat_file->count; f_index++) {
+		    if (disp + flat_file->indices[f_index] + 
+                       (ADIO_Offset) n_filetypes*filetype_extent + 
+		       flat_file->blocklens[f_index] >= start_off) 
+		    {
+		    	/* this block contains our starting position */
+
+			st_index = f_index;
+			fwr_size = (int) (disp + flat_file->indices[f_index] + 
+		 	           (ADIO_Offset) n_filetypes*filetype_extent + 
+				   flat_file->blocklens[f_index] - start_off);
+			flag = 1;
+			break;
+		    }
+		}
+	    }
+	}
+	else {
+	    n_etypes_in_filetype = filetype_size/etype_size;
+	    n_filetypes = (int) (offset / n_etypes_in_filetype);
+	    etype_in_filetype = (int) (offset % n_etypes_in_filetype);
+	    size_in_filetype = etype_in_filetype * etype_size;
+ 
+	    sum = 0;
+	    for (f_index=0; f_index < flat_file->count; f_index++) {
+		sum += flat_file->blocklens[f_index];
+		if (sum > size_in_filetype) {
+		    st_index = f_index;
+		    fwr_size = sum - size_in_filetype;
+		    abs_off_in_filetype = flat_file->indices[f_index] +
+			                  size_in_filetype - 
+			                  (sum - flat_file->blocklens[f_index]);
+		    break;
+		}
+	    }
+
+	    /* abs. offset in bytes in the file */
+	    start_off = disp + (ADIO_Offset) n_filetypes*filetype_extent + 
+	    	        abs_off_in_filetype;
+	}
+
+	st_fwr_size = fwr_size;
+	st_n_filetypes = n_filetypes;
+
+	/* start_off, st_n_filetypes, st_index, and st_fwr_size are 
+	 * all calculated at this point
+	 */
+
+        /* Calculate end_offset, the last byte-offset that will be accessed.
+         * e.g., if start_off=0 and 100 bytes to be written, end_offset=99
+	 */
+	userbuf_off = 0;
+	f_index = st_index;
+	off = start_off;
+	fwr_size = ADIOI_MIN(st_fwr_size, bufsize);
+	while (userbuf_off < bufsize) {
+	    userbuf_off += fwr_size;
+	    end_offset = off + fwr_size - 1;
+
+	    if (f_index < (flat_file->count - 1)) f_index++;
+	    else {
+		f_index = 0;
+		n_filetypes++;
+	    }
+
+	    off = disp + flat_file->indices[f_index] + 
+	          (ADIO_Offset) n_filetypes*filetype_extent;
+	    fwr_size = ADIOI_MIN(flat_file->blocklens[f_index], 
+	                         bufsize-(int)userbuf_off);
+	}
+
+	/* End of calculations.  At this point the following values have
+	 * been calculated and are ready for use:
+	 * - start_off
+	 * - end_offset
+	 * - st_n_filetypes
+	 * - st_index
+	 * - st_fwr_size
+	 */
+
+	/* if atomicity is true, lock (exclusive) the region to be accessed */
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_WRITE_LOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+	if (buftype_is_contig && !filetype_is_contig) {
+	    /* contiguous in memory, noncontiguous in file. should be the
+	     * most common case.
+	     */
+
+	    userbuf_off = 0;
+	    f_index = st_index;
+	    off = start_off;
+	    n_filetypes = st_n_filetypes;
+	    fwr_size = ADIOI_MIN(st_fwr_size, bufsize);
+
+	    /* while there is still space in the buffer, write more data */
+	    while (userbuf_off < bufsize) {
+                if (fwr_size) { 
+                    /* TYPE_UB and TYPE_LB can result in 
+                       fwr_size = 0. save system call in such cases */ 
+		    req_off = off;
+		    req_len = fwr_size;
+
+		    ADIO_WriteContig(fd, 
+				    (char *) buf + userbuf_off,
+				    req_len, 
+				    MPI_BYTE, 
+				    ADIO_EXPLICIT_OFFSET,
+				    req_off,
+				    &status1,
+				    error_code);
+		    if (*error_code != MPI_SUCCESS) return;
+		}
+		userbuf_off += fwr_size;
+
+                if (off + fwr_size < disp + flat_file->indices[f_index] +
+                   flat_file->blocklens[f_index] + 
+		   (ADIO_Offset) n_filetypes*filetype_extent)
+		{
+		    /* important that this value be correct, as it is
+		     * used to set the offset in the fd near the end of
+		     * this function.
+		     */
+                    off += fwr_size;
+		}
+                /* did not reach end of contiguous block in filetype.
+                 * no more I/O needed. off is incremented by fwr_size.
+		 */
+                else {
+		    if (f_index < (flat_file->count - 1)) f_index++;
+		    else {
+			f_index = 0;
+			n_filetypes++;
+		    }
+		    off = disp + flat_file->indices[f_index] + 
+                          (ADIO_Offset) n_filetypes*filetype_extent;
+		    fwr_size = ADIOI_MIN(flat_file->blocklens[f_index], 
+		                         bufsize-(int)userbuf_off);
+		}
+	    }
+	}
+	else {
+	    int i, tmp_bufsize = 0;
+	    /* noncontiguous in memory as well as in file */
+
+	    ADIOI_Flatten_datatype(buftype);
+	    flat_buf = ADIOI_Flatlist;
+	    while (flat_buf->type != buftype) flat_buf = flat_buf->next;
+
+	    b_index = buf_count = 0;
+	    i = (int) (flat_buf->indices[0]);
+	    f_index = st_index;
+	    off = start_off;
+	    n_filetypes = st_n_filetypes;
+	    fwr_size = st_fwr_size;
+	    bwr_size = flat_buf->blocklens[0];
+
+	    /* while we haven't read size * count bytes, keep going */
+	    while (tmp_bufsize < bufsize) {
+    		int new_bwr_size = bwr_size, new_fwr_size = fwr_size;
+
+		size = ADIOI_MIN(fwr_size, bwr_size);
+		if (size) {
+		    req_off = off;
+		    req_len = size;
+		    userbuf_off = i;
+
+		    ADIO_WriteContig(fd, 
+				    (char *) buf + userbuf_off,
+				    req_len, 
+				    MPI_BYTE, 
+				    ADIO_EXPLICIT_OFFSET,
+				    req_off,
+				    &status1,
+				    error_code);
+		    if (*error_code != MPI_SUCCESS) return;
+		}
+
+		if (size == fwr_size) {
+		    /* reached end of contiguous block in file */
+		    if (f_index < (flat_file->count - 1)) f_index++;
+		    else {
+			f_index = 0;
+			n_filetypes++;
+		    }
+
+		    off = disp + flat_file->indices[f_index] + 
+                          (ADIO_Offset) n_filetypes*filetype_extent;
+
+		    new_fwr_size = flat_file->blocklens[f_index];
+		    if (size != bwr_size) {
+			i += size;
+			new_bwr_size -= size;
+		    }
+		}
+
+		if (size == bwr_size) {
+		    /* reached end of contiguous block in memory */
+
+		    b_index = (b_index + 1)%flat_buf->count;
+		    buf_count++;
+		    i = (int) (buftype_extent*(buf_count/flat_buf->count) +
+			flat_buf->indices[b_index]);
+		    new_bwr_size = flat_buf->blocklens[b_index];
+		    if (size != fwr_size) {
+			off += size;
+			new_fwr_size -= size;
+		    }
+		}
+		tmp_bufsize += size;
+		fwr_size = new_fwr_size;
+                bwr_size = new_bwr_size;
+	    }
+	}
+
+	/* unlock the file region if we locked it */
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_UNLOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+	if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind = off;
+    } /* end of (else noncontiguous in file) */
+
+    fd->fp_sys_posn = -1;   /* mark it as invalid. */
+
+#ifdef HAVE_STATUS_SET_BYTES
+    MPIR_Status_set_bytes(status, buftype, bufsize);
+    /* This is a temporary way of filling in status. The right way is to 
+     * keep track of how much data was actually written and placed in buf 
+     */
+#endif
+
+    if (!buftype_is_contig) ADIOI_Delete_flattened(buftype);
+}
Index: romio/adio/common/flatten.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/common/flatten.c,v
retrieving revision 1.12
retrieving revision 1.14
--- romio/adio/common/flatten.c	4 Sep 2003 21:35:29 -0000	1.12
+++ romio/adio/common/flatten.c	19 Feb 2004 16:24:02 -0000	1.14
@@ -1,46 +1,72 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: flatten.c,v 1.12 2003/09/04 21:35:29 rross Exp $    
+ *   $Id: flatten.c,v 1.14 2004/02/19 16:24:02 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "adio.h"
 #include "adio_extern.h"
 #ifdef MPISGI
 #include "mpisgi2.h"
 #endif
 
-#if 0
-#define HAVE_MPIR_TYPE_FLATTEN 1
-#define HAVE_MPIR_TYPE_GET_CONTIG_BLOCKS 1
-#endif
-
-#undef HAVE_MPI_COMBINER_DUP
-#undef HAVE_MPI_COMBINER_SUBARRAY
-
 void ADIOI_Optimize_flattened(ADIOI_Flatlist_node *flat_type);
 void ADIOI_Flatten_subarray(int ndims,
 			    int *array_of_sizes,
 			    int *array_of_subsizes,
 			    int *array_of_starts,
 			    int order,
 			    MPI_Datatype oldtype,
 			    ADIOI_Flatlist_node *flat,
 			    ADIO_Offset start_offset,
 			    int *inout_index_p);
+void ADIOI_Flatten_darray(int size,
+			  int rank,
+			  int ndims,
+			  int array_of_gsizes[],
+			  int array_of_distribs[],
+			  int array_of_dargs[],
+			  int array_of_psizes[],
+			  int order,
+			  MPI_Datatype oldtype,
+			  ADIOI_Flatlist_node *flat,
+			  ADIO_Offset start_offset,
+			  int *inout_index_p);
 void ADIOI_Flatten_copy_type(ADIOI_Flatlist_node *flat,
 			     int old_type_start,
 			     int old_type_end,
 			     int new_type_start,
 			     ADIO_Offset offset_adjustment);
 
+/* darray helper functions */
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+static int index_of_type(int type_nr,
+			 int dim_size,
+			 int dim_rank,
+			 int dim_ranks,
+			 int k);
+static int get_cyclic_k(int dim_size,
+			int dim_ranks,
+			int dist,
+			int d_arg);
+static void get_darray_position(int rank,
+				int ranks,
+				int ndims,
+				int array_of_psizes[],
+				int r[]);
+static int local_types_in_dim(int dim_size,
+			      int dim_rank,
+			      int dim_ranks,
+			      int k);
+#endif
+
 /* flatten datatype and add it to Flatlist */
 void ADIOI_Flatten_datatype(MPI_Datatype datatype)
 {
 #ifdef HAVE_MPIR_TYPE_FLATTEN
     MPI_Aint flatten_idx;
 #endif
     int curr_index=0, is_contig;
     ADIOI_Flatlist_node *flat, *prev=0;
@@ -99,17 +125,17 @@
     {
 	int i;
 	FPRINTF(stderr, "blens: ");
 	for (i=0; i<flat->count; i++) 
 	    FPRINTF(stderr, "%d ", flat->blocklens[i]);
 	FPRINTF(stderr, "\n\n");
 	FPRINTF(stderr, "indices: ");
 	for (i=0; i<flat->count; i++) 
-	    FPRINTF(stderr, "%ld ", flat->indices[i]);
+	    FPRINTF(stderr, "%ld ", (long) flat->indices[i]);
 	FPRINTF(stderr, "\n\n");
     }
 #endif
 
 }
 
 /* ADIOI_Flatten()
  *
@@ -128,42 +154,61 @@
 
     MPI_Type_get_envelope(datatype, &nints, &nadds, &ntypes, &combiner);
     ints = (int *) ADIOI_Malloc((nints+1)*sizeof(int));
     adds = (MPI_Aint *) ADIOI_Malloc((nadds+1)*sizeof(MPI_Aint));
     types = (MPI_Datatype *) ADIOI_Malloc((ntypes+1)*sizeof(MPI_Datatype));
     MPI_Type_get_contents(datatype, nints, nadds, ntypes, ints, adds, types);
 
     switch (combiner) {
-#ifdef HAVE_MPI_COMBINER_DUP
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DUP
     case MPI_COMBINER_DUP:
         MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
 			      &old_ntypes, &old_combiner); 
         ADIOI_Datatype_iscontig(types[0], &old_is_contig);
 	if ((old_combiner != MPI_COMBINER_NAMED) && (!old_is_contig))
             ADIOI_Flatten(types[0], flat, st_offset, curr_index);
         break;
 #endif
-#ifdef HAVE_MPI_COMBINER_SUBARRAY
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_SUBARRAY
     case MPI_COMBINER_SUBARRAY:
 	{
 	    int dims = ints[0];
 	    ADIOI_Flatten_subarray(dims,
 				   &ints[1],        /* sizes */
 				   &ints[dims+1],   /* subsizes */
 				   &ints[2*dims+1], /* starts */
 				   ints[3*dims+1],  /* order */
 				   types[0],        /* type */
 				   flat,
 				   st_offset,
 				   curr_index);
 				   
 	}
 	break;
 #endif
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+    case MPI_COMBINER_DARRAY:
+	{
+	    int dims = ints[2];
+	    ADIOI_Flatten_darray(ints[0],         /* size */
+				 ints[1],         /* rank */
+				 dims,
+				 &ints[3],        /* gsizes */
+				 &ints[dims+3],   /* distribs */
+				 &ints[2*dims+3], /* dargs */
+				 &ints[3*dims+3], /* psizes */
+				 ints[4*dims+3],  /* order */
+				 types[0],
+				 flat,
+				 st_offset,
+				 curr_index);
+	}
+	break;
+#endif
     case MPI_COMBINER_CONTIGUOUS:
 	top_count = ints[0];
         MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
 			      &old_ntypes, &old_combiner); 
         ADIOI_Datatype_iscontig(types[0], &old_is_contig);
 
 	prev_index = *curr_index;
 	if ((old_combiner != MPI_COMBINER_NAMED) && (!old_is_contig))
@@ -480,21 +525,18 @@
 #endif
 
     ADIOI_Free(ints);
     ADIOI_Free(adds);
     ADIOI_Free(types);
 
 }
 
-
 /********************************************************/
 
-
-
 /* ADIOI_Count_contiguous_blocks
  *
  * Returns number of contiguous blocks in type, and also saves this value in
  * curr_index.
  *
  * ASSUMES THAT TYPE IS NOT A BASIC!!!
  */
 int ADIOI_Count_contiguous_blocks(MPI_Datatype datatype, int *curr_index)
@@ -515,27 +557,27 @@
 
     MPI_Type_get_envelope(datatype, &nints, &nadds, &ntypes, &combiner);
     ints = (int *) ADIOI_Malloc((nints+1)*sizeof(int));
     adds = (MPI_Aint *) ADIOI_Malloc((nadds+1)*sizeof(MPI_Aint));
     types = (MPI_Datatype *) ADIOI_Malloc((ntypes+1)*sizeof(MPI_Datatype));
     MPI_Type_get_contents(datatype, nints, nadds, ntypes, ints, adds, types);
 
     switch (combiner) {
-#ifdef HAVE_MPI_COMBINER_DUP
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DUP
     case MPI_COMBINER_DUP:
         MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
                               &old_ntypes, &old_combiner); 
 	ADIOI_Datatype_iscontig(types[0], &old_is_contig);
 	if ((old_combiner != MPI_COMBINER_NAMED) && (!old_is_contig))
 	    count = ADIOI_Count_contiguous_blocks(types[0], curr_index);
 	else count = 1;
         break;
 #endif
-#ifdef HAVE_MPI_COMBINER_SUBARRAY
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_SUBARRAY
     case MPI_COMBINER_SUBARRAY:
 	/* first get an upper bound (since we're not optimizing) on the
 	 * number of blocks in the child type.
 	 */
 	MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
 			      &old_ntypes, &old_combiner);
 	ADIOI_Datatype_iscontig(types[0], &old_is_contig);
 	if ((old_combiner != MPI_COMBINER_NAMED) && (!old_is_contig))
@@ -553,16 +595,53 @@
 	 */
 	n = 1; /* going to tally up # of types in here */
 	for (i=0; i < ints[0]; i++) {
 	    n *= ints[ints[0]+1+i];
 	}
 	count *= n;
 	break;	    
 #endif
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+    case MPI_COMBINER_DARRAY:
+	{
+	    int dims, k, *ranks;
+
+	    MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
+				  &old_ntypes, &old_combiner);
+	    ADIOI_Datatype_iscontig(types[0], &old_is_contig);
+	    if ((old_combiner != MPI_COMBINER_NAMED) && (!old_is_contig))
+		count = ADIOI_Count_contiguous_blocks(types[0], curr_index);
+	    else count = 1;
+	    
+	    n = 1;
+	    dims = ints[2];
+	    ranks = ADIOI_Malloc(sizeof(int) * dims);
+	    get_darray_position(ints[1],         /* rank */
+				ints[0],         /* size */
+				dims,
+				&ints[3*dims+3], /* psizes */
+				ranks);
+
+	    for (i=0; i < dims; i++) {
+		k = get_cyclic_k(ints[3+i],         /* gsize */
+				 ints[3*dims+3+i],  /* psize */
+				 ints[dims+3+i],    /* distrib */
+				 ints[2*dims+3+i]); /* darg */
+
+		n *= local_types_in_dim(ints[3+i],        /* gsize */
+					ranks[i],         /* dim rank */
+					ints[3*dims+3+i], /* psize */
+					k);
+	    }
+	    ADIOI_Free(ranks);
+	    count *= n;
+	}
+	break;
+#endif
     case MPI_COMBINER_CONTIGUOUS:
         top_count = ints[0];
         MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
                               &old_ntypes, &old_combiner); 
 	ADIOI_Datatype_iscontig(types[0], &old_is_contig);
 
 	prev_index = *curr_index;
 	if ((old_combiner != MPI_COMBINER_NAMED) && (!old_is_contig))
@@ -767,17 +846,17 @@
 	if (flat->blocklens) ADIOI_Free(flat->blocklens);
 	if (flat->indices) ADIOI_Free(flat->indices);
 	ADIOI_Free(flat);
     }
 }
 
 /****************************************************************/
 
-#ifdef HAVE_MPI_COMBINER_SUBARRAY
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_SUBARRAY
 /* ADIOI_Flatten_subarray()
  *
  * ndims - number of dimensions in the array
  * array_of_sizes - dimensions of the array (one value per dim)
  * array_of_subsizes - dimensions of the subarray (one value per dim)
  * array_of_starts - starting offsets of the subarray (one value per dim)
  * order - MPI_ORDER_FORTRAN or MPI_ORDER_C
  * oldtype - type on which this subarray as built
@@ -792,20 +871,21 @@
 			    int *array_of_subsizes,
 			    int *array_of_starts,
 			    int order,
 			    MPI_Datatype oldtype,
 			    ADIOI_Flatlist_node *flat,
 			    ADIO_Offset start_offset,
 			    int *inout_index_p)
 {
-    int i, j, oldtype_extent, total_types, *dim_sz, flatten_start_offset,
+    int i, j, total_types, *dim_sz, flatten_start_offset,
 	flatten_end_offset;
     int old_nints, old_nadds, old_ntypes, old_combiner;
     ADIO_Offset subarray_start_offset, type_offset, *dim_skipbytes;
+    MPI_Aint oldtype_extent;
 
     MPI_Type_extent(oldtype, &oldtype_extent);
 
     /* TODO: optimization for 1-dimensional types -- treat like a contig */
 
     /* general case - make lots of copies of the offsets, adjusting 
      * the indices as necessary.
      */
@@ -955,8 +1035,324 @@
     int i, out_index = new_type_start;
 
     for (i=old_type_start; i < old_type_end; i++) {
 	flat->indices[out_index]   = flat->indices[i] + offset_adjustment;
 	flat->blocklens[out_index] = flat->blocklens[i];
 	out_index++;
     }
 }
+
+/****************************************************************/
+
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+/* ADIOI_Flatten_darray()
+ *
+ * size - number of processes across which darray is defined
+ * rank - our rank in the group of processes
+ * ndims - number of dimensions of darray type
+ * gsizes - dimensions of the array in types (order varies)
+ * distribs - type of dist. for each dimension (order varies)
+ * dargs - argument to dist. for each dimension (order varies)
+ * psizes - number of processes across which each dimension
+ *          is split (always C order)
+ * order - order of parameters (c or fortran)
+ * oldtype - type on which this darray is built
+ * flat - ...
+ * start_offset - offset of this type to begin with
+ * inout_index_p - count of indices already used on input, updated
+ *                 for output
+ *
+ * The general approach is to convert everything into cyclic-k and process
+ * it from there.
+ */
+void ADIOI_Flatten_darray(int size,
+			  int rank,
+			  int ndims,
+			  int array_of_gsizes[],
+			  int array_of_distribs[],
+			  int array_of_dargs[],
+			  int array_of_psizes[],
+			  int order,
+			  MPI_Datatype oldtype,
+			  ADIOI_Flatlist_node *flat,
+			  ADIO_Offset start_offset,
+			  int *inout_index_p)
+{
+    int i, j, total_types, flatten_start_offset,
+	flatten_end_offset, oldtype_nints, oldtype_nadds, oldtype_ntypes,
+	oldtype_combiner, *dim_ranks, *dim_ks, *dim_localtypes;
+    ADIO_Offset darray_start_offset, first_darray_offset;
+    MPI_Aint oldtype_extent, *dim_skipbytes;
+
+    MPI_Type_extent(oldtype, &oldtype_extent);
+
+    dim_localtypes = ADIOI_Malloc(sizeof(int) * ndims);
+    dim_skipbytes = ADIOI_Malloc(sizeof(MPI_Aint) * ndims);
+    dim_ranks = (int *) ADIOI_Malloc(sizeof(int) * ndims);
+    dim_ks = (int *) ADIOI_Malloc(sizeof(int) * ndims);
+
+    /* fill in dim_ranks, C order (just like psizes) */
+    get_darray_position(rank, size, ndims, array_of_psizes, dim_ranks);
+
+    /* calculate all k values; store in same order as arrays */
+    for (i=0; i < ndims; i++) {
+	dim_ks[i] = get_cyclic_k(array_of_gsizes[i],
+				 array_of_psizes[i],
+				 array_of_distribs[i],
+				 array_of_dargs[i]);
+    }
+
+    /* calculate total number of oldtypes in this type */
+    total_types = 1;
+    for (i=0; i < ndims; i++) {
+	total_types *= local_types_in_dim(array_of_gsizes[i],
+					  dim_ranks[i],
+					  array_of_psizes[i],
+					  dim_ks[i]);
+    }
+
+    /* fill in temporary values; these are just cached so we aren't
+     * calculating them for every type instance.
+     *
+     * dim_localtypes holds the # of types this process has in the given
+     * dimension.
+     *
+     * dim_skipbytes (in this function) is going to hold the distance
+     * to skip to move from one type to the next in that dimension, in
+     * bytes, in terms of the darray as a whole.  sort of like the stride
+     * for a vector.
+     * 
+     * we keep this stuff in row-major (C) order -- least-frequently changing
+     * first.
+     */
+    for (i=0; i < ndims; i++) {
+	int idx = (order == MPI_ORDER_C) ? i : ndims-1-i;
+
+	dim_localtypes[i] = local_types_in_dim(array_of_gsizes[idx],
+					       dim_ranks[idx],
+					       array_of_psizes[idx],
+					       dim_ks[idx]);
+    }
+
+    dim_skipbytes[ndims-1] = oldtype_extent;
+    for (i=ndims-2; i >= 0; i--) {
+	int idx = (order == MPI_ORDER_C) ? i+1 : ndims-2-i;
+
+	dim_skipbytes[i] = array_of_gsizes[idx] * dim_skipbytes[i+1];
+    }
+
+#if 0
+    for (i=0; i < ndims; i++) {
+	MPIU_dbg_printf("dim_skipbytes[%d] = %d, dim_localtypes[%d] = %d\n",
+			i, (int) dim_skipbytes[i], i, dim_localtypes[i]);
+    }
+#endif
+
+
+    /* determine starting offset */
+    darray_start_offset = start_offset;
+    first_darray_offset = 0;
+    for (i=0; i < ndims; i++) {
+	ADIO_Offset this_dim_off;
+	int idx = (order == MPI_ORDER_C) ? i : ndims-1-i;
+
+	this_dim_off = index_of_type(0,
+				     array_of_gsizes[idx],
+				     dim_ranks[i],
+				     array_of_psizes[i],
+				     dim_ks[idx]);
+
+	this_dim_off *= (ADIO_Offset) dim_skipbytes[i];
+	darray_start_offset += this_dim_off;
+	first_darray_offset += this_dim_off;
+    }
+    
+    /* flatten one of the type to get the offsets that we need;
+     * we need an accurate starting offset to do this in-place.
+     *
+     * we save the starting offset so we can adjust when copying
+     * later on.
+     */
+    flatten_start_offset = *inout_index_p;
+    MPI_Type_get_envelope(oldtype,
+			  &oldtype_nints,
+			  &oldtype_nadds,
+			  &oldtype_ntypes,
+			  &oldtype_combiner);
+    if (oldtype_combiner != MPI_COMBINER_NAMED) {
+	ADIOI_Flatten(oldtype, flat, darray_start_offset, inout_index_p);
+    }
+    else {
+	int oldtype_size;
+
+	MPI_Type_size(oldtype, &oldtype_size);
+
+	flat->indices[flatten_start_offset]   = darray_start_offset;
+	flat->blocklens[flatten_start_offset] = oldtype_size;
+	(*inout_index_p)++;
+    }
+    flatten_end_offset = *inout_index_p;
+
+    /* now run through all the types, calculating the effective
+     * offset and then making a copy of the flattened regions for the
+     * type (and adjusting the offsets of them appropriately)
+     */
+    for (i=0; i < total_types; i++) {
+	int block_nr = i;
+	ADIO_Offset type_offset = 0;
+
+	for (j=ndims-1; j >= 0; j--) {
+	    ADIO_Offset dim_off;
+	    int idx = (order == MPI_ORDER_C) ? j : ndims-1-j;
+	    int dim_index = block_nr % dim_localtypes[j];
+
+	    dim_off = index_of_type(dim_index,
+				    array_of_gsizes[idx],
+				    dim_ranks[j],
+				    array_of_psizes[j],
+				    dim_ks[idx]);
+
+
+	    if (dim_off) type_offset += (ADIO_Offset) dim_off *
+			     (ADIO_Offset) dim_skipbytes[j];
+#if 0
+	    {
+		char s1[] = " ", s2[] = "  ", s3[] = "   ";
+		MPIU_dbg_printf("%sindex of type %d (pass %d,%d) is %d; new offset = %d\n",
+				(j == 0) ? s1 : ((j == 1) ? s2 : s3),
+				dim_index, i, j, (int) dim_off, (int) type_offset);
+	    }
+#endif
+	    block_nr /= dim_localtypes[j];
+	}
+
+	/* perform copy; noting in this case that the type offsets that
+	 * we are calculating here are relative to the beginning of the
+	 * darray as a whole, not relative to the first of our elements.
+	 *
+	 * because of that we have to subtract off the first_darray_offset
+	 * in order to get the right offset adjustment.
+	 */
+	ADIOI_Flatten_copy_type(flat,
+				flatten_start_offset,
+				flatten_end_offset,
+				flatten_start_offset + i * (flatten_end_offset - flatten_start_offset),
+				type_offset - first_darray_offset);
+    }
+    
+    /* free temp space */
+    ADIOI_Free(dim_skipbytes);
+    ADIOI_Free(dim_localtypes);
+    ADIOI_Free(dim_ranks);
+    ADIOI_Free(dim_ks);
+
+    *inout_index_p = flatten_start_offset + total_types *
+	(flatten_end_offset - flatten_start_offset);
+}
+
+/* darray processing helper functions */
+static int index_of_type(int type_nr,
+			 int dim_size,
+			 int dim_rank,
+			 int dim_ranks,
+			 int k)
+{
+    int cycle, leftover, index;
+
+    /* handle MPI_DISTRIBUTE_NONE case */
+    if (k == 0) return type_nr;
+
+    cycle = type_nr / k;
+    leftover = type_nr % k;
+
+    index = (dim_rank * k) + (dim_ranks * k * cycle) + leftover;
+
+    return index;
+}
+
+static int get_cyclic_k(int dim_size,
+			int dim_ranks,
+			int dist,
+			int d_arg)
+{
+    int k;
+
+    /* calculate correct "k" if DFLT_DARG passed in */
+    if (dist == MPI_DISTRIBUTE_NONE) return 0; /* indicates NONE */
+    else if (d_arg == MPI_DISTRIBUTE_DFLT_DARG) {
+	if (dist == MPI_DISTRIBUTE_BLOCK) {
+	    k = (dim_size + dim_ranks - 1) / dim_ranks;
+	}
+	else {
+	    k = 1;
+	}
+    }
+    else {
+	k = d_arg;
+    }
+
+    return k;
+}
+
+static int local_types_in_dim(int dim_size,
+			      int dim_rank,
+			      int dim_ranks,
+			      int k)
+{
+    int count, n_blocks, n_types, leftover;
+
+    if (k == 0) {
+	/* indicates MPI_DISTRIBUTE_NONE */
+	return dim_size;
+    }
+
+    /* blocks are regions of (up to k) types; this count
+     * includes partials
+     */
+    n_blocks = (dim_size + k - 1) / k;
+
+    /* count gets us a total # of blocks that the particular
+     * rank gets, including possibly a partial block
+     */
+    count = n_blocks / dim_ranks;
+    leftover = n_blocks - (count * dim_ranks);
+    if (dim_rank < leftover) count++;
+
+    n_types = count * k;
+
+    /* subtract off the types that are missing from the final
+     * partial block, if there is a partial and this rank is
+     * the one that has it.
+     */
+    if ((dim_rank == leftover - 1) && (dim_size % k != 0)) {
+	n_types -= k - (dim_size - ((dim_size / k) * k));
+    }
+
+    return n_types;
+}
+
+/* get_darray_position(rank, ranks, ndims, array_of_psizes, r[])
+ *
+ * Calculates the position of this process in the darray
+ * given the rank of the process passed to the darray create
+ * and the total number of processes also passed to the darray
+ * create.
+ *
+ * Assumes that the array (r[]) has already been allocated.
+ */
+static void get_darray_position(int rank,
+				int ranks,
+				int ndims,
+				int array_of_psizes[],
+				int r[])
+{
+    int i;
+    int t_rank = rank;
+    int t_size = ranks;
+
+    for (i = 0; i < ndims; i++) {
+	t_size = t_size / array_of_psizes[i];
+	r[i] = t_rank / t_size;
+	t_rank = t_rank % t_size;
+    }
+} 
+#endif
Index: romio/adio/common/lock.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/common/lock.c,v
retrieving revision 1.10
retrieving revision 1.11
--- romio/adio/common/lock.c	10 Dec 2003 22:44:12 -0000	1.10
+++ romio/adio/common/lock.c	26 May 2004 17:56:55 -0000	1.11
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: lock.c,v 1.10 2003/12/10 22:44:12 gropp Exp $    
+ *   $Id: lock.c,v 1.11 2004/05/26 17:56:55 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "adio.h"
 
 #ifdef ROMIO_NTFS
@@ -78,17 +78,17 @@
 
     do {
 	err = fcntl(fd, cmd, &lock);
     } while (err && (errno == EINTR));
 
     if (err && (errno != EBADF)) {
 	/* FIXME: This should use the error message system, 
 	   especially for MPICH2 */
-	FPRINTF(stderr, "File locking failed in ADIOI_Set_lock. If the file system is NFS, you need to use NFS version 3 and mount the directory with the 'noac' option (no attribute caching).\n");
+	FPRINTF(stderr, "File locking failed in ADIOI_Set_lock. If the file system is NFS, you need to use NFS version 3, ensure that the lockd daemon is running on all the machines, and mount the directory with the 'noac' option (no attribute caching).\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 
     error_code = (err == 0) ? MPI_SUCCESS : MPI_ERR_UNKNOWN;
     return error_code;
 }
 #endif
 
Index: romio/adio/include/adio.h
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/include/adio.h,v
retrieving revision 1.30
retrieving revision 1.35
--- romio/adio/include/adio.h	8 Sep 2003 13:35:43 -0000	1.30
+++ romio/adio/include/adio.h	7 Jun 2004 17:59:57 -0000	1.35
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: adio.h,v 1.30 2003/09/08 13:35:43 gropp Exp $    
+ *   $Id: adio.h,v 1.35 2004/06/07 17:59:57 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 /* main include file for ADIO.
    contains general definitions, declarations, and macros independent 
    of the underlying file system */
@@ -52,17 +52,22 @@
 #  define FORTRAN_API __declspec(dllexport)
 # else
 #  define FORTRAN_API __declspec(dllimport)
 # endif
 #else
 # define FORTRAN_API
 #endif
 
+/* Include romioconf.h if we haven't already (some include files may
+   need to include romioconf before some system includes) */
+#ifndef ROMIOCONF_H_INCLUDED
 #include "romioconf.h"
+#define ROMIOCONG_H_INCLUDED
+#endif
 
 #include "mpi.h"
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -175,17 +180,17 @@
     unsigned d_maxiosz;      /* max xfer size */
 #endif
     ADIO_Offset fp_ind;      /* individual file pointer in MPI-IO (in bytes)*/
     ADIO_Offset fp_sys_posn; /* current location of the system file-pointer
                                 in bytes */
     ADIOI_Fns *fns;          /* struct of I/O functions to use */
     MPI_Comm comm;           /* communicator indicating who called open */
     MPI_Comm agg_comm;      /* deferred open: aggregators who called open */
-    int io_worker;	    /* if one proc should do io, should it be me? */
+    int io_worker;	    /* bool: if one proc should do io, is it me? */
     int is_open;		/* deferred open: 0: not open yet 1: is open */
     char *filename;          
     int file_system;         /* type of file system */
     int access_mode;         /* Access mode (sequential, append, etc.) */
     ADIO_Offset disp;        /* reqd. for MPI-IO */
     MPI_Datatype etype;      /* reqd. for MPI-IO */
     MPI_Datatype filetype;   /* reqd. for MPI-IO */
     int etype_size;          /* in bytes */
@@ -387,13 +392,14 @@
 /* Copied from mpiimpl.h because mpiimpl.h cannot be included from romio. */
 /* Remove these prototypes when mpiimpl.h is broken up and a specific error */
 /* handling header file can be included. */
 #define MPIR_ERR_FATAL 1
 #define MPIR_ERR_RECOVERABLE 0
 int MPIR_Err_return_file( MPI_File file_ptr, const char fcname[], int errcode );
 int MPIR_Err_create_code( int, int, const char [], int, int, const char [], const char [], ... );
 int MPIR_Err_is_fatal(int);
-void MPIR_Err_get_string(int, char *);
+typedef int (* MPIR_Err_get_class_string_func_t)(int error, char *str, int length);
+void MPIR_Err_get_string(int, char *, int, MPIR_Err_get_class_string_func_t );
 void MPIR_Err_print_stack(FILE *, int);
 extern int MPIR_Err_print_stack_flag;
 
 #endif
Index: romio/adio/include/adioi.h
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/include/adioi.h,v
retrieving revision 1.21
retrieving revision 1.22
--- romio/adio/include/adioi.h	4 Dec 2003 22:20:06 -0000	1.21
+++ romio/adio/include/adioi.h	17 Dec 2003 16:49:52 -0000	1.22
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: adioi.h,v 1.21 2003/12/04 22:20:06 robl Exp $    
+ *   $Id: adioi.h,v 1.22 2003/12/17 16:49:52 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 
 /* contains general definitions, declarations, and macros internal to
    the ADIO implementation, though independent of the underlying file
@@ -299,16 +299,20 @@
 void ADIOI_GEN_ReadStrided_naive(ADIO_File fd, void *buf, int count,
                        MPI_Datatype buftype, int file_ptr_type,
                        ADIO_Offset offset, ADIO_Status *status, int
                        *error_code);
 void ADIOI_GEN_WriteStrided(ADIO_File fd, void *buf, int count,
                        MPI_Datatype datatype, int file_ptr_type,
                        ADIO_Offset offset, ADIO_Status *status, int
                        *error_code);
+void ADIOI_GEN_WriteStrided_naive(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code);
 void ADIOI_GEN_ReadStridedColl(ADIO_File fd, void *buf, int count,
                        MPI_Datatype datatype, int file_ptr_type,
                        ADIO_Offset offset, ADIO_Status *status, int
                        *error_code);
 void ADIOI_GEN_WriteStridedColl(ADIO_File fd, void *buf, int count,
                        MPI_Datatype datatype, int file_ptr_type,
                        ADIO_Offset offset, ADIO_Status *status, int
                        *error_code);
Index: romio/adio/include/mpipr.h
===================================================================
RCS file: /home/MPI/cvsMaster/romio/adio/include/mpipr.h,v
retrieving revision 1.8
retrieving revision 1.9
--- romio/adio/include/mpipr.h	8 Sep 2003 13:36:43 -0000	1.8
+++ romio/adio/include/mpipr.h	8 Jan 2004 22:41:54 -0000	1.9
@@ -1,10 +1,10 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
-/*  $Id: mpipr.h,v 1.8 2003/09/08 13:36:43 gropp Exp $
+/*  $Id: mpipr.h,v 1.9 2004/01/08 22:41:54 gropp Exp $
  *
  *  (C) 2001 by Argonne National Laboratory.
  *      See COPYRIGHT in top-level directory.
  */
 /* This file replaces all MPI function names with their PMPI equivalents.
    PMPI versions are used by default so that the user can profile 
    application code without interference from MPI functions used by 
    MPI-IO. */
@@ -144,16 +144,17 @@
 #undef MPI_Group_size
 #define MPI_Group_size PMPI_Group_size
 #undef MPI_Group_translate_ranks
 #define MPI_Group_translate_ranks PMPI_Group_translate_ranks
 #undef MPI_Group_union
 #define MPI_Group_union PMPI_Group_union
 #undef MPI_Ibsend
 #define MPI_Ibsend PMPI_Ibsend
+#if 0
 #undef MPI_Info_create
 #define MPI_Info_create PMPI_Info_create
 #undef MPI_Info_delete
 #define MPI_Info_delete PMPI_Info_delete
 #undef MPI_Info_dup
 #define MPI_Info_dup PMPI_Info_dup
 #undef MPI_Info_free
 #define MPI_Info_free PMPI_Info_free
@@ -162,16 +163,17 @@
 #undef MPI_Info_get_nkeys
 #define MPI_Info_get_nkeys PMPI_Info_get_nkeys
 #undef MPI_Info_get_nthkey
 #define MPI_Info_get_nthkey PMPI_Info_get_nthkey
 #undef MPI_Info_get_valuelen
 #define MPI_Info_get_valuelen PMPI_Info_get_valuelen
 #undef MPI_Info_set
 #define MPI_Info_set PMPI_Info_set
+#endif /* only conditionally set the info */
 #undef MPI_Init
 #define MPI_Init PMPI_Init
 #undef MPI_Initialized
 #define MPI_Initialized PMPI_Initialized
 #undef MPI_Intercomm_create
 #define MPI_Intercomm_create PMPI_Intercomm_create
 #undef MPI_Intercomm_merge
 #define MPI_Intercomm_merge PMPI_Intercomm_merge
Index: romio/doc/Makefile
===================================================================
RCS file: /home/MPI/cvsMaster/romio/doc/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
--- romio/doc/Makefile	18 Jan 2002 16:41:58 -0000	1.1
+++ romio/doc/Makefile	26 May 2004 17:57:02 -0000	1.2
@@ -9,9 +9,9 @@
 	latex users-guide.tex
 	bibtex users-guide
 	latex users-guide.tex
 	latex users-guide.tex
 	dvips -o users-guide.ps users-guide.dvi
 
 clean:
 	-rm -f users-guide.toc users-guide.log users-guide.dvi \
-	       users-guide.aux
+	       users-guide.aux users-guide.bbl
Index: romio/doc/users-guide.ps.gz
===================================================================
RCS file: /home/MPI/cvsMaster/romio/doc/users-guide.ps.gz,v
retrieving revision 1.19
retrieving revision 1.20
diff -u -w -p -U8 -r1.19 -r1.20
Binary files /tmp/cvsy3X7o5 and /tmp/cvsdA5Zly differ
Index: romio/doc/users-guide.tex
===================================================================
RCS file: /home/MPI/cvsMaster/romio/doc/users-guide.tex,v
retrieving revision 1.11
retrieving revision 1.12
--- romio/doc/users-guide.tex	9 Jul 2003 00:20:25 -0000	1.11
+++ romio/doc/users-guide.tex	26 May 2004 17:57:03 -0000	1.12
@@ -31,17 +31,17 @@
 Mathematics and Computer Science Division
 
 \bigskip
 
 Technical Memorandum No.\ 234
 
 
 \vspace{1.4in}
-Revised May 2002
+Revised May 2004
 
 \end{center}
 
 \vfill
 
 {\small
 \noindent
 This work was supported by the Mathematical, Information, and
@@ -400,24 +400,23 @@
 Default is \texttt{disable}.
 \end{itemize}
 
 If ROMIO doesn't understand a hint, or if the value is invalid, the hint
 will be ignored. The values of hints being used by ROMIO for a file
 can be obtained at any time via {\tt MPI\_File\_get\_info}.
 
 \subsection{Using ROMIO on NFS}
-To use ROMIO on NFS, file locking with {\tt fcntl} must work correctly on
-the NFS installation. On some installations, fcntl locks don't work.
-To get them to work, you need to use Version~3 of NFS and 
-have the system administrator mount the NFS file system with the 
-``{\tt noac}'' option (no attribute caching). Turning off attribute caching 
-may reduce performance, but it is necessary for correct behavior.  
-Some NFS server implementations also need the lockd and rpc.statd servers
-running. 
+To use ROMIO on NFS, file locking with {\tt fcntl} must work correctly
+on the NFS installation. On some installations, fcntl locks don't
+work.  To get them to work, you need to use Version~3 of NFS, ensure
+that the lockd daemon is running on all the machines, and have the system
+administrator mount the NFS file system with the ``{\tt noac}'' option
+(no attribute caching). Turning off attribute caching may reduce
+performance, but it is necessary for correct behavior.
 
 The following are some instructions we received from Ian Wells of HP
 for setting the {\tt noac} option on NFS. We have not tried them
 ourselves. We are including them here because you may find 
 them useful. Note that some of the steps may be specific to HP
 systems, and you may need root permission to execute some of the
 commands. 
 
Index: romio/include/mpio.h.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/include/mpio.h.in,v
retrieving revision 1.20
retrieving revision 1.25
--- romio/include/mpio.h.in	7 Nov 2003 00:14:54 -0000	1.20
+++ romio/include/mpio.h.in	1 Jun 2004 19:21:16 -0000	1.25
@@ -1,40 +1,46 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: mpio.h.in,v 1.20 2003/11/07 00:14:54 robl Exp $    
+ *   $Id: mpio.h.in,v 1.25 2004/06/01 19:21:16 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 /* user include file for MPI-IO programs */
 
 #ifndef MPIO_INCLUDE
 #define MPIO_INCLUDE
 
 #include "mpi.h"
 
 #if defined(__cplusplus)
 extern "C" {
 #endif
 
-#define ROMIO_VERSION 124 /* version 1.2.4 */
+#define ROMIO_VERSION 126 /* version 1.2.6 */
 
 /* define MPI-IO datatypes and constants */
 
 #ifndef MPI_FILE_DEFINED
 typedef struct ADIOI_FileD *MPI_File;
 #endif
 
 @DEFINE_HAVE_MPI_GREQUEST@
 #ifndef HAVE_MPI_GREQUEST
 typedef struct ADIOI_RequestD *MPIO_Request;  
 #else
 #define MPIO_Request MPI_Request
+#define MPIO_USES_MPI_REQUEST
+/* Also rename the MPIO routines to get the MPI versions */
+#define MPIO_Wait MPI_Wait
+#define MPIO_Test MPI_Test
+#define PMPIO_Wait PMPI_Wait
+#define PMPIO_Test PMPI_Test
 #endif
 #define MPIO_REQUEST_DEFINED
 
 #ifndef HAVE_MPI_OFFSET
 @DEFINE_MPI_OFFSET@
 #endif
 
 #ifndef NEEDS_MPI_FINT
@@ -61,17 +67,22 @@
 #define MPI_MODE_EXCL               64  /* ADIO_EXCL */
 #define MPI_MODE_DELETE_ON_CLOSE    16  /* ADIO_DELETE_ON_CLOSE */
 #define MPI_MODE_UNIQUE_OPEN        32  /* ADIO_UNIQUE_OPEN */
 #define MPI_MODE_APPEND            128  /* ADIO_APPEND */
 #define MPI_MODE_SEQUENTIAL        256  /* ADIO_SEQUENTIAL */
 
 #define MPI_DISPLACEMENT_CURRENT   -54278278
 
+#ifndef MPI_FILE_NULL
+
+
+
 #define MPI_FILE_NULL           ((MPI_File) 0)
+#endif
 #define MPIO_REQUEST_NULL       ((MPIO_Request) 0)
 
 #define MPI_SEEK_SET            600
 #define MPI_SEEK_CUR            602
 #define MPI_SEEK_END            604
 
 #define MPI_MAX_DATAREP_STRING  128
 
@@ -199,18 +210,21 @@
                                      MPI_Aint *extent);
 
 /* Section 9.6.1 */
 int MPI_File_set_atomicity(MPI_File fh, int flag);
 int MPI_File_get_atomicity(MPI_File fh, int *flag);
 int MPI_File_sync(MPI_File fh);
 
 /* Section 4.13.3 */
+#ifndef MPICH2
+/* MPICH2 provides these definitions */
 int MPI_File_set_errhandler( MPI_File, MPI_Errhandler );
 int MPI_File_get_errhandler( MPI_File, MPI_Errhandler * );
+#endif
 /* End Prototypes */
 
 #ifndef HAVE_MPI_DARRAY_SUBARRAY
 /* Section 4.14.4 */
 int MPI_Type_create_subarray(int ndims, int *array_of_sizes, int
                       *array_of_subsizes, int *array_of_starts, int order, 
                       MPI_Datatype oldtype, MPI_Datatype *newtype);
 
@@ -394,18 +408,21 @@
                                       MPI_Aint *extent);
 
 /* Section 9.6.1 */
 int PMPI_File_set_atomicity(MPI_File fh, int flag);
 int PMPI_File_get_atomicity(MPI_File fh, int *flag);
 int PMPI_File_sync(MPI_File fh);
 
 /* Section 4.13.3 */
+#ifndef MPICH2
+/* MPICH2 provides these definitions */
 int PMPI_File_set_errhandler( MPI_File, MPI_Errhandler );
 int PMPI_File_get_errhandler( MPI_File, MPI_Errhandler * );
+#endif
 
 #ifndef HAVE_MPI_DARRAY_SUBARRAY
 /* Section 4.14.4 */
 int PMPI_Type_create_subarray(int ndims, int *array_of_sizes, int
                       *array_of_subsizes, int *array_of_starts, int order, 
                       MPI_Datatype oldtype, MPI_Datatype *newtype);
 
 /* Section 4.14.5 */
Index: romio/mpi-io/.cvsignore
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/.cvsignore,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/mpi-io/.cvsignore	1 Aug 2003 13:30:20 -0000	1.2
+++ romio/mpi-io/.cvsignore	19 Jan 2004 14:49:37 -0000	1.3
@@ -1,2 +1,5 @@
 Makefile
 .deps
+*.o
+*.bb
+*.bbg
Index: romio/mpi-io/Makefile.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/Makefile.in,v
retrieving revision 1.19
retrieving revision 1.21
--- romio/mpi-io/Makefile.in	1 Dec 2003 21:52:58 -0000	1.19
+++ romio/mpi-io/Makefile.in	27 Jan 2004 23:27:39 -0000	1.21
@@ -29,82 +29,77 @@
       rd_atallb.c rd_atalle.c read_allb.c read_alle.c wr_atallb.c \
       wr_atalle.c write_allb.c write_alle.c \
       get_posn_sh.c iread_sh.c read_sh.c write_sh.c \
       iwrite_sh.c seek_sh.c read_ord.c read_orde.c write_ordb.c \
       read_ordb.c write_ord.c write_orde.c mpiu_greq.c 
 
 # EXTRA objects are ones that need to be included for all but MPICH2
 MPIO_OBJECTS = close.o read.o open.o write.o set_view.o \
-      iread.o iwrite.o iotest.o iowait.o \
-	iowaitall.o iowaitany.o \
-	iotestall.o iotestany.o \
-	iowaitsome.o iotestsome.o \
+      iread.o iwrite.o \
       seek.o get_posn.o \
       delete.o read_all.o read_at.o \
       read_atall.o iread_at.o iwrite_at.o write_all.o get_bytoff.o \
       write_at.o write_atall.o get_view.o get_group.o get_amode.o \
       get_extent.o fsync.o get_atom.o set_atom.o \
       set_size.o get_size.o prealloc.o file_f2c.o file_c2f.o \
       ioreq_f2c.o ioreq_c2f.o set_info.o get_info.o \
       rd_atallb.o rd_atalle.o read_allb.o read_alle.o wr_atallb.o \
       wr_atalle.o write_allb.o write_alle.o \
       get_posn_sh.o iread_sh.o read_sh.o write_sh.o \
       iwrite_sh.o seek_sh.o read_ord.o read_orde.o write_ordb.o \
       read_ordb.o write_ord.o write_orde.o mpiu_greq.o mpich2_fileutil.o
+# MPIO_REQOBJECTS are the routines that provide the MPIO_Wait etc.
+# routines (iotest.o, iowait.o iowaitall.o iowaitany.o iotestall.o
+# iotestany.o iowaitsome.o and iotestsome.o)
+MPIO_REQOBJECTS = @MPIO_REQOBJECTS@
 
 # Either get_errh.o set_errh.o or empty 
-MPIO_EXTRA_OBJECTS = @MPIO_EXTRA_OBJECTS@
+MPIO_EXTRA_OBJECTS = @MPIO_EXTRA_OBJECTS@ @MPIO_REQOBJECTS@
 
 # mpich2_fileutil.p is not included because it does not include any
 # name-shifted functions
 MPIO_TMP_POBJECTS = close.p read.p open.p write.p get_extent.p \
-      iread.p iwrite.p iotest.p iowait.p \
-	iowaitall.p iowaitany.p \
-	iotestall.p iotestany.p \
-	iowaitsome.p iotestsome.p \
+      iread.p iwrite.p \
       seek.p \
       delete.p read_all.p read_at.p \
       read_atall.p iread_at.p iwrite_at.p get_posn.p \
       write_all.p write_at.p write_atall.p get_bytoff.p \
       set_view.p get_view.p get_group.p get_amode.p \
       fsync.p get_atom.p set_atom.p set_size.p get_size.p prealloc.p \
       file_f2c.p file_c2f.p ioreq_f2c.p ioreq_c2f.p set_info.p get_info.p \
       rd_atallb.p rd_atalle.p read_allb.p read_alle.p wr_atallb.p \
       wr_atalle.p write_allb.p write_alle.p \
       get_posn_sh.p iread_sh.p read_sh.p write_sh.p \
       iwrite_sh.p seek_sh.p read_ord.p read_orde.p write_ordb.p \
       read_ordb.p write_ord.p write_orde.p 
 
 # Either get_errh.p set_errh.p or empty 
-MPIO_EXTRA_TMP_POBJECTS = @MPIO_EXTRA_TMP_POBJECTS@
+MPIO_EXTRA_TMP_POBJECTS = @MPIO_EXTRA_TMP_POBJECTS@ @MPIO_REQ_TMP_POBJECTS@
 
 # _mpich2_fileutil.o is not included because it does not include any 
 # name-shifted functions
 MPIO_REAL_POBJECTS = _close.o _read.o _open.o _get_extent.o \
       _write.o _set_view.o _seek.o _read_at.o _prealloc.o \
-      _iread.o _iwrite.o _iotest.o _iowait.o \
-	_iowaitall.o _iowaitany.o \
-	_iotestall.o _iotestany.o \
-	_iowaitsome.o _iotestsome.o \
+      _iread.o _iwrite.o \
 	_get_posn.o \
       _delete.o _read_all.o _get_bytoff.o \
       _read_atall.o _iread_at.o _iwrite_at.o _get_group.o _get_amode.o \
       _write_all.o _write_at.o _write_atall.o _get_view.o \
       _fsync.o _get_atom.o _set_atom.o _set_size.o _get_size.o \
       _file_f2c.o _file_c2f.o _ioreq_f2c.o _ioreq_c2f.o \
       _set_info.o _get_info.o \
       _rd_atallb.o _rd_atalle.o _read_allb.o _read_alle.o _wr_atallb.o \
       _wr_atalle.o _write_allb.o _write_alle.o \
       _get_posn_sh.o _iread_sh.o _read_sh.o _write_sh.o \
       _iwrite_sh.o _seek_sh.o _read_ord.o _read_orde.o _write_ordb.o \
       _read_ordb.o _write_ord.o _write_orde.o 
 
 # Either _get_errh.o _set_errh.o or empty 
-MPIO_EXTRA_REAL_POBJECTS = @MPIO_EXTRA_REAL_POBJECTS@
+MPIO_EXTRA_REAL_POBJECTS = @MPIO_EXTRA_REAL_POBJECTS@ @MPIO_REQ_REAL_POBJECTS@
 
 all: $(LIBNAME)
 	@if [ "@ENABLE_SHLIB@" != "none" ] ; then \
 	    $(MAKE) $(SHLIBNAME).la ;\
 	fi
 
 .SUFFIXES: $(SUFFIXES) .p .lo
 
@@ -148,8 +143,14 @@
 	doctext -latex -mpath ../../../../doc/refman  -heading MPI \
 		-quotefmt ${master_top_srcdir}/maint/docnotes $<
 .c.html:
 	doctext -html -mpath ../../../../www/www3  -heading MPI \
 		-quotefmt ${master_top_srcdir}/maint/docnotes $<
 mandoc: ${mpi_sources:.c=.man}
 latexdoc: ${mpi_sources:.c=.latex}
 htmldoc: ${mpi_sources:.c=.html}
+
+tags: TAGS
+SOURCES = ${mpi_sources}
+HEADERS = 
+TAGS:${HEADERS} ${SOURCES}
+	here=`cd ../../../.. && pwd` ; cd ${srcdir} && etags -o $$here/TAGS --append ${HEADERS} ${SOURCES}
Index: romio/mpi-io/close.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/close.c,v
retrieving revision 1.11
retrieving revision 1.12
--- romio/mpi-io/close.c	1 Jul 2003 19:12:39 -0000	1.11
+++ romio/mpi-io/close.c	6 Apr 2004 18:46:31 -0000	1.12
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: close.c,v 1.11 2003/07/01 19:12:39 robl Exp $    
+ *   $Id: close.c,v 1.12 2004/04/06 18:46:31 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -50,16 +50,20 @@
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(*fh, myname);
 #endif
 
     if (((*fh)->file_system != ADIO_PIOFS) && ((*fh)->file_system != ADIO_PVFS) && ((*fh)->file_system != ADIO_PVFS2)) {
 	ADIOI_Free((*fh)->shared_fp_fname);
+        /* need a barrier because the file containing the shared file
+        pointer is opened with COMM_SELF. We don't want it to be
+	deleted while others are still accessing it. */ 
+        MPI_Barrier((*fh)->comm);
 	if ((*fh)->shared_fp_fd != ADIO_FILE_NULL)
 	    ADIO_Close((*fh)->shared_fp_fd, &error_code);
     }
 
     ADIO_Close(*fh, &error_code);
 
     *fh = MPI_FILE_NULL;
 #ifdef MPI_hpux
Index: romio/mpi-io/delete.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/delete.c,v
retrieving revision 1.18
retrieving revision 1.19
--- romio/mpi-io/delete.c	15 Sep 2003 13:33:30 -0000	1.18
+++ romio/mpi-io/delete.c	12 Feb 2004 06:08:22 -0000	1.19
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: delete.c,v 1.18 2003/09/15 13:33:30 gropp Exp $    
+ *   $Id: delete.c,v 1.19 2004/02/12 06:08:22 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -51,26 +51,29 @@
 #endif /* MPI_hpux */
 
     /* first check if ADIO has been initialized. If not, initialize it */
     if (ADIO_Init_keyval == MPI_KEYVAL_INVALID) {
 
    /* check if MPI itself has been initialized. If not, flag an error.
    Can't initialize it here, because don't know argc, argv */
         MPI_Initialized(&flag);
-        if (!flag) {
+	/* --BEGIN ERROR HANDLING-- */
+        if (!flag)
+	{
 #ifdef MPICH2
 	    error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**initialized", 0);
 	    return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #else
             FPRINTF(stderr, "Error: MPI_Init() must be called before using MPI-IO\n");
             MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
         }
+	/* --END ERROR HANDLING-- */
 
         MPI_Keyval_create(MPI_NULL_COPY_FN, ADIOI_End_call, &ADIO_Init_keyval,
                           (void *) 0);  
 
    /* put a dummy attribute on MPI_COMM_WORLD, because we want the delete
    function to be called when MPI_COMM_WORLD is freed. Hopefully the
    MPI library frees MPI_COMM_WORLD when MPI_Finalize is called,
    though the standard does not mandate this. */
@@ -81,30 +84,33 @@
 
         ADIO_Init( (int *)0, (char ***)0, &error_code);
     }
 
 
     /* resolve file system type from file name; this is a collective call */
     ADIO_ResolveFileType(MPI_COMM_SELF, filename, &file_system, &fsops, 
 			 &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 	/* ADIO_ResolveFileType() will print as informative a message as it
 	 * possibly can or call MPIR_Err_setmsg.  We just need to propagate 
 	 * the error up.  In the PRINT_ERR_MSG case MPI_Abort has already
 	 * been called as well, so we probably didn't even make it this far.
 	 */
 #ifdef MPICH2
 	return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	MPI_Abort(MPI_COMM_WORLD, 1); /* this is mostly here for clarity */
 #else /* MPICH-1 */
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* skip prefix on filename if there is one */
     tmp = strchr(filename, ':');
     /* Only skip prefixes greater than length one to allow for windows drive specification (c:\...)*/
     /*if (tmp) filename = tmp + 1;*/
     if (tmp > filename + 1)
 	filename = tmp + 1;
 
Index: romio/mpi-io/get_posn_sh.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/get_posn_sh.c,v
retrieving revision 1.17
retrieving revision 1.18
--- romio/mpi-io/get_posn_sh.c	1 Jul 2003 19:12:39 -0000	1.17
+++ romio/mpi-io/get_posn_sh.c	12 Feb 2004 06:08:24 -0000	1.18
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: get_posn_sh.c,v 1.17 2003/07/01 19:12:39 robl Exp $    
+ *   $Id: get_posn_sh.c,v 1.18 2004/02/12 06:08:24 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -47,42 +47,46 @@
     if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
 	FPRINTF(stderr, "MPI_File_get_position_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**ioamodeseq", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_get_position_shared: Can't use this function because file was opened with MPI_MODE_SEQUENTIAL\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, MPIR_ERR_AMODE_SEQ,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_get_position_shared: Shared file pointer not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_get_position_shared", &error_code);
 
     ADIO_Get_shared_fp(fh, 0, offset, &error_code);
     return error_code;
 }
Index: romio/mpi-io/get_view.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/get_view.c,v
retrieving revision 1.15
retrieving revision 1.16
--- romio/mpi-io/get_view.c	18 Apr 2003 20:15:08 -0000	1.15
+++ romio/mpi-io/get_view.c	12 Feb 2004 06:08:26 -0000	1.16
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: get_view.c,v 1.15 2003/04/18 20:15:08 David Exp $    
+ *   $Id: get_view.c,v 1.16 2004/02/12 06:08:26 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -55,30 +55,33 @@
     if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
 	FPRINTF(stderr, "MPI_File_get_view: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (datarep <= (char *) 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (datarep <= (char *) 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iodatarepnomem", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_get_view: The user must allocate memory for datarep\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_DATAREP_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     *disp = fh->disp;
     strcpy(datarep, "native");
 
     MPI_Type_get_envelope(fh->etype, &i, &j, &k, &combiner);
     if (combiner == MPI_COMBINER_NAMED) *etype = fh->etype;
     else {
         MPI_Type_contiguous(1, fh->etype, &copy_etype);
Index: romio/mpi-io/ioreq_f2c.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/ioreq_f2c.c,v
retrieving revision 1.10
retrieving revision 1.11
--- romio/mpi-io/ioreq_f2c.c	24 Feb 2003 23:52:08 -0000	1.10
+++ romio/mpi-io/ioreq_f2c.c	12 Feb 2004 06:08:27 -0000	1.11
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ioreq_f2c.c,v 1.10 2003/02/24 23:52:08 robl Exp $    
+ *   $Id: ioreq_f2c.c,v 1.11 2004/02/12 06:08:27 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -39,17 +39,19 @@
 MPIO_Request MPIO_Request_f2c(MPI_Fint request) {return((MPIO_Request)request);}
 #else
 MPIO_Request MPIO_Request_f2c(MPI_Fint request)
 {
 
 #ifndef INT_LT_POINTER
     return (MPIO_Request) request;
 #else
+    /* --BEGIN ERROR HANDLING-- */
     if (!request) return MPIO_REQUEST_NULL;
     if ((request < 0) || (request > ADIOI_Reqtable_ptr)) {
 	FPRINTF(stderr, "MPIO_Request_f2c: Invalid request\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
+    /* --END ERROR HANDLING-- */
     return ADIOI_Reqtable[request];
 #endif
 }
 #endif
Index: romio/mpi-io/iread_sh.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/iread_sh.c,v
retrieving revision 1.20
retrieving revision 1.21
--- romio/mpi-io/iread_sh.c	1 Jul 2003 19:12:40 -0000	1.20
+++ romio/mpi-io/iread_sh.c	12 Feb 2004 06:08:29 -0000	1.21
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: iread_sh.c,v 1.20 2003/07/01 19:12:40 robl Exp $    
+ *   $Id: iread_sh.c,v 1.21 2004/02/12 06:08:29 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -71,129 +71,152 @@
     int error_code, bufsize, buftype_is_contig, filetype_is_contig;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_IREAD_SHARED";
 #endif
     int datatype_size, incr;
     ADIO_Status status;
     ADIO_Offset off, shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_iread_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_iread_shared: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_iread_shared: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_iread_shared: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_iread_shared: Shared file pointer not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_iread_sh", &error_code);
 
     incr = (count*datatype_size)/fh->etype_size;
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 	FPRINTF(stderr, "MPI_File_iread_shared: Error! Could not access shared file pointer.\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
+    /* --END ERROR HANDLING-- */
 
     /* contiguous or strided? */
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
     /* convert count and shared_fp to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * shared_fp;
         if (!(fh->atomicity))
+	{
 	    ADIO_IreadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			off, request, &error_code); 
-        else {
+	}
+        else
+	{
             /* to maintain strict atomicity semantics with other concurrent
               operations, lock (exclusive) and call blocking routine */
 
             *request = ADIOI_Malloc_request();
             (*request)->optype = ADIOI_READ;
             (*request)->fd = fh;
             (*request)->datatype = datatype;
             (*request)->queued = 0;
 	    (*request)->handle = 0;
 
             if (fh->file_system != ADIO_NFS)
+	    {
                 ADIOI_WRITE_LOCK(fh, off, SEEK_SET, bufsize);
+	    }
 
             ADIO_ReadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET, off, 
                     &status, &error_code);  
 
             if (fh->file_system != ADIO_NFS)
+	    {
                 ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
+	    }
 
             fh->async_count++;
             /* status info. must be linked to the request structure, so that it
                can be accessed later from a wait */
         }
     }
-    else ADIO_IreadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
+    else
+    {
+	ADIO_IreadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			   shared_fp, request, &error_code); 
+    }
 
     return error_code;
 }
 #endif
Index: romio/mpi-io/mpich2_fileutil.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/mpich2_fileutil.c,v
retrieving revision 1.12
retrieving revision 1.15
--- romio/mpi-io/mpich2_fileutil.c	3 Nov 2003 13:49:38 -0000	1.12
+++ romio/mpi-io/mpich2_fileutil.c	7 Jun 2004 14:55:17 -0000	1.15
@@ -12,22 +12,26 @@
    in a ROMIO File structure.  FIXME: These should be imported from a common
    header file that is also used in errhan/file_set_errhandler.c
  */
 int MPIR_ROMIO_Get_file_errhand( MPI_File, MPI_Errhandler * );
 int MPIR_ROMIO_Set_file_errhand( MPI_File, MPI_Errhandler );
 void MPIR_Get_file_error_routine( MPI_Errhandler, 
 				  void (**)(MPI_File *, int *, ...), 
 				  int * );
+struct MPID_Comm;
+int MPID_Abort( struct MPID_Comm *comm, int mpi_errno, int exit_code, char *error_msg );
 
 int MPIR_Err_return_file( MPI_File file_ptr, const char fcname[], int errcode )
 {
     MPI_Errhandler e;
     void (*c_errhandler)(MPI_File *, int *, ... );
     int  kind;   /* Error handler kind (see below) */
+    char error_msg[4096];
+    int len;
 
     /* First, check the nesting level */
     /*if (MPIR_Nest_value()) return errcode;*/ /* Is there any recursion in the MPI_File_... interface? */
 
     /* If the file pointer is not valid, we use the handler on
        MPI_FILE_NULL (MPI-2, section 9.7).  For now, this code assumes that 
        MPI_FILE_NULL has the default handler (return).  FIXME.  See
        below - the set error handler uses ADIOI_DFLT_ERR_HANDLER; 
@@ -53,35 +57,22 @@
     }
     else {
 	MPIR_Get_file_error_routine( e, &c_errhandler, &kind );
     }
 
     /* --BEGIN ERROR HANDLING-- */
     if (MPIR_Err_is_fatal(errcode) || kind == 0) 
     {
-	if (MPIR_Err_print_stack_flag)
-	{
-	    fprintf( stderr, "Fatal error (code 0x%08x) in %s():\n", errcode, fcname);
-	    MPIR_Err_print_stack(stderr, errcode);
-	}
-	else
-	{
-	    /* The default handler should try the following: Provide the rank 
-	       in comm_world.  If the process is not in comm world,
-	       use something else.  If the communicator exists and has a name, 
-	       provide that name */
-	    char msg[MPI_MAX_ERROR_STRING];
-
-	    MPIR_Err_get_string( errcode, msg );
-	    fprintf( stderr, "Fatal error (code 0x%08x) in %s(): %s\n", 
-		     errcode, fcname, msg);
-	}
-
-	MPID_Abort( 0, errcode, errcode); 
+	/* This file does not get the correct definitions for MPIU_Snprintf because it cannot include mpiimpl.h */
+	/* MPIU_Snprintf(error_msg, 4096, "Fatal error in %s: ", fcname); */
+	sprintf(error_msg, "Fatal error in %s: ", fcname);
+	len = (int)strlen(error_msg);
+	MPIR_Err_get_string(errcode, &error_msg[len], 4096-len, NULL);
+	MPID_Abort(NULL, MPI_SUCCESS, errcode, error_msg);
     }
     /* --END ERROR HANDLING-- */
     else if (kind == 2) {
 	(*c_errhandler)( &file_ptr, &errcode, 0 );
     }
     /* if kind == 1, just return */
 
     return errcode;
Index: romio/mpi-io/mpioprof.h
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/mpioprof.h,v
retrieving revision 1.9
retrieving revision 1.10
--- romio/mpi-io/mpioprof.h	8 Sep 2003 13:32:48 -0000	1.9
+++ romio/mpi-io/mpioprof.h	28 May 2004 23:05:41 -0000	1.10
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: mpioprof.h,v 1.9 2003/09/08 13:32:48 gropp Exp $    
+ *   $Id: mpioprof.h,v 1.10 2004/05/28 23:05:41 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 /* 
    This header file converts all MPI_ names into PMPI_ names, for 
    building the profiling interface
@@ -135,18 +135,20 @@
 #if !defined(MPI_File_f2c) || defined(MPICH_RENAMING_MPI_FUNCS)
 #undef MPI_File_f2c
 #define MPI_File_f2c PMPI_File_f2c
 #undef MPI_File_c2f
 #define MPI_File_c2f PMPI_File_c2f
 #endif
 
 #undef MPIO_Test
+#undef PMPIO_Test
 #define MPIO_Test PMPIO_Test
 #undef MPIO_Wait
+#undef PMPIO_Wait
 #define MPIO_Wait PMPIO_Wait
 #undef MPIO_Testall
 #define MPIO_Testall PMPIO_Testall
 #undef MPIO_Waitall
 #define MPIO_Waitall PMPIO_Waitall
 #undef MPIO_Testany
 #define MPIO_Testany PMPIO_Testany
 #undef MPIO_Waitany
@@ -182,9 +184,16 @@
 #define MPI_Info_free PMPI_Info_free
 #undef MPI_Info_c2f
 #define MPI_Info_c2f PMPI_Info_c2f
 #undef MPI_Info_f2c
 #define MPI_Info_f2c PMPI_Info_f2c
 
 #endif
 
+#undef MPI_Grequest_start
+#define MPI_Grequest_start PMPI_Grequest_start
+#undef MPI_Grequest_complete
+#define MPI_Grequest_complete PMPI_Grequest_complete
+#undef MPI_Status_set_cancelled
+#define MPI_Status_set_cancelled PMPI_Status_set_cancelled
+
 #endif
Index: romio/mpi-io/mpiu_greq.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/mpiu_greq.c,v
retrieving revision 1.2
retrieving revision 1.3
--- romio/mpi-io/mpiu_greq.c	18 Mar 2003 17:19:17 -0000	1.2
+++ romio/mpi-io/mpiu_greq.c	28 May 2004 23:05:41 -0000	1.3
@@ -2,16 +2,22 @@
 /*
  *  (C) 2003 by Argonne National Laboratory.
  *      See COPYRIGHT in top-level directory.
  */
 #include <string.h>
 #include "mpioimpl.h"
 #include "mpiu_greq.h"
 
+#ifdef HAVE_WEAK_SYMBOLS
+/* Include mapping from MPI->PMPI */
+#define MPIO_BUILD_PROFILING
+#include "mpioprof.h"
+#endif
+
 int MPIU_Greq_query_fn(void *extra_state, MPI_Status *status)
 {
 	int foo;
 
 	/* can't touch user's MPI_ERROR, so hold it for a moment */
 	foo = status->MPI_ERROR;
 
 	/* get the status from the blocking operation */
Index: romio/mpi-io/open.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/open.c,v
retrieving revision 1.32
retrieving revision 1.34
--- romio/mpi-io/open.c	22 Sep 2003 21:23:23 -0000	1.32
+++ romio/mpi-io/open.c	19 May 2004 23:55:09 -0000	1.34
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: open.c,v 1.32 2003/09/22 21:23:23 gropp Exp $    
+ *   $Id: open.c,v 1.34 2004/05/19 23:55:09 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -52,108 +52,118 @@
     ADIOI_Fns *fsops;
 
 #ifdef MPI_hpux
     int fl_xmpi;
 
     HPMP_IO_OPEN_START(fl_xmpi, comm);
 #endif /* MPI_hpux */
 
-    if (comm == MPI_COMM_NULL) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (comm == MPI_COMM_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_COMM, "**comm", 0);
 	return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_open: Invalid communicator\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_COMM, MPIR_ERR_COMM_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Comm_test_inter(comm, &flag);
-    if (flag) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (flag)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_COMM, 
 	    "**commnotintra", 0);
 	return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_open: Intercommunicator cannot be passed to MPI_File_open\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_COMM, MPIR_ERR_COMM_INTER,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
 
     if ( ((amode&MPI_MODE_RDONLY)?1:0) + ((amode&MPI_MODE_RDWR)?1:0) +
-	 ((amode&MPI_MODE_WRONLY)?1:0) != 1 ) {
+	 ((amode&MPI_MODE_WRONLY)?1:0) != 1 )
+    {
 #ifdef MPICH2
 	     error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_AMODE, 
 		 "**fileamodeone", 0);
 	     return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_open: Exactly one of MPI_MODE_RDONLY, MPI_MODE_WRONLY, or MPI_MODE_RDWR must be specified\n");
 	MPI_Abort(MPI_COMM_WORLD, 1); 
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_AMODE, 3,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
 
     if ((amode & MPI_MODE_RDONLY) && 
-            ((amode & MPI_MODE_CREATE) || (amode & MPI_MODE_EXCL))) {
+            ((amode & MPI_MODE_CREATE) || (amode & MPI_MODE_EXCL)))
+    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_AMODE, 
 		    "**fileamoderead", 0);
 		return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_open: It is erroneous to specify MPI_MODE_CREATE or MPI_MODE_EXCL with MPI_MODE_RDONLY\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_AMODE, 5,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
 
-    if ((amode & MPI_MODE_RDWR) && (amode & MPI_MODE_SEQUENTIAL)) {
+    if ((amode & MPI_MODE_RDWR) && (amode & MPI_MODE_SEQUENTIAL))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_AMODE, 
 	    "**fileamodeseq", 0);
 	return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_open: It is erroneous to specify MPI_MODE_SEQUENTIAL with MPI_MODE_RDWR\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_AMODE, 7,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 /* check if amode is the same on all processes */
     MPI_Comm_dup(comm, &dupcomm);
 
 /*  
     Removed this check because broadcast is too expensive. 
     tmp_amode = amode;
     MPI_Bcast(&tmp_amode, 1, MPI_INT, 0, dupcomm);
     if (amode != tmp_amode) {
 	FPRINTF(stderr, "MPI_File_open: amode must be the same on all processes\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 */
 
 /* check if ADIO has been initialized. If not, initialize it */
-    if (ADIO_Init_keyval == MPI_KEYVAL_INVALID) {
+    if (ADIO_Init_keyval == MPI_KEYVAL_INVALID)
+    {
 
 /* check if MPI itself has been initialized. If not, flag an error.
    Can't initialize it here, because don't know argc, argv */
 	MPI_Initialized(&flag);
 	/* --BEGIN ERROR HANDLING-- */
 	if (!flag) {
 	    FPRINTF(stderr, "Error: MPI_Init() must be called before using MPI-IO\n");
 	    MPI_Abort(MPI_COMM_WORLD, 1);
@@ -175,17 +185,19 @@
 	ADIO_Init( (int *)0, (char ***)0, &error_code);
     }
 
 
     file_system = -1;
 
     /* resolve file system type from file name; this is a collective call */
     ADIO_ResolveFileType(dupcomm, filename, &file_system, &fsops, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 	/* ADIO_ResolveFileType() will print as informative a message as it
 	 * possibly can or call MPIR_Err_setmsg.  We just need to propagate 
 	 * the error up.  In the PRINT_ERR_MSG case MPI_Abort has already
 	 * been called as well, so we probably didn't even make it this far.
 	 */
 #ifdef MPICH2
 	return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
@@ -197,45 +209,50 @@
 
     /* Test for invalid flags in amode.
      *
      * eventually we should allow the ADIO implementations to test for 
      * invalid flags through some functional interface rather than having
      *  these tests here. -- Rob, 06/06/2001
      */
     if (((file_system == ADIO_PIOFS) || (file_system == ADIO_PVFS) || (file_system == ADIO_PVFS2)) && 
-        (amode & MPI_MODE_SEQUENTIAL)) {
+        (amode & MPI_MODE_SEQUENTIAL))
+    {
 #ifdef MPICH2
 	    error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 		"**iosequnsupported", 0);
 	    return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_open: MPI_MODE_SEQUENTIAL not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_MODE_SEQ, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* strip off prefix if there is one */
     tmp = strchr(filename, ':');
     /* Only skip prefixes greater than length one to allow for windows drive specification (c:\...)*/
     /*if (tmp) filename = tmp + 1;*/
     if (tmp > filename + 1)
 	filename = tmp + 1;
 
 /* use default values for disp, etype, filetype */    
 /* set iomode=M_ASYNC. It is used to implement the Intel PFS interface
    on top of ADIO. Not relevant for MPI-IO implementation */    
 
     *fh = ADIO_Open(comm, dupcomm, filename, file_system, amode, 0, MPI_BYTE,
                     MPI_BYTE, M_ASYNC, info, ADIO_PERM_NULL, &error_code);
 
+    if (error_code != MPI_SUCCESS)
+        MPI_Comm_free(&dupcomm);
+
     /* determine name of file that will hold the shared file pointer */
     /* can't support shared file pointers on a file system that doesn't
        support file locking, e.g., PIOFS, PVFS, PVFS2 */
     if ((error_code == MPI_SUCCESS) && ((*fh)->file_system != ADIO_PIOFS)
           && ((*fh)->file_system != ADIO_PVFS) 
 	  && ((*fh)->file_system != ADIO_PVFS2) ){
 	MPI_Comm_rank(dupcomm, &rank);
 	ADIOI_Shfp_fname(*fh, rank);
Index: romio/mpi-io/read_alle.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/read_alle.c,v
retrieving revision 1.15
retrieving revision 1.16
--- romio/mpi-io/read_alle.c	8 Sep 2003 13:35:04 -0000	1.15
+++ romio/mpi-io/read_alle.c	12 Feb 2004 06:08:42 -0000	1.16
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_alle.c,v 1.15 2003/09/08 13:35:04 gropp Exp $    
+ *   $Id: read_alle.c,v 1.16 2004/02/12 06:08:42 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -38,39 +38,43 @@
 @*/
 int MPI_File_read_all_end(MPI_File fh, void *buf, MPI_Status *status)
 {
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     int error_code;
     static char myname[] = "MPI_FILE_IREAD";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_all_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_all_end: Does not match a previous MPI_File_read_all_begin\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_NO_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     if (status != MPI_STATUS_IGNORE)
        *status = fh->split_status;
 #endif
     fh->split_coll_count = 0;
 
     return MPI_SUCCESS;
Index: romio/mpi-io/read_at.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/read_at.c,v
retrieving revision 1.20
retrieving revision 1.21
--- romio/mpi-io/read_at.c	8 Sep 2003 13:33:43 -0000	1.20
+++ romio/mpi-io/read_at.c	12 Feb 2004 06:08:44 -0000	1.21
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_at.c,v 1.20 2003/09/08 13:33:43 gropp Exp $    
+ *   $Id: read_at.c,v 1.21 2004/02/12 06:08:44 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -52,134 +52,147 @@
     int datatype_size;
     ADIO_Offset off;
 #ifdef MPI_hpux
     int fl_xmpi;
 
     HPMP_IO_START(fl_xmpi, BLKMPIFILEREADAT, TRDTBLOCK, fh, datatype, count);
 #endif /* MPI_hpux */
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_at: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (offset < 0) {
+    if (offset < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadoffset", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_at: Invalid offset argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_at: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_at: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
-    if (count*datatype_size == 0) {
+    if (count*datatype_size == 0)
+    {
 #ifdef MPI_hpux
 	HPMP_IO_END(fl_xmpi, fh, datatype, count);
 #endif /* MPI_hpux */
 #ifdef HAVE_STATUS_SET_BYTES
        MPIR_Status_set_bytes(status, datatype, 0);
 #endif
 	return MPI_SUCCESS;
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_at: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_WRONLY) {
+    if (fh->access_mode & MPI_MODE_WRONLY)
+    {
 #ifdef MPICH2
 	error_code=  MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ACCESS, 
 	    "**ioneedrd", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_at: Can't read from a file opened with MPI_MODE_WRONLY\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
  		MPIR_ERR_MODE_WRONLY, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**ioamodeseq", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_at: Can't use this function because file was opened with MPI_MODE_SEQUENTIAL\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                         MPIR_ERR_AMODE_SEQ, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_read_at", &error_code);
 
     /* contiguous or strided? */
 
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
     /* convert count and offset to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * offset;
 
         /* if atomic mode requested, lock (exclusive) the region, because there
            could be a concurrent noncontiguous request. Locking doesn't 
            work on PIOFS and PVFS, and on NFS it is done in the ADIO_ReadContig.*/
 
@@ -191,19 +204,22 @@
 	ADIO_ReadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			off, status, &error_code); 
 
         if ((fh->atomicity) && (fh->file_system != ADIO_PIOFS) && 
             (fh->file_system != ADIO_NFS) && (fh->file_system != ADIO_PVFS) &&
 	    	(fh->file_system != ADIO_PVFS2))
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
-    else ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
+    else
+    {
+	ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			  offset, status, &error_code); 
     /* For strided and atomic mode, locking is done in ADIO_ReadStrided */
+    }
 
 
 #ifdef MPI_hpux
     HPMP_IO_END(fl_xmpi, fh, datatype, count);
 #endif /* MPI_hpux */
     return error_code;
 }
 
Index: romio/mpi-io/read_ordb.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/read_ordb.c,v
retrieving revision 1.20
retrieving revision 1.21
--- romio/mpi-io/read_ordb.c	25 Sep 2003 13:25:11 -0000	1.20
+++ romio/mpi-io/read_ordb.c	12 Feb 2004 06:08:49 -0000	1.21
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_ordb.c,v 1.20 2003/09/25 13:25:11 gropp Exp $    
+ *   $Id: read_ordb.c,v 1.21 2004/02/12 06:08:49 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -42,125 +42,138 @@
 {
     int error_code, datatype_size, nprocs, myrank, incr;
     int source, dest;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_READ_ORDERED_BEGIN";
 #endif
     ADIO_Offset shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_ordered_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_ordered_begin: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_ordered_begin: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcoll", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_ordered_begin: Only one active split collective I/O operation allowed per file handle\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */	
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_MULTIPLE_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_ordered_begin: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
     if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || 
-		    (fh->file_system == ADIO_PVFS2)) {
+		    (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_ordered_begin: Shared file pointer not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_read_ordered_begin", &error_code);
 
     MPI_Comm_size(fh->comm, &nprocs);
     MPI_Comm_rank(fh->comm, &myrank);
 
     incr = (count*datatype_size)/fh->etype_size;
     /* Use a message as a 'token' to order the operations */
     source = myrank - 1;
     dest   = myrank + 1;
     if (source < 0) source = MPI_PROC_NULL;
     if (dest >= nprocs) dest = MPI_PROC_NULL;
     MPI_Recv( NULL, 0, MPI_BYTE, source, 0, fh->comm, MPI_STATUS_IGNORE );
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #else
 	FPRINTF(stderr, "MPI_File_read_ordered_begin: Error! Could not access shared file pointer.\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
     MPI_Send( NULL, 0, MPI_BYTE, dest, 0, fh->comm );
 
     ADIO_ReadStridedColl(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			 shared_fp, &fh->split_status, &error_code);
 
     return error_code;
 }
Index: romio/mpi-io/read_orde.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/read_orde.c,v
retrieving revision 1.15
retrieving revision 1.16
--- romio/mpi-io/read_orde.c	8 Sep 2003 13:35:04 -0000	1.15
+++ romio/mpi-io/read_orde.c	12 Feb 2004 06:08:51 -0000	1.16
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_orde.c,v 1.15 2003/09/08 13:35:04 gropp Exp $    
+ *   $Id: read_orde.c,v 1.16 2004/02/12 06:08:51 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -47,30 +47,33 @@
     if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
 	FPRINTF(stderr, "MPI_File_read_ordered_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_ordered_end: Does not match a previous MPI_File_read_ordered_begin\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_NO_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     if (status != MPI_STATUS_IGNORE)
        *status = fh->split_status;
 #endif
     fh->split_coll_count = 0;
 
     return MPI_SUCCESS;
Index: romio/mpi-io/read_sh.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/read_sh.c,v
retrieving revision 1.19
retrieving revision 1.20
--- romio/mpi-io/read_sh.c	15 Sep 2003 13:33:31 -0000	1.19
+++ romio/mpi-io/read_sh.c	12 Feb 2004 06:08:53 -0000	1.20
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_sh.c,v 1.19 2003/09/15 13:33:31 gropp Exp $    
+ *   $Id: read_sh.c,v 1.20 2004/02/12 06:08:53 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -45,112 +45,126 @@
 {
     int error_code, bufsize, buftype_is_contig, filetype_is_contig;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_READ_SHARED";
 #endif
     int datatype_size, incr;
     ADIO_Offset off, shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_shared: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_read_shared: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
-    if (count*datatype_size == 0) {
+    if (count*datatype_size == 0)
+    {
 #ifdef HAVE_STATUS_SET_BYTES
 	MPIR_Status_set_bytes(status, datatype, 0);
 #endif
 	return MPI_SUCCESS;
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_shared: Only an integral number of etypes can be accessed\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_read_shared: Shared file pointer not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_read_shared", &error_code);
 
     incr = (count*datatype_size)/fh->etype_size;
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #else
 	FPRINTF(stderr, "MPI_File_read_shared: Error! Could not access shared file pointer.\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* contiguous or strided? */
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
 	/* convert count and shared_fp to bytes */
         bufsize = datatype_size * count;
         off = fh->disp + fh->etype_size * shared_fp;
 
         /* if atomic mode requested, lock (exclusive) the region, because there
            could be a concurrent noncontiguous request. On NFS, locking 
            is done in the ADIO_ReadContig.*/
 
@@ -158,14 +172,17 @@
             ADIOI_WRITE_LOCK(fh, off, SEEK_SET, bufsize);
 
         ADIO_ReadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
                         off, status, &error_code); 
 
         if ((fh->atomicity) && (fh->file_system != ADIO_NFS))
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
-    else ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
+    else
+    {
+	ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
                           shared_fp, status, &error_code); 
     /* For strided and atomic mode, locking is done in ADIO_ReadStrided */
+    }
 
     return error_code;
 }
Index: romio/mpi-io/seek_sh.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/seek_sh.c,v
retrieving revision 1.18
retrieving revision 1.19
--- romio/mpi-io/seek_sh.c	15 Sep 2003 13:33:31 -0000	1.18
+++ romio/mpi-io/seek_sh.c	12 Feb 2004 06:09:02 -0000	1.19
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: seek_sh.c,v 1.18 2003/09/15 13:33:31 gropp Exp $    
+ *   $Id: seek_sh.c,v 1.19 2004/02/12 06:09:02 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -37,171 +37,198 @@
 int MPI_File_seek_shared(MPI_File fh, MPI_Offset offset, int whence)
 {
     int error_code=MPI_SUCCESS, tmp_whence, myrank;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_SEEK_SHARED";
 #endif
     MPI_Offset curr_offset, eof_offset, tmp_offset;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_seek_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**ioamodeseq", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_seek_shared: Can't use this function because file was opened with MPI_MODE_SEQUENTIAL\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                         MPIR_ERR_AMODE_SEQ, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_seek_shared: Shared file pointer not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     tmp_offset = offset;
     MPI_Bcast(&tmp_offset, 1, ADIO_OFFSET, 0, fh->comm);
-    if (tmp_offset != offset) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (tmp_offset != offset)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**notsame", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_seek_shared: offset must be the same on all processes\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG_NOT_SAME,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     tmp_whence = whence;
     MPI_Bcast(&tmp_whence, 1, MPI_INT, 0, fh->comm);
-    if (tmp_whence != whence) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (tmp_whence != whence)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadwhence", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_seek_shared: whence argument must be the same on all processes\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_WHENCE_ARG_NOT_SAME,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_seek_shared", &error_code);
 
     MPI_Comm_rank(fh->comm, &myrank);
 
-    if (!myrank) {
-	switch(whence) {
+    if (!myrank)
+    {
+	switch(whence)
+	{
 	case MPI_SEEK_SET:
-	    if (offset < 0) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (offset < 0)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		    "**iobadoffset", 0);
 		return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 		FPRINTF(stderr, "MPI_File_seek_shared: Invalid offset argument\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    break;
 	case MPI_SEEK_CUR:
 	    /* get current location of shared file pointer */
 	    ADIO_Get_shared_fp(fh, 0, &curr_offset, &error_code);
-	    if (error_code != MPI_SUCCESS) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (error_code != MPI_SUCCESS)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 	    "**iosharedfailed", 0);
 		return MPIR_Err_return_file(fh, myname, error_code);
 #else
 		FPRINTF(stderr, "MPI_File_seek_shared: Error! Could not access shared file pointer.\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    offset += curr_offset;
-	    if (offset < 0) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (offset < 0)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		    "**ionegoffset", 0);
 		return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 		FPRINTF(stderr, "MPI_File_seek_shared: offset points to a negative location in the file\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG_NEG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    break;
 	case MPI_SEEK_END:
 	    /* find offset corr. to end of file */
 	    ADIOI_Get_eof_offset(fh, &eof_offset);
 	    offset += eof_offset;
-	    if (offset < 0) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (offset < 0)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		    "**ionegoffset", 0);
 		return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 		FPRINTF(stderr, "MPI_File_seek_shared: offset points to a negative location in the file\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG_NEG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    break;
 	default:
+	    /* --BEGIN ERROR HANDLING-- */
 #ifdef MPICH2
 	    error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		"**iobadwhence", 0);
 	    return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	    FPRINTF(stderr, "MPI_File_seek_shared: Invalid whence argument\n");
 	    MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	    error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_WHENCE_ARG,
 				     myname, (char *) 0, (char *) 0);
 	    return ADIOI_Error(fh, error_code, myname);
 #endif
+	    /* --END ERROR HANDLING-- */
 	}
 
 	ADIO_Set_shared_fp(fh, offset, &error_code);
     }
 
     /* FIXME: explain why the barrier is necessary */
     MPI_Barrier(fh->comm);
 
Index: romio/mpi-io/set_errh.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/set_errh.c,v
retrieving revision 1.11
retrieving revision 1.12
--- romio/mpi-io/set_errh.c	18 Apr 2003 20:15:12 -0000	1.11
+++ romio/mpi-io/set_errh.c	16 Dec 2003 17:32:34 -0000	1.12
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: set_errh.c,v 1.11 2003/04/18 20:15:12 David Exp $    
+ *   $Id: set_errh.c,v 1.12 2003/12/16 17:32:34 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 #include "adio_extern.h"
 
@@ -36,17 +36,17 @@
 @*/
 int MPI_File_set_errhandler(MPI_File fh, MPI_Errhandler errhandler)
 {
     int error_code = MPI_SUCCESS;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_SET_ERRHANDLER";
 #endif
 
-    if ((errhandler != MPI_ERRORS_RETURN) || (errhandler != MPI_ERRORS_ARE_FATAL)) {
+    if ((errhandler != MPI_ERRORS_RETURN) && (errhandler != MPI_ERRORS_ARE_FATAL)) {
 	FPRINTF(stderr, "Only MPI_ERRORS_RETURN and MPI_ERRORS_ARE_FATAL are currently supported for MPI_File_set_errhandler\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 
     if (fh == MPI_FILE_NULL) ADIOI_DFLT_ERR_HANDLER = errhandler;
     else if (fh->cookie != ADIOI_FILE_COOKIE) {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_FILE, "**iobadfh", 0);
Index: romio/mpi-io/wr_atallb.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/wr_atallb.c,v
retrieving revision 1.16
retrieving revision 1.17
--- romio/mpi-io/wr_atallb.c	5 Sep 2003 22:33:57 -0000	1.16
+++ romio/mpi-io/wr_atallb.c	12 Feb 2004 06:09:09 -0000	1.17
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: wr_atallb.c,v 1.16 2003/09/05 22:33:57 gropp Exp $    
+ *   $Id: wr_atallb.c,v 1.17 2004/02/12 06:09:09 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -39,113 +39,124 @@
 int MPI_File_write_at_all_begin(MPI_File fh, MPI_Offset offset, void *buf,
                          int count, MPI_Datatype datatype)
 {
     int error_code, datatype_size;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_WRITE_AT_ALL_BEGIN";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_at_all_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (offset < 0) {
+    if (offset < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**iobadoffset", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_at_all_begin: Invalid offset argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_at_all_begin: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_at_all_begin: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**ioamodeseq", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_at_all_begin: Can't use this function because file was opened with MPI_MODE_SEQUENTIAL\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                         MPIR_ERR_AMODE_SEQ, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcoll", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_at_all_begin: Only one active split collective I/O operation allowed per file handle\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_MULTIPLE_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_at_all_begin: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_datatype = datatype;
     ADIO_WriteStridedColl(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			  offset, &fh->split_status, &error_code);
     return error_code;
 }
Index: romio/mpi-io/wr_atalle.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/wr_atalle.c,v
retrieving revision 1.16
retrieving revision 1.17
--- romio/mpi-io/wr_atalle.c	8 Sep 2003 13:35:05 -0000	1.16
+++ romio/mpi-io/wr_atalle.c	12 Feb 2004 06:09:10 -0000	1.17
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: wr_atalle.c,v 1.16 2003/09/08 13:35:05 gropp Exp $    
+ *   $Id: wr_atalle.c,v 1.17 2004/02/12 06:09:10 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -38,39 +38,43 @@
 @*/
 int MPI_File_write_at_all_end(MPI_File fh, void *buf, MPI_Status *status)
 {
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     int error_code;
     static char myname[] = "MPI_FILE_WRITE_AT_ALL_END";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_at_all_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_at_all_end: Does not match a previous MPI_File_write_at_all_begin\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_NO_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     /* FIXME - we should really ensure that the split_datatype remains
        valid by incrementing the ref count in the write_allb.c routine
        and decrement it here after setting the bytes */
     if (status != MPI_STATUS_IGNORE)
        *status = fh->split_status;
 #endif
Index: romio/mpi-io/write_allb.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/write_allb.c,v
retrieving revision 1.15
retrieving revision 1.16
--- romio/mpi-io/write_allb.c	5 Sep 2003 22:34:31 -0000	1.15
+++ romio/mpi-io/write_allb.c	12 Feb 2004 06:09:12 -0000	1.16
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_allb.c,v 1.15 2003/09/05 22:34:31 gropp Exp $    
+ *   $Id: write_allb.c,v 1.16 2004/02/12 06:09:12 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -38,100 +38,110 @@
 int MPI_File_write_all_begin(MPI_File fh, void *buf, int count, 
                             MPI_Datatype datatype)
 {
     int error_code, datatype_size;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_WRITE_ALL_BEGIN";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_all_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_all_begin: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_all_begin: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**ioamodeseq", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_all_begin: Can't use this function because file was opened with MPI_MODE_SEQUENTIAL\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                         MPIR_ERR_AMODE_SEQ, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**iosplitcoll", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_all_begin: Only one active split collective I/O operation allowed per file handle\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_MULTIPLE_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO,
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_all_begin: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* See FIXME in write_alle.c */
     fh->split_datatype = datatype;
     ADIO_WriteStridedColl(fh, buf, count, datatype, ADIO_INDIVIDUAL,
 			  0, &fh->split_status, &error_code);
     return error_code;
 }
Index: romio/mpi-io/write_alle.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/write_alle.c,v
retrieving revision 1.15
retrieving revision 1.18
--- romio/mpi-io/write_alle.c	5 Sep 2003 22:34:32 -0000	1.15
+++ romio/mpi-io/write_alle.c	17 Mar 2004 20:31:27 -0000	1.18
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_alle.c,v 1.15 2003/09/05 22:34:32 gropp Exp $    
+ *   $Id: write_alle.c,v 1.18 2004/03/17 20:31:27 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -38,42 +38,46 @@
 @*/
 int MPI_File_write_all_end(MPI_File fh, void *buf, MPI_Status *status)
 {
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     int error_code;
     static char myname[] = "MPI_FILE_WRITE_ALL_END";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
     if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
 	FPRINTF(stderr, "MPI_File_write_all_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO,
 	    "**iosplitcollnone", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_all_end: Does not match a previous MPI_File_write_all_begin\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_NO_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     /* FIXME - we should really ensure that the split_datatype remains
        valid by incrementing the ref count in the write_allb.c routine
        and decrement it here after setting the bytes */
+    if (status != MPI_STATUS_IGNORE)
        *status = fh->split_status;
 #endif
     fh->split_coll_count = 0;
 
     return MPI_SUCCESS;
 }
Index: romio/mpi-io/write_at.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/write_at.c,v
retrieving revision 1.20
retrieving revision 1.21
--- romio/mpi-io/write_at.c	8 Sep 2003 21:29:22 -0000	1.20
+++ romio/mpi-io/write_at.c	12 Feb 2004 06:09:15 -0000	1.21
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_at.c,v 1.20 2003/09/08 21:29:22 gropp Exp $    
+ *   $Id: write_at.c,v 1.21 2004/02/12 06:09:15 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -53,135 +53,148 @@
     int datatype_size;
     ADIO_Offset off;
 #ifdef MPI_hpux
     int fl_xmpi;
 
     HPMP_IO_START(fl_xmpi, BLKMPIFILEWRITEAT, TRDTBLOCK, fh, datatype, count);
 #endif /* MPI_hpux */
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_at: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (offset < 0) {
+    if (offset < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadoffset", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_at: Invalid offset argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_at: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE,
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_at: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
-    if (count*datatype_size == 0) {
+    if (count*datatype_size == 0)
+    {
 #ifdef MPI_hpux
 	HPMP_IO_END(fl_xmpi, fh, datatype, count);
 #endif /* MPI_hpux */
 #ifdef HAVE_STATUS_SET_BYTES
        MPIR_Status_set_bytes(status, datatype, 0);
 #endif
 	
 	return MPI_SUCCESS;
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO,
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_at: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**ioamodeseq", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_at: Can't use this function because file was opened with MPI_MODE_SEQUENTIAL\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                         MPIR_ERR_AMODE_SEQ, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
-    if (fh->access_mode & MPI_MODE_RDONLY) {
+
+    if (fh->access_mode & MPI_MODE_RDONLY)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_READ_ONLY,
 	    "**filerdonly", "**filerdonly %s", fh->filename );
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write: Can't use this function because file was opened with MPI_MODE_RDONLY\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_READ_ONLY, 
                         0, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
-
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_write_at", &error_code);
 
     /* contiguous or strided? */
 
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
     /* convert bufocunt and offset to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * offset;
 
         /* if atomic mode requested, lock (exclusive) the region, because there
            could be a concurrent noncontiguous request. Locking doesn't 
            work on PIOFS and PVFS, and on NFS it is done in the ADIO_WriteContig.*/
 
@@ -194,17 +207,19 @@
 		     off, status, &error_code); 
 
         if ((fh->atomicity) && (fh->file_system != ADIO_PIOFS) && 
             (fh->file_system != ADIO_NFS) && (fh->file_system != ADIO_PVFS)&&
 	    	(fh->file_system != ADIO_PVFS2))
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
     else
+    {
 	ADIO_WriteStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			 offset, status, &error_code); 
     /* For strided and atomic mode, locking is done in ADIO_WriteStrided */
+    }
 
 #ifdef MPI_hpux
     HPMP_IO_END(fl_xmpi, fh, datatype, count);
 #endif /* MPI_hpux */
     return error_code;
 }
Index: romio/mpi-io/write_ordb.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/write_ordb.c,v
retrieving revision 1.20
retrieving revision 1.21
--- romio/mpi-io/write_ordb.c	25 Sep 2003 13:25:11 -0000	1.20
+++ romio/mpi-io/write_ordb.c	12 Feb 2004 06:09:17 -0000	1.21
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_ordb.c,v 1.20 2003/09/25 13:25:11 gropp Exp $    
+ *   $Id: write_ordb.c,v 1.21 2004/02/12 06:09:17 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -42,127 +42,140 @@
 {
     int error_code, datatype_size, nprocs, myrank, incr;
     int source, dest;
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     static char myname[] = "MPI_FILE_WRITE_ORDERED_BEGIN";
 #endif
     ADIO_Offset shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_ordered_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_ordered_begin: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE,
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_ordered_begin: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcoll", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_ordered_begin: Only one active split collective I/O operation allowed per file handle\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_MULTIPLE_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_ordered_begin: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
     if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) ||
-		    (fh->file_system == ADIO_PVFS2)) {
+		    (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_ordered_begin: Shared file pointer not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_write_ordered_begin", &error_code);
+    /* --END ERROR HANDLING-- */
 
     MPI_Comm_size(fh->comm, &nprocs);
     MPI_Comm_rank(fh->comm, &myrank);
 
     incr = (count*datatype_size)/fh->etype_size;
     /* Use a message as a 'token' to order the operations */
     source = myrank - 1;
     dest   = myrank + 1;
     if (source < 0) source = MPI_PROC_NULL;
     if (dest >= nprocs) dest = MPI_PROC_NULL;
     MPI_Recv( NULL, 0, MPI_BYTE, source, 0, fh->comm, MPI_STATUS_IGNORE );
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #else
 	FPRINTF(stderr, "MPI_File_write_ordered_begin: Error! Could not access shared file pointer.\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
     MPI_Send( NULL, 0, MPI_BYTE, dest, 0, fh->comm );
 
     ADIO_WriteStridedColl(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			 shared_fp, &fh->split_status, &error_code);
 
     /* FIXME: Check for error code from WriteStridedColl? */
     return error_code;
 }
Index: romio/mpi-io/write_orde.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/write_orde.c,v
retrieving revision 1.15
retrieving revision 1.16
--- romio/mpi-io/write_orde.c	8 Sep 2003 13:35:05 -0000	1.15
+++ romio/mpi-io/write_orde.c	12 Feb 2004 06:09:19 -0000	1.16
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_orde.c,v 1.15 2003/09/08 13:35:05 gropp Exp $    
+ *   $Id: write_orde.c,v 1.16 2004/02/12 06:09:19 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -38,39 +38,43 @@
 @*/
 int MPI_File_write_ordered_end(MPI_File fh, void *buf, MPI_Status *status)
 {
 #if defined(MPICH2) || !defined(PRINT_ERR_MSG)
     int error_code;
     static char myname[] = "MPI_FILE_WRITE_ORDERED_END";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_ordered_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_ordered_end: Does not match a previous MPI_File_write_ordered_begin\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_NO_SPLIT_COLL,
                               myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     if (status != MPI_STATUS_IGNORE)
        *status = fh->split_status;
 #endif
     fh->split_coll_count = 0;
 
     return MPI_SUCCESS;
Index: romio/mpi-io/write_sh.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/mpi-io/write_sh.c,v
retrieving revision 1.19
retrieving revision 1.21
--- romio/mpi-io/write_sh.c	15 Sep 2003 13:33:36 -0000	1.19
+++ romio/mpi-io/write_sh.c	20 Feb 2004 19:47:59 -0000	1.21
@@ -1,11 +1,11 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_sh.c,v 1.19 2003/09/15 13:33:36 gropp Exp $    
+ *   $Id: write_sh.c,v 1.21 2004/02/20 19:47:59 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
  */
 
 #include "mpioimpl.h"
 
 #ifdef HAVE_WEAK_SYMBOLS
@@ -54,103 +54,115 @@
     if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
 	FPRINTF(stderr, "MPI_File_write_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
 #else
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_shared: Invalid count argument\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_shared: Invalid datatype\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
     if (count*datatype_size == 0) {
 #ifdef HAVE_STATUS_SET_BYTES
        MPIR_Status_set_bytes(status, datatype, 0);
 #endif
 	return MPI_SUCCESS; 
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
         FPRINTF(stderr, "MPI_File_write_shared: Only an integral number of etypes can be accessed\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,
 				     myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #elif defined(PRINT_ERR_MSG)
 	FPRINTF(stderr, "MPI_File_write_shared: Shared file pointer not supported on PIOFS and PVFS\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
 	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, 
                     MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_write_shared", &error_code);
 
     incr = (count*datatype_size)/fh->etype_size;
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
 #else
 	FPRINTF(stderr, "MPI_File_write_shared: Error! Could not access shared file pointer.\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* contiguous or strided? */
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
         /* convert bufocunt and shared_fp to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * shared_fp;
 
         /* if atomic mode requested, lock (exclusive) the region, because there
            could be a concurrent noncontiguous request. On NFS, locking is 
            done in the ADIO_WriteContig.*/
 
@@ -159,14 +171,16 @@
 
 	ADIO_WriteContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 		     off, status, &error_code); 
 
         if ((fh->atomicity) && (fh->file_system != ADIO_NFS))
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
     else
+    {
 	ADIO_WriteStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
 			 shared_fp, status, &error_code); 
     /* For strided and atomic mode, locking is done in ADIO_WriteStrided */
+    }
 
     return error_code;
 }
Index: romio/test/Makefile.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/Makefile.in,v
retrieving revision 1.22
retrieving revision 1.23
--- romio/test/Makefile.in	25 Feb 2003 20:55:25 -0000	1.22
+++ romio/test/Makefile.in	1 Jun 2004 19:21:24 -0000	1.23
@@ -69,13 +69,13 @@
 	$(F77) $(USER_FFLAGS) -o  $@ $< $(OUR_LIBS)
 
 fmisc: fmisc.f
 	$(F77) $(USER_FFLAGS) -o  $@ $< $(OUR_LIBS)
 
 pfcoll_test: pfcoll_test.f	
 	$(F77) $(USER_FFLAGS) -o  $@ $< $(OUR_LIBS)
 
-testing: 
-	-./runtests $(TESTARGS)
+#testing: 
+#	-./runtests $(TESTARGS)
 
 cleanall:
-	-@rm -f .P* PI* misc.c large_file.c fcoll_test.f fmisc.f fperf.f \mpif.h simple async coll_test coll_perf misc perf fcoll_test fperf fmisc file_info excl large_array large_file noncontig i_noncontig noncontig_coll atomicity *.out runtests pfcoll_test.f noncontig_coll2
+	-@rm -f .P* PI* misc.c large_file.c fcoll_test.f fmisc.f fperf.f \mpif.h simple async coll_test coll_perf misc perf fcoll_test fperf fmisc file_info excl large_array large_file noncontig i_noncontig noncontig_coll atomicity *.out runtests pfcoll_test.f pfcoll_test noncontig_coll2
Index: romio/test/Mfile.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/Mfile.in,v
retrieving revision 1.3
retrieving revision 1.4
--- romio/test/Mfile.in	28 Mar 2003 21:37:34 -0000	1.3
+++ romio/test/Mfile.in	8 Jun 2004 19:13:33 -0000	1.4
@@ -46,17 +46,17 @@
 testing: 
 	  -./runtests $(TESTARGS)
 
 all: testing
 
 fortran_tests: $(FTESTS)
 #
 # The Fortran tests must be built with the Fortran linker
-fperf: ${srcdir}/fperf.f
+fperf: fperf.f
 	$(F77) $(USER_FFLAGS) -o  $@ $< $(FLIBS)
 
 # Some of the Fortran tests must be derived, so their code will be in the
 # LOCAL directory
 fcoll_test: fcoll_test.f
 	$(F77) $(USER_FFLAGS) -o  fcoll_test fcoll_test.f $(FLIBS)
 
 fmisc: fmisc.f
Index: romio/test/async.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/async.c,v
retrieving revision 1.6
retrieving revision 1.7
--- romio/test/async.c	23 Feb 2003 16:17:22 -0000	1.6
+++ romio/test/async.c	27 Jan 2004 23:23:37 -0000	1.7
@@ -61,27 +61,36 @@
     tmp = (char *) malloc(len+10);
     strcpy(tmp, filename);
     sprintf(filename, "%s.%d", tmp, rank);
 
     MPI_File_open(MPI_COMM_SELF, filename, MPI_MODE_CREATE | MPI_MODE_RDWR, 
                   MPI_INFO_NULL, &fh);
     MPI_File_set_view(fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL);
     MPI_File_iwrite(fh, buf, nints, MPI_INT, &request);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait( &request, &status );
+#else    
     MPIO_Wait(&request, &status);
+#endif
     MPI_File_close(&fh);
 
     /* reopen the file and read the data back */
 
     for (i=0; i<nints; i++) buf[i] = 0;
     MPI_File_open(MPI_COMM_SELF, filename, MPI_MODE_CREATE | MPI_MODE_RDWR, 
                   MPI_INFO_NULL, &fh);
     MPI_File_set_view(fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL);
     MPI_File_iread(fh, buf, nints, MPI_INT, &request);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait( &request, &status );
+#else
     MPIO_Wait(&request, &status);
+#endif
+
     MPI_File_close(&fh);
 
     /* check if the data read is correct */
     for (i=0; i<nints; i++) {
 	if (buf[i] != (rank*100000 + i)) {
 	    errs++;
 	    fprintf(stderr, "Process %d: error, read %d, should be %d\n", rank, buf[i], rank*100000+i);
 	}
Index: romio/test/coll_test.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/coll_test.c,v
retrieving revision 1.8
retrieving revision 1.9
--- romio/test/coll_test.c	28 May 2003 23:52:20 -0000	1.8
+++ romio/test/coll_test.c	1 Jun 2004 19:21:24 -0000	1.9
@@ -14,16 +14,18 @@
 /* Uses collective I/O. Writes a 3D block-distributed array to a file
    corresponding to the global array in row-major (C) order, reads it
    back, and checks that the data read is correct. */
 
 /* The file name is taken as a command-line argument. */
 
 /* Note that the file access pattern is noncontiguous. */
    
+void handle_error(int errcode, char *str);
+
 void handle_error(int errcode, char *str)
 {
 	char msg[MPI_MAX_ERROR_STRING];
 	int resultlen;
 	MPI_Error_string(errcode, msg, &resultlen);
 	fprintf(stderr, "%s: %s\n", str, msg);
 	MPI_Abort(MPI_COMM_WORLD, 1);
 }
Index: romio/test/fperf.f.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/fperf.f.in,v
retrieving revision 1.1.1.1
retrieving revision 1.2
--- romio/test/fperf.f.in	15 May 1998 20:48:15 -0000	1.1.1.1
+++ romio/test/fperf.f.in	1 Jun 2004 19:21:24 -0000	1.2
@@ -1,13 +1,13 @@
       program main
       implicit none
 
       include 'mpif.h'
-      include 'mpiof.h'
+      @F77MPIOINC@
 
 !     Fortran equivalent of perf.c
 
       integer SIZE 
       parameter (SIZE=1048576*4)
 !     read/write size per node in bytes
 
       integer buf(SIZE/4), j, mynod, nprocs, ntimes, flag
Index: romio/test/i_noncontig.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/i_noncontig.c,v
retrieving revision 1.6
retrieving revision 1.7
--- romio/test/i_noncontig.c	23 Feb 2003 16:31:15 -0000	1.6
+++ romio/test/i_noncontig.c	29 Jan 2004 16:30:22 -0000	1.7
@@ -86,24 +86,32 @@
 
     MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_CREATE | 
              MPI_MODE_RDWR, MPI_INFO_NULL, &fh);
 
     MPI_File_set_view(fh, 0, MPI_INT, newtype, "native", MPI_INFO_NULL);
 
     for (i=0; i<SIZE; i++) buf[i] = i + mynod*SIZE;
     MPI_File_iwrite(fh, buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     MPI_Barrier(MPI_COMM_WORLD);
 
     for (i=0; i<SIZE; i++) buf[i] = -1;
 
     MPI_File_iread_at(fh, 0, buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     for (i=0; i<SIZE; i++) {
 	if (!mynod) {
 	    if ((i%2) && (buf[i] != -1)) {
 		errs++;
 		fprintf(stderr, "Process %d: buf %d is %d, should be -1\n", 
 			mynod, i, buf[i]);
 	    }
@@ -139,24 +147,32 @@
     }
     MPI_Barrier(MPI_COMM_WORLD);
 
     MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_CREATE | 
              MPI_MODE_RDWR, MPI_INFO_NULL, &fh);
 
     for (i=0; i<SIZE; i++) buf[i] = i + mynod*SIZE;
     MPI_File_iwrite_at(fh, mynod*(SIZE/2)*sizeof(int), buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     MPI_Barrier(MPI_COMM_WORLD);
 
     for (i=0; i<SIZE; i++) buf[i] = -1;
 
     MPI_File_iread_at(fh, mynod*(SIZE/2)*sizeof(int), buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     for (i=0; i<SIZE; i++) {
 	if (!mynod) {
 	    if ((i%2) && (buf[i] != -1)) {
 		errs++;
 		fprintf(stderr, "Process %d: buf %d is %d, should be -1\n", 
 			mynod, i, buf[i]);
 	    }
@@ -194,24 +210,32 @@
 
     MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_CREATE | 
              MPI_MODE_RDWR, MPI_INFO_NULL, &fh);
 
     MPI_File_set_view(fh, 0, MPI_INT, newtype, "native", MPI_INFO_NULL);
 
     for (i=0; i<SIZE; i++) buf[i] = i + mynod*SIZE;
     MPI_File_iwrite(fh, buf, SIZE, MPI_INT, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     MPI_Barrier(MPI_COMM_WORLD);
 
     for (i=0; i<SIZE; i++) buf[i] = -1;
 
     MPI_File_iread_at(fh, 0, buf, SIZE, MPI_INT, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     for (i=0; i<SIZE; i++) {
 	if (!mynod) {
 	    if (buf[i] != i) {
 		errs++;
 		fprintf(stderr, "Process %d: buf %d is %d, should be %d\n", 
 			mynod, i, buf[i], i);
 	    }
Index: romio/test/misc.c.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/misc.c.in,v
retrieving revision 1.4
retrieving revision 1.5
--- romio/test/misc.c.in	25 Mar 2003 15:37:02 -0000	1.4
+++ romio/test/misc.c.in	1 Jun 2004 19:21:24 -0000	1.5
@@ -71,17 +71,17 @@
 	fprintf(stderr, "atomicity is %d, should be 0\n", flag);
     }
 #if VERBOSE
     if (!mynod) fprintf(stderr, "setting atomic mode\n");
 #endif
     MPI_File_set_atomicity(fh, 1);
     MPI_File_get_atomicity(fh, &flag);
     if (!flag) {
-	errs;
+	errs++;
 	fprintf(stderr, "atomicity is %d, should be 1\n", flag);
     }
     MPI_File_set_atomicity(fh, 0);
 #if VERBOSE
     if (!mynod) fprintf(stderr, "reverting back to nonatomic mode\n");
 #endif
 
     MPI_Type_vector(10, 10, 20, MPI_INT, &newtype);
Index: romio/test/noncontig_coll2.c
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/noncontig_coll2.c,v
retrieving revision 1.9
retrieving revision 1.10
--- romio/test/noncontig_coll2.c	2 Dec 2003 21:05:59 -0000	1.9
+++ romio/test/noncontig_coll2.c	1 Jun 2004 19:21:24 -0000	1.10
@@ -35,16 +35,32 @@
  */ 
 struct ADIO_cb_name_arrayD {   
        int refct;              
        int namect;
        char **names;
 };  
 typedef struct ADIO_cb_name_arrayD *ADIO_cb_name_array;
 
+void handle_error(int errcode, char *str);
+int cb_copy_name_array(MPI_Comm comm, 
+		       int *keyval, 
+		       void *extra, 
+		       void *attr_in,
+		       void **attr_out, 
+		       int *flag);
+int cb_delete_name_array(MPI_Comm comm, 
+			 int *keyval, 
+			 void *attr_val, 
+			 void *extra);
+int cb_gather_name_array(MPI_Comm comm, ADIO_cb_name_array *arrayp);
+void default_str(int mynod, int len, ADIO_cb_name_array array, char *dest);
+void reverse_str(int mynod, int len, ADIO_cb_name_array array, char *dest);
+void reverse_alternating_str(int mynod, int len, ADIO_cb_name_array array, char *dest);
+void simple_shuffle_str(int mynod, int len, ADIO_cb_name_array array, char *dest);
 
 
 void handle_error(int errcode, char *str) 
 {
 	char msg[MPI_MAX_ERROR_STRING];
 	int resultlen;
 	MPI_Error_string(errcode, msg, &resultlen);
 	fprintf(stderr, "%s: %s\n", str, msg);
Index: romio/test/runtests.in
===================================================================
RCS file: /home/MPI/cvsMaster/romio/test/runtests.in,v
retrieving revision 1.10
retrieving revision 1.11
--- romio/test/runtests.in	19 Dec 2002 22:31:35 -0000	1.10
+++ romio/test/runtests.in	8 Jan 2004 22:39:12 -0000	1.11
@@ -1,11 +1,11 @@
 #! /bin/sh
 mpirun="@MPIRUN@"
-STOPFILE=$HOME/.stopmpichtests
+STOPFILE=${MPITEST_STOPTEST:-"$HOME/.stopmpichtests"}
 #
 # If the programs are not available, run make.
 runtests=1
 makeeach=0
 check_at_once=1
 quiet=0
 MAKE="@MAKE@"
 srcdir=@srcdir@
Index: romio/util/nfslock.c
===================================================================
RCS file: romio/util/nfslock.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ romio/util/nfslock.c	20 Jan 2004 16:23:54 -0000	1.2
@@ -0,0 +1,69 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/*  
+ *  (C) 2004 by Argonne National Laboratory.
+ *      See COPYRIGHT in top-level directory.
+ */
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+
+/*
+ * This routine tests to see if fcntl returns success when asked to 
+ * establish a file lock.  This test is intended for use on file systems
+ * such as NFS that may not implement file locks.  ROMIO makes use
+ * of file locks to implement certain operations, and may not work
+ * properly if file locks are not available.  
+ *
+ * This is a simple test and has at least two limitations:
+ * 
+ * 1. Some implementations of NFS are known to return success for 
+ * setting a file lock when in fact no lock has been set.  This
+ * test will not detect such erroneous implementations of NFS
+ *
+ * 2. Some implementations will hang (enter and wait indefinitately)
+ * within the fcntl call.  This program will also hang in that case.
+ * Under normal conditions, this program should only take a few seconds to 
+ * run.
+ *
+ * This program prints a message showing the success or failure of
+ * setting the file lock and sets the return status to 0 on success and
+ * non-zero on failure.  If there is a failure, the system routine
+ * perror is also called to explain the reason.
+ */
+int main( int argc, char *argv[] )
+{
+    struct flock lock;
+    int fd, err;
+    char *filename;
+
+    /* Set the filename.  Either arg[1] or conftest.dat */
+    if (argc > 1 && argv[1]) {
+      filename = argv[1];
+    }
+    else {
+      filename = "conftest.dat";
+    }
+
+       
+    lock.l_type   = F_WRLCK;
+    lock.l_start  = 0;
+    lock.l_whence = SEEK_SET;
+    lock.l_len    = 100;
+
+    fd = open(filename, O_RDWR | O_CREAT, 0644);
+
+    err = fcntl(fd, F_SETLKW, &lock);
+
+    if (err) {
+      printf( "Failed to set a file lock on %s\n", filename );
+      perror( "Reason " );
+    }
+    else {
+      printf( "fcntl claims success in setting a file lock on %s\n", filename );
+    }
+   /* printf("err = %d, errno = %d\n", err, errno); */
+    close(fd);
+    unlink( filename );
+    return err;
+}
